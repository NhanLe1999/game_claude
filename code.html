<!DOCTYPE html>
<html>
<head>
    <title>Grand Theft Astro</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Denk+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

      <script src="asset_map.local.js"></script>
    <script src="lib_stub.js"></script>

    
    <style>
        /* CSS Reset & Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            font-family: 'Poppins', sans-serif;
            background: #87CEEB;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* CSS Custom Properties */
        :root {
            /* Animation Timings */
            --transition-fast: 150ms;
            --transition-normal: 300ms;
            --transition-slow: 500ms;
            
            /* Easing Functions */
            --ease-out: cubic-bezier(0.0, 0, 0.2, 1);
            --ease-bounce: cubic-bezier(0.68, -0.6, 0.32, 1.6);
            
            /* Spacing Scale */
            --space-xs: 8px;
            --space-sm: 16px;
            --space-md: 24px;
            --space-lg: 32px;
            --space-xl: 48px;
            
            /* Color System */
            --color-primary: #4CAF50;
            --color-primary-hover: #45a049;
            --color-accent: #2196F3;
            --color-accent-hover: #1976D2;
            --color-surface: rgba(0, 0, 0, 0.85);
            --color-surface-light: rgba(255, 255, 255, 0.1);
            --color-text: #FFFFFF;
            --color-text-secondary: rgba(255, 255, 255, 0.7);
            
            /* Shadows & Effects */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.3);
            --backdrop-blur: blur(12px);
        }
        
        /* Game Container */
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        
        /* Joystick Controls */
        #joystick {
            position: absolute;
            bottom: var(--space-md);
            left: var(--space-md);
            width: 240px;
            height: 240px;
            background: var(--color-surface-light);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 100;
            backdrop-filter: var(--backdrop-blur);
            box-shadow: var(--shadow-sm);
            display: none; /* Hidden by default, shown on touch */
            opacity: 0;
            pointer-events: none; /* Don't capture events, let gameContainer handle them */
            /* Hardware acceleration for smoother rendering */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        #joystick.active {
            display: block;
        }

        #joystickKnob {
            position: absolute;
            width: 80px;
            height: 80px;
            background: var(--color-text);
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: var(--shadow-sm);
        }
        

        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Minimap Styles */
        .minimap-container {
            position: absolute;
            top: 140px;
            right: 20px;
            width: 200px;
            height: 200px;
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 1000;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        

        




        /* Debug Coordinates Display */
        #debugCoords {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            text-align: center;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 16px;
            border-radius: 8px;
            backdrop-filter: blur(8px);
            pointer-events: none;
            border: 2px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Hide elements by default */
        .hidden {
            display: none !important;
        }

        /* UI Elements */
        .ui-element {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
        }

        .ui-bullets {
            top: 60px;
            left: 20px;
            width: 90px;
            height: 90px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: transparent;
        }

        /* Hold Up Button */
        .hold-up-button {
            position: absolute;
            bottom: 160px; /* Above the gun button */
            right: 24px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; /* Circular */
            z-index: 100;
            backdrop-filter: blur(12px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease-out;
        }

        .hold-up-button.pressed {
            transform: scale(1.1);
        }

        .hold-up-button-icon {
            width: 75px;
            height: 75px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: transparent;
            pointer-events: none;
            transition: transform 0.15s ease-out;
        }

        /* Weapon Switch Button */
        .weapon-switch-button {
            position: absolute;
            bottom: 160px; /* Above the hold up button */
            left: 24px; /* Left side, opposite of gun button */
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 100;
            backdrop-filter: blur(12px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease-out;
            font-family: 'Denk One', cursive;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }

        .weapon-switch-button.pressed {
            transform: scale(1.1);
        }

        .weapon-switch-button.flash {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.9);
            color: black;
        }

        /* Weapon Indicator */
        .weapon-indicator {
            position: absolute;
            bottom: 92px; /* Positioned directly above weapon switch buttons (24px + 60px + 8px gap) */
            right: 160px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            color: white;
            font-family: 'Denk One', cursive;
            font-size: 18px;
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        /* Weapon Switch Buttons */
        .weapon-switch-container {
            position: absolute;
            bottom: 24px;
            right: 160px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .weapon-switch-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .weapon-switch-btn.active {
            background: rgba(255, 255, 255, 0.2);
            border-color: #FFD700;
            transform: scale(1.1);
        }

        .weapon-switch-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .weapon-switch-btn.locked {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        .weapon-switch-btn.locked:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.3);
            transform: none;
        }

        .weapon-switch-icon {
            width: 40px;
            height: 40px;
            image-rendering: pixelated;
            background: transparent center/contain no-repeat;
        }

        /* Circular Gun Button */
        .gun-button {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 100;
            backdrop-filter: blur(12px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease-out;
        }

        .gun-button.pressed {
            transform: scale(1.1);
        }

        .gun-button.flash {
            background: rgba(255, 255, 255, 0.8);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .gun-button-icon {
            width: 75px;
            height: 75px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: transparent;
            pointer-events: none;
            transition: transform 0.15s ease-out;
        }

        .ui-cash {
            top: 60px;
            right: 20px;
            width: 90px;
            height: 90px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: transparent;
        }

        .ui-text {
            font-family: 'Denk One', cursive;
            font-size: 56px;
            color: white;
            text-shadow: 
                -2px -2px 0 black,
                2px -2px 0 black,
                -2px 2px 0 black,
                2px 2px 0 black,
                -2px 0 0 black,
                2px 0 0 black,
                0 -2px 0 black,
                0 2px 0 black;
            position: absolute;
            top: 50px;
            line-height: 1;
            pointer-events: none;
        }

        .ui-ammo {
            left: 120px;
            top: 80px;
        }

        .ui-money {
            right: 120px;
            text-align: right;
            top: 80px;
        }

        /* Money scaling animation */
        .money-scale-animation {
            animation: moneyScale 0.3s ease-out;
        }

        @keyframes moneyScale {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); }
            100% { transform: scale(1); }
        }

        /* Health Bar */
        .health-bar-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 340px; /* Halfway across 720px screen */
            height: 40px;
            z-index: 1000;
            display: flex;
            align-items: center;
        }

        .health-heart {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: transparent center/contain no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #FF1493;
        }

        .health-bar {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #000;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF1493 0%, #DC143C 100%);
            transition: width 0.3s ease-out;
            width: 100%;
        }

        /* Star System */
        .star-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: row-reverse;
            gap: 8px;
            z-index: 1000;
        }

        .star {
            width: 40px;
            height: 40px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: transparent center/contain no-repeat;
            opacity: 0.35;
            transition: opacity 0.3s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #FFD700;
        }

        .star.filled {
            opacity: 1;
        }

        .star.flashing {
            animation: starFlash 0.5s infinite alternate;
        }

        @keyframes starFlash {
            0% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        /* Quest System */
        .quest-container {
            position: absolute;
            top: 160px;
            left: 20px;
            width: 400px;
            max-width: calc(100vw - 40px);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            z-index: 1000;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .quest-title {
            font-family: 'Denk One', cursive;
            font-size: 18px;
            color: #FFD700;
            margin: 0 0 8px 0;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .quest-description {
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            color: white;
            margin: 0;
            line-height: 1.4;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .quest-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 12px;
            transition: transform 0.3s ease-out;
            display: none;
        }

        .quest-arrow::before {
            content: '';
            position: absolute;
            left: 0;
            top: 4px;
            width: 12px;
            height: 4px;
            background: #FFD700;
        }

        .quest-arrow::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            width: 0;
            height: 0;
            border-left: 8px solid #FFD700;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }

        .quest-target-circle {
            position: absolute;
            border: 3px solid #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            animation: questPulse 2s infinite;
        }

        @keyframes questPulse {
            0% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% { 
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Vendor Shop UI */
        .vendor-button {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            z-index: 1001;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .vendor-button:hover {
            transform: scale(1.1);
        }

        .vendor-shop {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-width: 90vw;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            padding: 20px;
            z-index: 2000;
            backdrop-filter: blur(12px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            display: none;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .vendor-shop.show {
            display: block;
        }

        .vendor-shop-header {
            font-family: 'Denk One', cursive;
            font-size: 24px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .vendor-shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .vendor-item {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            touch-action: manipulation; /* Optimize for touch */
        }

        .vendor-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.02);
        }

        .vendor-item-icon {
            width: 40px;
            height: 40px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            background: transparent center/contain no-repeat;
        }

        .vendor-item-info {
            flex: 1;
        }

        .vendor-item-name {
            font-family: 'Denk One', cursive;
            font-size: 16px;
            color: white;
            margin-bottom: 5px;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .vendor-item-price {
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            color: #4CAF50;
            font-weight: bold;
        }

        .vendor-close-button {
            background: rgba(255, 0, 0, 0.8);
            border: 2px solid white;
            border-radius: 8px;
            padding: 10px 20px;
            color: white;
            font-family: 'Denk One', cursive;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 auto;
            display: block;
            pointer-events: auto;
            touch-action: manipulation;
        }

        .vendor-close-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Quest Dialog */
        .quest-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-width: 90vw;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            padding: 20px;
            z-index: 2000;
            backdrop-filter: blur(12px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            display: none;
        }

        .quest-dialog.show {
            display: block;
        }

        .quest-dialog-title {
            font-family: 'Denk One', cursive;
            font-size: 24px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .quest-dialog-description {
            font-family: 'Poppins', sans-serif;
            font-size: 16px;
            color: white;
            margin-bottom: 30px;
            line-height: 1.5;
            text-align: center;
        }

        .quest-dialog-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        .quest-dialog-button {
            border: 2px solid white;
            border-radius: 8px;
            padding: 10px 20px;
            color: white;
            font-family: 'Denk One', cursive;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quest-dialog-button.accept {
            background: rgba(0, 255, 0, 0.8);
        }

        .quest-dialog-button.cancel {
            background: rgba(255, 0, 0, 0.8);
        }

        .quest-dialog-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Dialog System */
        .dialog-window {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border-top: 3px solid rgba(255, 255, 255, 0.6);
            padding: 20px;
            z-index: 2500;
            backdrop-filter: blur(12px);
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.8);
            display: none;
            cursor: pointer;
            user-select: none;
        }
        
        /* Dialog Player Model */
        .dialog-player-model {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);width: 720px;height: 1280px;
            z-index: 2400;
            pointer-events: none;
            display: none;
        }

        .dialog-window.show {
            display: block;
        }

        .dialog-content {
            max-width: 90%;
            margin: 0 auto;
        }

        .dialog-speaker {
            font-family: 'Denk One', cursive;
            font-size: 36px;
            color: #FFD700;
            margin-bottom: 10px;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .dialog-text {
            font-family: 'Poppins', sans-serif;
            font-size: 32px;
            color: white;
            line-height: 1.5;
            margin-bottom: 15px;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .dialog-next-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            padding: 8px 16px;
            color: white;
            font-family: 'Denk One', cursive;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 
                -1px -1px 0 black,
                1px -1px 0 black,
                -1px 1px 0 black,
                1px 1px 0 black;
        }

        .dialog-next-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }


    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: url('https://d2oir5eh8rty2e.cloudfront.net/assets/images/8892c3e9-8108-4a0e-9d99-0224c7d2ffde.webp'); background-size: cover; background-position: center; background-repeat: no-repeat; z-index: 10003; opacity: 1;"></div>

    <div id="gameContainer">
        
        <!-- Health Bar -->
        <div class="health-bar-container">
            <div class="health-heart" id="healthHeart">❤</div>
            <div class="health-bar">
                <div class="health-bar-fill" id="healthBarFill"></div>
            </div>
        </div>
        
        <!-- Star System -->
        <div class="star-container">
            <div class="star" id="star1">⭐</div>
            <div class="star" id="star2">⭐</div>
            <div class="star" id="star3">⭐</div>
            <div class="star" id="star4">⭐</div>
            <div class="star" id="star5">⭐</div>
        </div>
        
        <!-- Quest System -->
        <div class="quest-container" id="questContainer" style="display: none;">
            <div class="quest-title" id="questTitle">No Active Quest</div>
            <div class="quest-description" id="questDescription">Visit a quest location to start a new quest.</div>
            <div class="quest-arrow" id="questArrow"></div>
        </div>
        
        <!-- Minimap -->
        <div class="minimap-container">
            <canvas id="minimapCanvas" class="minimap-canvas" width="200" height="200"></canvas>
        </div>
        
        <!-- Joystick Control -->
        <!-- UI Elements -->
        <div id="bulletIcon" class="ui-element ui-bullets"></div>
        <div id="cashIcon" class="ui-element ui-cash"></div>
        <div id="ammoText" class="ui-text ui-ammo">24</div>
        <div id="moneyText" class="ui-text ui-money">$0</div>
        
        <!-- Weapon System UI -->
        <div id="weaponIndicator" class="weapon-indicator">PISTOL</div>

        <div id="weaponSwitchContainer" class="weapon-switch-container">
            <div class="weapon-switch-btn active" data-weapon="pistol">
                <div class="weapon-switch-icon" id="pistolIcon"></div>
            </div>
            <div class="weapon-switch-btn" data-weapon="uzi">
                <div class="weapon-switch-icon" id="uziIcon"></div>
            </div>
            <div class="weapon-switch-btn" data-weapon="rocketLauncher">
                <div class="weapon-switch-icon" id="rocketIcon"></div>
            </div>
        </div>

        <!-- Circular Gun Button -->
        <div id="holdUpButton" class="hold-up-button">
            <div id="holdUpIcon" class="hold-up-button-icon"></div>
        </div>

        <div id="gunButton" class="gun-button">
            <div id="gunIcon" class="gun-button-icon"></div>
        </div>
        
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
        
        
        <!-- Debug Coordinates Display -->
        <div id="debugCoords" class="hidden">
            X: 0.0, Y: 0.0, Z: 0.0
        </div>

        <!-- FPS Counter Display -->
        <div id="fpsDisplay" style="
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 8px;
            border-radius: 3px;
            z-index: 10000;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        ">FPS: 0</div>

        <!-- Vendor Shop UI -->
        <div id="vendorShop" class="vendor-shop">
            <div class="vendor-shop-header" id="vendorShopTitle">Shop</div>
            <div class="vendor-shop-items" id="vendorShopItems">
                <!-- Items will be populated dynamically -->
            </div>
            <button class="vendor-close-button" id="vendorCloseButton">Close</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script>
        /* global THREE */
        /* ==================================================
         * GAME OVERVIEW: Grand Theft Astro - Shoot shoot bang bang.
         *
         * CONFIGURATION: All settings are constants (see lines 1290-1320)
         *   - BLOCKS_PER_SIDE: World grid size (11 blocks = 10x10 city grid)
         *   - CHARACTER_SPAWN_X/Z: Player spawn point (20, 70)
         *   - WORLD_FLOOR_COLOR: Ground color (#8B4513 brown)
         *   - Fog distance: Calculated as 80% of world size
         *
         * RUNTIME STATE: Procedurally generated each run (module-level variables)
         *   - worldCubes: Building/ground geometry (~338 objects)
         *   - worldDocks: Dock collision data (random positions each run)
         *   - npcCharacters: NPC instances (~121 NPCs on curbs)
         *   - carObjects: Car instances (~80 cars on roads)
         *   - treeObjects: Tree instances (in parks)
         *
         * To adjust settings, modify constants in code and re-export.
         * ==================================================
         */

        let scene, camera, renderer, character, world;
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };
        let isMoving = false;
        let currentMode = 'play';
        let splashActive = false;
        let cubeObjects = [];
        let streetlightObjects = [];
        let treeObjects = []; // Array to store tree objects
        let assetCache = {};
        const AUDIO_ASSET_IDS = ["footstep_grass", "ambient_outdoors"];

        // Web Audio API state
        let audioContext = null;
        let audioBuffers = {};
        let masterGainNode = null;
        let musicGainNode = null;
        let sfxGainNode = null;
        let musicSource = null;
        let lastFootstepTime = 0;
        let shadowPlane = null;
        let npcCharacters = []; // Array to store NPC character objects
        let vendorNPCs = []; // Array to store vendor NPC objects
        let carObjects = []; // Array to store car objects
        let cashBundles = []; // Array to store cash bundle objects
        let projectiles = []; // Array to store projectile objects
        let healthPacks = []; // Array to store health pack objects
        let questGivers = []; // Array to store quest giver NPC objects
        let dockGroups = []; // Array to store dock group data for location generation
        let npcAppearanceMap = {}; // Map of NPC name -> appearance (shirt/hair textures)

        // Minimap variables
        let minimapCanvas = null;
        let minimapCtx = null;
        let minimapOffscreenCanvas = null;
        let minimapOffscreenCtx = null;
        
        // Geometry merging optimization arrays
        let streetlightComponents = { bases: [], poles: [], topBoxes: [] };
        let treeComponents = { trunks: [], leaves: [] };
        let plantComponents = []; // Array to store plant geometries for merging
        let streetSignComponents = {
            mainSt: [], oakAve: [], elmRd: [], parkBlvd: [] // Group by texture
        };
        
        // Weapon System
        const WEAPONS = {
            pistol: {
                name: 'Pistol',
                icon: 'ui_pistol_icon',
                fireRate: 500,
                damage: 20,
                projectileSpeed: 50,
                projectileSize: 0.2,
                projectileColor: 0xFFFF00,
                maxAmmo: 24,
                currentAmmo: 24,
                muzzleFlashSize: 50,
                spread: 0,
                automatic: false
            },
            uzi: {
                name: 'Uzi',
                icon: 'ui_uzi_icon',
                fireRate: 100,
                damage: 15,
                projectileSpeed: 60,
                projectileSize: 0.15,
                projectileColor: 0xFFD700,
                maxAmmo: 50,
                currentAmmo: 50,
                muzzleFlashSize: 30,
                spread: 0.1,
                automatic: true
            },
            rocketLauncher: {
                name: 'Rocket Launcher',
                icon: 'ui_rocketlauncher_icon',
                fireRate: 2000,
                damage: 100,
                projectileSpeed: 30,
                projectileSize: 0.5,
                projectileColor: 0xFF4500,
                maxAmmo: 5,
                currentAmmo: 5,
                muzzleFlashSize: 100,
                spread: 0,
                automatic: false,
                explosive: true,
                explosionRadius: 20
            }
        };

        // Weapon ownership tracking
        const ownedWeapons = new Set(['pistol']); // Start with only pistol

        // Weapon prices for vendors
        const WEAPON_PRICES = {
            uzi: 500,
            rocketLauncher: 2000
        };

        const IS_DEV = false;
        const DEBUG_FAST_MOVEMENT = IS_DEV;
        const DEBUG_SHOW_FPS = IS_DEV;
        const ENABLE_LOADING_SCREEN = true;

        // Car color definitions
        const REGULAR_CAR_COLORS = [
            { color: 0x404040, weight: 30 },  // Grey 30%
            { color: 0xc0c0c0, weight: 30 },  // White 30%
            { color: 0x101010, weight: 20 },  // Black 20%
            { color: 0x004400, weight: 10 },   // Dark Green 10%
            { color: 0xFF0000, weight: 5 },   // Red 5%
            { color: 0x2568cc, weight: 5 }    // Light blue 5%
        ];
        const POLICE_CAR_COLORS = { lower: 0x0000FF, upper: 0xFFFFFF }; // Blue lower, white upper
        const POLICE_CAR_SPAWN_RATE = 0.10; // 10% of cars are police

        // Function to select a random car color based on weights
        function getRandomCarColor() {
            const totalWeight = REGULAR_CAR_COLORS.reduce((sum, c) => sum + c.weight, 0);
            let random = Math.random() * totalWeight;

            for (const colorOption of REGULAR_CAR_COLORS) {
                random -= colorOption.weight;
                if (random <= 0) {
                    return { lower: colorOption.color, upper: colorOption.color };
                }
            }

            // Fallback to first color
            return { lower: REGULAR_CAR_COLORS[0].color, upper: REGULAR_CAR_COLORS[0].color };
        }
        
        // Available pants colors for NPCs
        const PANTS_COLORS = [
            0x1a1a1a,  // Dark grey/black
            0x2F4F4F,  // Dark slate grey
            0x000080,  // Navy blue
            0x2F4F2F,  // Dark green
            0x36454F,  // Charcoal
            0x4B0082,  // Indigo
            0x800020   // Burgundy
        ];

        // NPC Appearance Definitions
        const npcDefinitions = {
            "Switch": {
                shirtTexture: "shirt_suit_texture",
                hairTexture: "hair_black_texture",
                pantsColor: 0x1a1a1a  // Dark grey/black pants
            },
            "Doc K": {
                shirtTexture: "shirt_leather_jacket_texture",
                hairTexture: "hair_grey_texture",
                pantsColor: 0x2F4F2F  // Dark green
            },
            "Rex": {
                shirtTexture: "shirt_red_texture",
                hairTexture: "hair_blonde_texture",
                pantsColor: 0x000080  // Navy blue
            }
        };

        // Quest Chain Data
        const QUEST_CHAINS = {
            "main_story": [
                {
                    id: "Q01",
                    title: "First Night",
                    giverNPC: null,
                    giverName: "Switch",
                    intro_dialog: [
                        {speaker: "Switch", text: "You look fresh off the bus. Hungry? I pay in cash and chances."},
                        {speaker: "Player", text: "Depends on the menu."},
                        {speaker: "Switch", text: "Start simple. Come find me at the High Street Diner. We talk, we see."}
                    ],
                    dialog_solid_background: true,
                    objective: {
                        type: "TALK",
                        targetLocation: "High Street Diner",
                        description: "Meet Switch outside the High Street Diner",
                        minDistance: 50,
                        maxDistance: 150
                    },
                    reward: {cash: 500},
                    autostart_next: true
                },
                {
                    id: "Q02",
                    title: "Starter Package",
                    giverNPC: null,
                    giverName: "Switch",
                    intro_dialog: [
                        {speaker: "Switch", text: "Doc K at the docks needs a parcel—no shakes, no peeks."},
                        {speaker: "Player", text: "What's inside?"},
                        {speaker: "Switch", text: "The kind of question that lowers your rate. Just deliver."}
                    ],
                    objective: {
                        type: "DELIVER_ITEM",
                        item: "Sealed Parcel",
                        fromLocation: "High Street Diner",
                        toLocation: "Dock 12",
                        description: "Deliver the sealed parcel to Doc K at Dock 12",
                        minDistance: 100
                    },
                    reward: {cash: 1000},
                    autostart_next: true
                },
                {
                    id: "Q03",
                    title: "Test Drive",
                    giverNPC: null,
                    giverName: "Doc K",
                    intro_dialog: [
                        {speaker: "Doc K", text: "Chopshop owes me. They want a Kuruma GT—clean condition."},
                        {speaker: "Player", text: "Keys?"},
                        {speaker: "Doc K", text: "Owner keeps them in the ignition. Lucky them, luckier you."}
                    ],
                    objective: {
                        type: "STEAL_CAR",
                        vehicleModel: "Kuruma GT",
                        fromLocation: "Sable Row Parking",
                        toLocation: "Eastside Chopshop",
                        description: "Steal a Kuruma GT and deliver it to Eastside Chopshop",
                        minDistance: 100,
                        maxDistance: 250
                    },
                    reward: {cash: 1500},
                    autostart_next: true
                },
                {
                    id: "Q04",
                    title: "Noise Control",
                    giverNPC: null,
                    giverName: "Rex",
                    intro_dialog: [
                        {speaker: "Rex", text: "Nines sells a signal muffler. We want it, fast."},
                        {speaker: "Player", text: "You buying or me?"},
                        {speaker: "Rex", text: "You buy, we reimburse. Bring a receipt. He hates fakes."}
                    ],
                    objective: {
                        type: "BUY",
                        item: "Signal Muffler Mk.II",
                        vendorName: "Nines",
                        vendorLocation: "Underpass Market",
                        price: 600,
                        description: "Buy a Signal Muffler from Nines at Underpass Market",
                        minDistance: 100,
                        maxDistance: 200
                    },
                    reward: {cash: 900},
                    autostart_next: true
                },
                {
                    id: "Q04B",
                    title: "The Drop-Off",
                    giverNPC: null,
                    giverName: "Rex",
                    intro_dialog: [
                        {speaker: "Rex", text: "You got it? Good. Bring it here, now."},
                        {speaker: "Player", text: "On my way."}
                    ],
                    objective: {
                        type: "DELIVER_ITEM",
                        item: "Signal Muffler Mk.II",
                        fromLocation: "Underpass Market",
                        toLocation: "Eastside Chopshop",
                        description: "Deliver the Signal Muffler to Rex at Eastside Chopshop"
                    },
                    reward: {cash: 300},
                    autostart_next: true
                },
                {
                    id: "Q05",
                    title: "Street Justice",
                    giverNPC: null,
                    giverName: "Rex",
                    intro_dialog: [
                        {speaker: "Rex", text: "It better work."},
                        {speaker: "Rex", text: "Razor's crew hijacked our delivery."},
                        {speaker: "Player", text: "Where's Razor?"},
                        {speaker: "Rex", text: "Pier 4. End him, then scatter."}
                    ],
                    objective: {
                        type: "KILL",
                        targetName: "Razor",
                        targetLocation: "Pier 4",
                        description: "Eliminate Razor at Pier 4",
                        minDistance: 200
                    },
                    reward: {cash: 2000}
                }
            ]
        };

        // World generation constants
        const BLOCKS_PER_SIDE = 11;  // Number of city blocks per side (creates 10x10 grid)
        const BLOCK_SIZE = 60;       // Size of each concrete block in units
        const ROAD_WIDTH = 30;       // Width of roads between blocks in units
        const BLOCK_SPACING = 90;    // Distance between block centers (BLOCK_SIZE + ROAD_WIDTH)
        const WATER_LEVEL = -3;      // Y position of water surface
        const SEAWALL_HEIGHT = 5;    // Height of seawalls (from water level to above ground)
        const ROAD_UNITS_PER_CAR = 240; // Spawn one car per this many units of road

        // Movement speeds
        const PLAYER_MOVE_SPEED = 10; // Player movement speed
        const NPC_MOVE_SPEED = 5;    // NPC patrol speed
        const CARJACK_NPC_RUN_SPEED = 20; // Carjack NPC run speed
        const NPC_SHOOTING_RANGE = 50; // Range in units where aggressive NPCs can shoot

        // ============================================================================
        // GAME CONFIGURATION - Replaces window.gameConfig
        // ============================================================================

        // World settings
        const WORLD_FLOOR_COLOR = "#8B4513";  // Brown ground color

        // Character spawn point
        const CHARACTER_SPAWN_X = 20;
        const CHARACTER_SPAWN_Z = 70;

        // Runtime state (not editable via UI, can be toggled via console)
        let showDebugCoordinates = false;
        // cameraZoomLevel already exists at line 1265

        // Runtime world state (procedurally generated each run)
        let worldCubes = [];   // Building/ground geometry (regenerated from BLOCKS_PER_SIDE)
        let worldDocks = [];   // Dock collision data (random positions each run)

        /**
         * Calculate world size based on number of blocks per side
         * Formula: (N blocks * 60) + ((N-1) roads * 30) = 90N - 30
         * Examples: 2x2 = 150, 5x5 = 420, 10x10 = 870
         */
        function getWorldSize() {
            return BLOCKS_PER_SIDE * BLOCK_SPACING - ROAD_WIDTH;
        }

        // Current weapon state
        let currentWeapon = 'pistol';
        let lastFireTime = 0;
        let isHoldingFire = false;

        // Input state
        let keys = {};
        let weaponSwitchCooldown = 0;

        // Helper Functions
        function applyToMaterials(object, callback) {
            object.traverse((child) => {
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(callback);
                    } else {
                        callback(child.material);
                    }
                }
            });
        }

        function setMaterialOpacity(object, opacity) {
            applyToMaterials(object, (mat) => {
                mat.transparent = true;
                mat.opacity = opacity;
            });
        }

        function setMaterialDarkness(object, darkness) {
            applyToMaterials(object, (mat) => {
                // Remove existing darkening
                mat.color.multiplyScalar(1.0 / (mat.userData.darkening || 1.0));
                // Apply new darkening
                mat.color.multiplyScalar(darkness);
                mat.userData.darkening = darkness;
            });
        }

        function updateNPCShadowPosition(npc, collision) {
            if (npc.userData.shadowPlane) {
                npc.userData.shadowPlane.position.set(
                    npc.position.x,
                    collision.groundHeight + 0.01,
                    npc.position.z
                );
            }
        }

        function loadPixelatedTexture(assetId) {
            const asset = lib.getAsset(assetId);
            if (!asset) return null;

            const texture = new THREE.TextureLoader().load(asset.url);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function createPixelatedMaterial(assetId, fallbackColor) {
            const texture = loadPixelatedTexture(assetId);
            if (texture) {
                return new THREE.MeshLambertMaterial({ map: texture });
            } else if (fallbackColor) {
                return new THREE.MeshLambertMaterial({ color: fallbackColor });
            }
            return null;
        }

        function applyCollisionHeight(object, x, z, currentY) {
            const collision = checkCollisions(x, z, currentY);
            object.position.y = collision.stepUpHeight;
            return collision;
        }

        function createNPCWithData(npcData, npcType = 'regular') {
            const npcCharacter = createCharacter(npcData.x, npcData.z, false);

            // Apply type-specific properties
            switch (npcType) {
                case 'vendor':
                    npcCharacter.userData.isVendor = true;
                    npcCharacter.userData.vendorType = npcData.type;
                    npcCharacter.userData.vendorId = npcData.id;
                    npcCharacter.userData.whenIdle = "stationary";
                    npcCharacter.userData.whenScared = "none";
                    npcCharacter.userData.whenApproached = "none";
                    // Make vendor face a random direction
                    npcCharacter.rotation.y = Math.random() * Math.PI * 2;
                    break;

                case 'questGiver':
                    npcCharacter.userData.isQuestGiver = true;
                    npcCharacter.userData.questGiverId = npcData.id;
                    npcCharacter.userData.hasQuest = npcData.hasQuest !== false;
                    npcCharacter.userData.questOffered = npcData.questOffered || false;
                    npcCharacter.userData.whenIdle = "stationary";
                    npcCharacter.userData.whenScared = "flee";
                    npcCharacter.userData.whenApproached = "none";
                    // Make quest giver face a random direction
                    npcCharacter.rotation.y = Math.random() * Math.PI * 2;
                    break;

                case 'carjack':
                    npcCharacter.userData.isCarjackNPC = true;
                    npcCharacter.userData.originalCar = npcData.car;
                    npcCharacter.userData.fadeInProgress = 0;
                    npcCharacter.userData.isRunningAway = false;
                    npcCharacter.userData.runSpeed = npcData.runSpeed || 15;
                    npcCharacter.userData.runDirectionX = npcData.runDirectionX;
                    npcCharacter.userData.runDirectionZ = npcData.runDirectionZ;
                    npcCharacter.userData.distanceFromCar = 0;
                    npcCharacter.visible = false; // Start invisible for fade-in
                    break;

                case 'regular':
                default:
                    // Regular NPC properties
                    npcCharacter.userData.curbBounds = {
                        centerX: npcData.curbX,
                        centerZ: npcData.curbZ,
                        size: npcData.curbSize
                    };
                    npcCharacter.userData.currentEdge = npcData.currentEdge;
                    npcCharacter.userData.edgeProgress = npcData.edgeProgress;
                    npcCharacter.userData.npcId = npcData.id;
                    break;
            }

            // Position at correct height
            applyCollisionHeight(npcCharacter, npcData.x, npcData.z, npcCharacter.position.y);

            return npcCharacter;
        }

        function animateDialogCharacter(character, breathingTime, headTime, isTalking, otherTalking, headRotation) {
            const breathingScale = 1 + Math.sin(breathingTime) * 0.02;

            if (isTalking) {
                // Character is talking - normal scale and brightness
                character.scale.y = breathingScale;
                setMaterialDarkness(character, 1.0);
            } else if (otherTalking) {
                // Other character is talking - scale down and darken
                character.scale.set(0.8, breathingScale * 0.8, 0.8);
                setMaterialDarkness(character, 0.6);
            } else {
                // No one talking - normal scale and brightness
                character.scale.y = breathingScale;
                setMaterialDarkness(character, 1.0);
            }

            // Subtle head movement
            if (character.children && character.children.length > 1) {
                const head = character.children[1]; // Head is typically the second child
                head.rotation.y = Math.sin(headTime) * headRotation;
            }
        }

        function updateWeaponUI() {
            const weapon = WEAPONS[currentWeapon];

            // Update weapon indicator text
            const indicator = document.getElementById('weaponIndicator');
            if (indicator) {
                indicator.textContent = weapon.name.toUpperCase();
            }

            // Update ammo display
            const ammoText = document.getElementById('ammoText');
            if (ammoText) {
                ammoText.textContent = weapon.currentAmmo;
            }

            // Update gun button icon
            const gunIcon = document.getElementById('gunIcon');
            if (gunIcon) {
                const weaponAsset = lib.getAsset(weapon.icon) || lib.getAsset('ui_pistol_icon');
                if (weaponAsset) {
                    gunIcon.style.background = `url(${weaponAsset.url}) center/contain no-repeat transparent`;
                }
            }

            const holdUpIcon = document.getElementById('holdUpIcon');
            if (holdUpIcon) {
                const holdUpAsset = lib.getAsset('ui_holdup_icon');
                if (holdUpAsset) {
                    holdUpIcon.style.background = `url(${holdUpAsset.url}) center/contain no-repeat transparent`;
                }
            }

            // Update weapon switch buttons
            document.querySelectorAll('.weapon-switch-btn').forEach(btn => {
                const weaponKey = btn.dataset.weapon;
                btn.classList.toggle('active', weaponKey === currentWeapon);

                // Add locked class for unowned weapons
                if (ownedWeapons.has(weaponKey)) {
                    btn.classList.remove('locked');
                } else {
                    btn.classList.add('locked');
                }
            });
        }

        function switchWeapon(weaponKey) {
            if (weaponSwitchCooldown > 0) return;
            if (!WEAPONS[weaponKey]) return;
            if (currentWeapon === weaponKey) return;

            // Check if player owns this weapon
            if (!ownedWeapons.has(weaponKey)) {
                showNotification(`You don't own the ${WEAPONS[weaponKey].name} yet!`);
                return;
            }

            currentWeapon = weaponKey;
            weaponSwitchCooldown = 0.3; // 300ms cooldown

            // Flash the gun button
            const gunButton = document.getElementById('gunButton');
            if (gunButton) {
                gunButton.classList.add('flash');
                setTimeout(() => gunButton.classList.remove('flash'), 150);
            }

            updateWeaponUI();
        }

        function cycleWeapon() {
            const weaponKeys = Object.keys(WEAPONS);
            const ownedWeaponKeys = weaponKeys.filter(key => ownedWeapons.has(key));

            if (ownedWeaponKeys.length <= 1) return; // No other weapons to switch to

            const currentIndex = ownedWeaponKeys.indexOf(currentWeapon);
            const nextIndex = (currentIndex + 1) % ownedWeaponKeys.length;
            switchWeapon(ownedWeaponKeys[nextIndex]);
        }

        function showNotification(message, duration = 3000) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 100px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 15px 25px;
                border-radius: 5px;
                font-size: 18px;
                font-weight: bold;
                z-index: 10001;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 1);
                border: 2px solid rgba(255, 255, 255, 0.3);
                animation: slideDown 0.3s ease-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            // Add animation style if not exists
            if (!document.getElementById('notificationStyle')) {
                const style = document.createElement('style');
                style.id = 'notificationStyle';
                style.textContent = `
                    @keyframes slideDown {
                        from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
                        to { transform: translateX(-50%) translateY(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);
            }

            // Remove after duration
            setTimeout(() => {
                notification.style.animation = 'slideDown 0.3s ease-out reverse';
                setTimeout(() => notification.remove(), 300);
            }, duration);
        }

        function acquireWeapon(weaponKey) {
            if (!WEAPONS[weaponKey]) return false;
            if (ownedWeapons.has(weaponKey)) return false; // Already owned

            ownedWeapons.add(weaponKey);
            showNotification(`🎉 ${WEAPONS[weaponKey].name} Acquired!`, 4000);

            // Give some ammo with the weapon
            WEAPONS[weaponKey].currentAmmo = WEAPONS[weaponKey].maxAmmo;

            updateWeaponUI();
            return true;
        }

        function createExplosion(x, y, z, radius) {
            // Create multiple explosion effects for dramatic impact

            // Main explosion sphere - starts larger and more visible
            const explosionGeometry = new THREE.SphereGeometry(radius * 0.3, 16, 16); // Start at 30% of final size
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4500,
                transparent: true,
                opacity: 1.0 // Start fully opaque
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.set(x, y, z);
            scene.add(explosion);

            // Store explosion for animation
            activeExplosions.push({
                mesh: explosion,
                scale: 0.3, // Start at 30% scale
                maxScale: radius,
                fadeSpeed: 0.02 // Slower fade for more impact
            });

            // Create smoke cloud effect
            for (let i = 0; i < 20; i++) {
                const offsetX = (Math.random() - 0.5) * radius;
                const offsetY = Math.random() * radius * 0.5;
                const offsetZ = (Math.random() - 0.5) * radius;
                spawnSmokeParticle(x + offsetX, y + offsetY, z + offsetZ);
            }

            // Area damage
            checkAreaDamage(x, y, z, radius);

            // Camera shake
            const distanceToPlayer = Math.sqrt(
                Math.pow(x - character.position.x, 2) +
                Math.pow(z - character.position.z, 2)
            );
            if (distanceToPlayer < radius * 2) {
                const intensity = Math.max(0, 1 - distanceToPlayer / (radius * 2));
                triggerCameraShake(intensity * 0.5, 0.3);
            }

            // Massive particle burst for dramatic effect
            spawnExplosionParticles(x, y, z);
            spawnExplosionParticles(x, y, z); // Double the particles
            spawnExplosionParticles(x, y, z); // Triple the particles

            // Play explosion sound if available
        }

        function updateDeathRotation(character, deltaTime) {
            // Update death rotation animation if active
            if (character.userData.deathRotationProgress !== undefined &&
                character.userData.deathRotationProgress < 1) {

                character.userData.deathRotationProgress += deltaTime / character.userData.deathRotationDuration;
                character.userData.deathRotationProgress = Math.min(1, character.userData.deathRotationProgress);

                // Interpolate rotation from initial to target
                const progress = character.userData.deathRotationProgress;
                character.rotation.x = character.userData.initialRotationX +
                    (character.userData.targetRotationX - character.userData.initialRotationX) * progress;
            }
        }

        function killNPC(npc) {
            // Common death setup for NPCs
            npc.userData.isFadingOut = true;
            npc.userData.fadeOutProgress = 0;
            npc.userData.fadeSpeed = 2;
            npc.userData.isDead = true;
            npc.userData.deathDelayTimer = 3.0; // Stay visible for 3 seconds before fading

            // Start death rotation animation (rotate to horizontal over 0.5 seconds)
            npc.userData.deathRotationProgress = 0;
            npc.userData.deathRotationDuration = 0.5;
            npc.userData.initialRotationX = npc.rotation.x;
            npc.userData.targetRotationX = -Math.PI / 2; // 90 degrees forward (horizontal)

            // Spawn red particle burst
            try {
                spawnRedParticleBurst(npc.position.x, npc.position.y, npc.position.z);
            } catch (e) {
                // Could not spawn red particles
            }

            // Raise wanted level: 4 stars for killing police, 2 for civilians
            if (npc.userData.isPoliceOfficer) {
                setWantedLevelForInfraction(4);
            } else {
                setWantedLevelForInfraction(2);
            }

            // Track quest target kills
            if (npc.userData.isQuestTarget && npc.userData.targetName) {
                targetNPCsKilled.add(npc.userData.targetName);
                console.log(`Quest target "${npc.userData.targetName}" eliminated!`);
            }
        }

        function checkAreaDamage(x, y, z, radius) {
            // Damage all NPCs in radius
            let npcsHit = 0;
            let npcsKilled = 0;
            [...npcCharacters, ...vendorNPCs, ...questGivers].forEach(npc => {
                if (!npc.userData.isShot && !npc.userData.isDead && !npc.userData.isFadingOut) {
                    const distance = Math.sqrt(
                        Math.pow(npc.position.x - x, 2) +
                        Math.pow(npc.position.z - z, 2)
                    );
                    if (distance <= radius) {
                        // Calculate distance ratio (0 = at center, 1 = at edge of radius)
                        const distanceRatio = distance / radius;

                        // Calculate launch force based on distance (closer = stronger force)
                        // Force ranges from 25 (at center) to 10 (at edge)
                        const horizontalForce = 25 - (distanceRatio * 15);
                        const verticalForce = 15 - (distanceRatio * 10);

                        // Launch NPCs away from explosion
                        npc.userData.isShot = true;
                        npc.userData.isFlyingFromShot = true;
                        const awayX = distance > 0.1 ? (npc.position.x - x) / distance : 1;
                        const awayZ = distance > 0.1 ? (npc.position.z - z) / distance : 0;

                        // Set velocity for physics system
                        npc.userData.velocity = {
                            x: awayX * horizontalForce,
                            y: verticalForce,
                            z: awayZ * horizontalForce
                        };
                        npc.userData.onGround = false;
                        npc.userData.isFlying = true;
                        npc.userData.bounceCount = 0;

                        // Calculate damage based on distance
                        // Close range (0-30% of radius): 100% damage (instant kill)
                        // Medium range (30-60% of radius): 60-100% damage (likely kill)
                        // Far range (60-100% of radius): 20-60% damage (injury only)
                        let shouldKill = false;
                        if (distanceRatio <= 0.6) {
                            // Close to medium range - kill the NPC
                            shouldKill = true;
                        }

                        if (shouldKill) {
                            // Kill NPC with common death setup
                            killNPC(npc);

                            // Add Y-axis tumbling rotation while flying (unique to explosion)
                            npc.userData.rotationSpeed = 2 + Math.random() * 2;

                            npcsKilled++;
                        }

                        npcsHit++;
                    }
                }
            });

            // Damage and launch player if in radius
            if (character) {
                const distance = Math.sqrt(
                    Math.pow(character.position.x - x, 2) +
                    Math.pow(character.position.z - z, 2)
                );
                if (distance <= radius) {
                    // Calculate distance ratio (0 = at center, 1 = at edge of radius)
                    const distanceRatio = distance / radius;

                    // Calculate launch force based on distance (closer = stronger force)
                    // Force ranges from 30 (at center) to 12 (at edge)
                    const horizontalForce = 30 - (distanceRatio * 18);
                    const verticalForce = 18 - (distanceRatio * 12);

                    // Calculate direction away from explosion
                    const awayX = distance > 0.1 ? (character.position.x - x) / distance : 1;
                    const awayZ = distance > 0.1 ? (character.position.z - z) / distance : 0;

                    // Initialize player physics if not present
                    if (!character.userData.velocity) {
                        character.userData.velocity = { x: 0, y: 0, z: 0 };
                    }

                    // Launch player away from explosion
                    character.userData.velocity.x = awayX * horizontalForce;
                    character.userData.velocity.y = verticalForce;
                    character.userData.velocity.z = awayZ * horizontalForce;
                    character.userData.onGround = false;
                    character.userData.isFlying = true;
                    character.userData.bounceCount = 0;

                    // Apply damage (20-100 based on distance)
                    const damage = Math.max(20, 100 * (1 - distance / radius));
                    damagePlayer(damage);

                    // Visual feedback
                    triggerRedScreenFlash();
                    spawnRedParticleBurst(character.position.x, character.position.y, character.position.z);
                }
            }

            // Destroy cash bundles and ammo pickups in radius
            cashBundles = cashBundles.filter(bundle => {
                // Get position coordinates (bundle is the mesh with position)
                const posX = bundle.position?.x;
                const posZ = bundle.position?.z;

                // Skip if bundle doesn't have valid position
                if (posX === undefined || posZ === undefined) {
                    return true; // Keep bundle in array
                }

                const distance = Math.sqrt(
                    Math.pow(posX - x, 2) +
                    Math.pow(posZ - z, 2)
                );
                if (distance <= radius) {
                    scene.remove(bundle);
                    return false; // Remove from array
                }
                return true; // Keep in array
            });
        }

        function triggerCameraShake(intensity, duration) {
            cameraShakeIntensity = intensity;
            cameraShakeDuration = duration;
        }

        function spawnSmokeParticle(x, y, z) {
            const smokeGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const smokeMaterial = new THREE.MeshBasicMaterial({
                color: 0x666666,
                transparent: true,
                opacity: 0.6
            });
            const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
            smoke.position.set(x, y, z);

            smoke.userData = {
                isParticle: true,
                velocity: {
                    x: (Math.random() - 0.5) * 2,
                    y: Math.random() * 2,
                    z: (Math.random() - 0.5) * 2
                },
                life: 2.0,
                maxLife: 2.0,
                scaleTime: 0,
                flickerTime: 0,
                isSmokeParticle: true
            };

            scene.add(smoke);

            // Store particles for cleanup
            if (!window.gameParticles) window.gameParticles = [];
            window.gameParticles.push(smoke);
        }

        function spawnExplosionParticles(x, y, z) {
            const particleCount = 30; // Reduced to 20% (was 150)
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3); // Original size restored
                const hue = Math.random() * 0.1; // Red to orange range
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 1, 0.5),
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);

                particle.position.set(x, y, z);

                // Random velocity in all directions
                const speed = 10 + Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                particle.userData = {
                    isParticle: true, // Required for cleanup system
                    velocity: {
                        x: Math.sin(phi) * Math.cos(theta) * speed,
                        y: Math.cos(phi) * speed,
                        z: Math.sin(phi) * Math.sin(theta) * speed
                    },
                    life: 1.0, // Changed from lifetime to life
                    maxLife: 1.0, // Required for fade calculation
                    scaleTime: 0, // Required for particle update
                    flickerTime: 0 // Required for particle update
                };

                scene.add(particle);

                // Store particles for cleanup
                if (!window.gameParticles) window.gameParticles = [];
                window.gameParticles.push(particle);
            }
        }

        function initializeQuestChains() {
            // Load quest chain data from constant
            questChainData = QUEST_CHAINS;

            // Named locations will be generated as needed
            // Start empty - locations will be added when first referenced
            namedLocations = {};

            // Start the first quest chain if available
            if (!questChainProgress.currentChain) {
                questChainProgress.currentChain = "main_story";
                questChainProgress.currentIndex = 0;
            }
        }

        function getOrCreateLocation(locationName, options = {}) {

            // Return existing location if already generated
            if (namedLocations[locationName]) {
                return namedLocations[locationName];
            }

            // Set default minDistance/maxDistance if not provided
            if (options.minDistance === undefined) {
                options.minDistance = 100;
            }
            if (options.maxDistance === undefined) {
                options.maxDistance = Infinity;
            }

            // Generate new location based on type
            const location = generateLocationForName(locationName, options);

            // Safety check - if location generation failed, use fallback
            if (!location) {
                console.error(`Failed to generate location "${locationName}" with constraints min:${options.minDistance} max:${options.maxDistance}`);
                // Generate a simple fallback location
                const worldSize = getWorldSize();
                return {
                    x: (Math.random() - 0.5) * worldSize * 0.8,
                    z: (Math.random() - 0.5) * worldSize * 0.8,
                    radius: 10
                };
            }

            namedLocations[locationName] = location;
            return location;
        }

        function generateLocationForName(locationName, options = {}) {
            const worldSize = getWorldSize();
            const spacing = BLOCK_SPACING;
            const MAX_ATTEMPTS = 100;

            // Get reference location (defaults to player position)
            let refX = 0;
            let refZ = 0;
            if (options.fromLocation) {
                refX = options.fromLocation.x;
                refZ = options.fromLocation.z;
            } else if (character) {
                refX = character.position.x;
                refZ = character.position.z;
            }

            // Get distance constraints
            const minDistance = options.minDistance !== undefined ? options.minDistance : 100;
            const maxDistance = options.maxDistance !== undefined ? options.maxDistance : Infinity;

            // Try multiple times to generate a valid location
            let bestLocation = null;
            let bestScore = -Infinity;

            for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
                let candidateLocation;

                // Different location types based on name keywords
                if (locationName.includes("Harbor") || locationName.includes("Dock") || locationName.includes("Drydock") || locationName.includes("Pier")) {
                    // Water/dock locations - place at world edges
                    candidateLocation = generateDockLocation(worldSize, 15);
                } else if (locationName.includes("Parking")) {
                    // Parking locations - place along street curbs with proper orientation
                    candidateLocation = generateParkedCarLocation(worldSize, 10);
                } else if (locationName.includes("Chopshop")) {
                    // Car drop-off locations - place along road with ring and NPC positions
                    candidateLocation = generateCarDropLocation(worldSize, 10);
                } else if (locationName.includes("Market") || locationName.includes("Shop")) {
                    // Commercial locations - place at street corners
                    candidateLocation = generateStreetCornerLocation(worldSize, spacing, 10);
                } else if (locationName.includes("Garden") || locationName.includes("Park") || locationName.includes("Plaza")) {
                    // Park locations - place in open areas between buildings
                    candidateLocation = generateParkLocation(worldSize, spacing, 20);
                } else if (locationName.includes("Warehouse") || locationName.includes("Depot")) {
                    // Industrial locations - place at outer areas
                    candidateLocation = generateIndustrialLocation(worldSize, spacing, 15);
                } else if (locationName.includes("Motel") || locationName.includes("Diner")) {
                    // Roadside locations - place near buildings
                    candidateLocation = generateBuildingLocation(worldSize, 10);
                } else if (locationName.includes("Lighthouse") || locationName.includes("Tower")) {
                    // Landmark locations - place at prominent corners
                    candidateLocation = generateLandmarkLocation(worldSize, 25);
                } else {
                    // Default - random street location
                    candidateLocation = generateStreetLocation(worldSize, spacing, 10);
                }

                // Calculate distance from reference location
                const distanceFromRef = Math.sqrt(
                    Math.pow(candidateLocation.x - refX, 2) +
                    Math.pow(candidateLocation.z - refZ, 2)
                );

                // Score this location based on how well it fits the constraints
                let score = 0;
                if (distanceFromRef >= minDistance && distanceFromRef <= maxDistance) {
                    // Perfect - within range, prefer middle of range
                    const rangeMiddle = (minDistance + maxDistance) / 2;
                    const deviationFromMiddle = Math.abs(distanceFromRef - rangeMiddle);
                    score = 1000 - deviationFromMiddle;
                } else if (distanceFromRef < minDistance) {
                    // Too close - penalize based on how far under minimum
                    score = distanceFromRef - (minDistance - distanceFromRef);
                } else {
                    // Too far - penalize based on how far over maximum
                    score = maxDistance - (distanceFromRef - maxDistance);
                }

                // Track best location
                if (score > bestScore) {
                    bestScore = score;
                    bestLocation = candidateLocation;
                }

                // Check if this location meets all requirements
                const meetsMinDistance = distanceFromRef >= minDistance;
                const meetsMaxDistance = distanceFromRef <= maxDistance;

                if (meetsMinDistance && meetsMaxDistance) {
                    return candidateLocation;
                }
            }

            // If no location met all requirements, return the best one we found
            return bestLocation;
        }

        function generateDockLocation(worldSize, radius) {
            // If docks exist, place along outer half of a random dock
            if (dockGroups && dockGroups.length > 0) {
                const DOCK_LENGTH = 70;
                const DOCK_WIDTH = 30;
                const worldBoundary = worldSize / 2;
                const edgeOffset = 4; // 4 units from the end

                // Pick a random dock group
                const group = dockGroups[Math.floor(Math.random() * dockGroups.length)];

                // Pick a random road position from that group
                const roadPos = group.roadPositions[Math.floor(Math.random() * group.roadPositions.length)];

                // Random position in outer 2/3 of dock
                const outerHalfStart = DOCK_LENGTH * 0.33;
                const outerHalfEnd = DOCK_LENGTH - edgeOffset;
                const distanceFromBoundary = outerHalfStart + Math.random() * (outerHalfEnd - outerHalfStart);

                // Random lateral position across dock width
                const lateralOffset = ((Math.random() < 0.5) ? -DOCK_WIDTH : DOCK_WIDTH) * 0.42;
                
                let x, z;

                // Calculate position based on dock side
                switch(group.side) {
                    case 'north': // Dock extends in +Z direction
                        x = roadPos + lateralOffset;
                        z = worldBoundary + distanceFromBoundary;
                        break;
                    case 'south': // Dock extends in -Z direction
                        x = roadPos + lateralOffset;
                        z = -worldBoundary - distanceFromBoundary;
                        break;
                    case 'east': // Dock extends in +X direction
                        x = worldBoundary + distanceFromBoundary;
                        z = roadPos + lateralOffset;
                        break;
                    case 'west': // Dock extends in -X direction
                        x = -worldBoundary - distanceFromBoundary;
                        z = roadPos + lateralOffset;
                        break;
                }

                return {x, z, radius};
            }

            // Fallback: place at world edge if docks not yet generated
            const edge = Math.floor(Math.random() * 4);
            let x, z;

            switch(edge) {
                case 0: // North edge
                    x = (Math.random() - 0.5) * worldSize * 0.8;
                    z = -worldSize / 2 + radius;
                    break;
                case 1: // East edge
                    x = worldSize / 2 - radius;
                    z = (Math.random() - 0.5) * worldSize * 0.8;
                    break;
                case 2: // South edge
                    x = (Math.random() - 0.5) * worldSize * 0.8;
                    z = worldSize / 2 - radius;
                    break;
                case 3: // West edge
                    x = -worldSize / 2 + radius;
                    z = (Math.random() - 0.5) * worldSize * 0.8;
                    break;
            }

            return {x, z, radius};
        }

        function generateStreetCornerLocation(worldSize, spacing, radius) {
            // Place at a street intersection
            const gridStart = -Math.floor(worldSize / spacing) * spacing / 2;
            const gridEnd = Math.floor(worldSize / spacing) * spacing / 2;

            // Pick a random intersection
            const intersections = [];
            for (let x = gridStart; x <= gridEnd; x += spacing) {
                for (let z = gridStart; z <= gridEnd; z += spacing) {
                    if (Math.abs(x) <= worldSize/2 && Math.abs(z) <= worldSize/2) {
                        intersections.push({x, z});
                    }
                }
            }

            if (intersections.length > 0) {
                const corner = intersections[Math.floor(Math.random() * intersections.length)];
                // Offset slightly from exact corner
                const offset = 24; // Half of curb size
                corner.x += (Math.random() < 0.5 ? -offset : offset);
                corner.z += (Math.random() < 0.5 ? -offset : offset);
                return {x: corner.x, z: corner.z, radius};
            }

            // Fallback
            return generateStreetLocation(worldSize, spacing, radius);
        }

        function generateParkLocation(worldSize, spacing, radius) {
            // Find all park blocks (curb interiors with grass texture)
            const parks = worldCubes.filter(cube =>
                cube.asset === 'new_grass_texture' && cube.size === 40
            );

            if (parks.length === 0) {
                // Fallback: use center of world if no parks exist yet
                return {x: 0, z: 0, radius};
            }

            // Pick a random park
            const park = parks[Math.floor(Math.random() * parks.length)];
            const parkSize = park.size; // 40 units
            const parkHalfSize = parkSize / 2; // 20 units

            // Random position within the park (stay away from edges)
            const margin = 8; // Stay 8 units from park edge
            const x = park.x + (Math.random() - 0.5) * (parkSize - margin * 2);
            const z = park.z + (Math.random() - 0.5) * (parkSize - margin * 2);

            return {x, z, radius};
        }

        function generateIndustrialLocation(worldSize, spacing, radius) {
            // Place in outer thirds of world
            const outerMin = worldSize / 3;
            const outerMax = worldSize / 2 - radius;

            let x = (Math.random() < 0.5 ? -1 : 1) * (outerMin + Math.random() * (outerMax - outerMin));
            let z = (Math.random() < 0.5 ? -1 : 1) * (outerMin + Math.random() * (outerMax - outerMin));

            // Snap to nearest street edge
            x = Math.round(x / spacing) * spacing + spacing/2;
            z = Math.round(z / spacing) * spacing;

            return {x, z, radius};
        }

        function debugGenerateLocations(locationBaseName, count = 100) {
            const cubes = [];

            for (let i = 0; i < count; i++) {
                // Use a unique name for each iteration to avoid caching
                const uniqueName = `${locationBaseName}_debug_${i}`;
                const candidateLocation = generateLocationForName(uniqueName, 0);

                // Create a 2x2x2 magenta cube at the primary location (ring position)
                const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
                const cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xFF00FF }); // Magenta for visibility
                const cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cubeMesh.position.set(candidateLocation.x, 1, candidateLocation.z);
                cubeMesh.castShadow = true;
                scene.add(cubeMesh);
                cubes.push(cubeMesh);

                // If this location has an NPC position (car drop locations), show it too
                if (candidateLocation.npcX !== undefined && candidateLocation.npcZ !== undefined) {
                    const npcCubeGeometry = new THREE.BoxGeometry(2, 2, 2);
                    const npcCubeMaterial = new THREE.MeshLambertMaterial({ color: 0x00FFFF }); // Cyan for NPC
                    const npcCubeMesh = new THREE.Mesh(npcCubeGeometry, npcCubeMaterial);
                    npcCubeMesh.position.set(candidateLocation.npcX, 1, candidateLocation.npcZ);
                    npcCubeMesh.castShadow = true;
                    scene.add(npcCubeMesh);
                    cubes.push(npcCubeMesh);
                }
            }

            console.log(`Created ${count} debug cubes for "${locationBaseName}" at random locations`);
            return cubes;
        }

        function generateParkedCarLocation(worldSize, radius) {
            // Use road network segments to avoid intersections
            if (!window.roadNetwork || !window.roadNetwork.segments) {
                // Fallback if road network not available
                return {x: 0, z: 0, radius, direction: 'x', movingDirection: 0, rotation: 0};
            }

            // Get all segments
            const segments = Object.values(window.roadNetwork.segments);
            if (segments.length === 0) {
                return {x: 0, z: 0, radius, direction: 'x', movingDirection: 0, rotation: 0};
            }

            // Pick a random segment
            const segment = segments[Math.floor(Math.random() * segments.length)];

            // Pick a random position along the segment (avoid ends near intersections)
            // Use 20-80% of segment length to stay away from intersections
            const t = 0.2 + Math.random() * 0.6;
            const centerX = segment.roadStart.x + (segment.roadEnd.x - segment.roadStart.x) * t;
            const centerZ = segment.roadStart.z + (segment.roadEnd.z - segment.roadStart.z) * t;

            // Calculate perpendicular direction (90° from segment angle)
            const parkingOffset = 11;
            const parkOnRightSide = Math.random() < 0.5;
            const perpAngle = segment.angle + (parkOnRightSide ? Math.PI / 2 : -Math.PI / 2);

            // Calculate parking position offset perpendicular to segment
            // Note: segment.angle uses Z-axis reference (North=0), so conversion is: x=sin(angle), z=cos(angle)
            const x = centerX + Math.sin(perpAngle) * parkingOffset;
            const z = centerZ + Math.cos(perpAngle) * parkingOffset;

            // Car faces the direction of the segment (traffic flow)
            const rotation = segment.angle; // Segment angle now matches car rotation system

            // Determine direction and movingDirection based on segment orientation
            const dx = Math.abs(segment.end.x - segment.start.x);
            const dz = Math.abs(segment.end.z - segment.start.z);
            const direction = dx > dz ? 'x' : 'z';
            const movingDirection = parkOnRightSide ? 1 : -1;

            return {x, z, radius, direction, movingDirection, rotation};
        }

        function generateCarDropLocation(worldSize, radius) {
            // Generate a car drop-off location with two positions:
            // 1. Ring position (8 units from road center - driveable area near curb)
            // 2. NPC position (16 units from road center - on sidewalk past curb)

            // Use road network segments to avoid intersections
            if (!window.roadNetwork || !window.roadNetwork.segments) {
                // Fallback if road network not available
                return {
                    x: 0, z: 0,
                    npcX: 0, npcZ: 0,
                    radius,
                    direction: 'x',
                    movingDirection: 0,
                    rotation: 0
                };
            }

            // Get all segments
            const segments = Object.values(window.roadNetwork.segments);
            if (segments.length === 0) {
                return {
                    x: 0, z: 0,
                    npcX: 0, npcZ: 0,
                    radius,
                    direction: 'x',
                    movingDirection: 0,
                    rotation: 0
                };
            }

            // Pick a random segment
            const segment = segments[Math.floor(Math.random() * segments.length)];

            // Pick a random position along the segment (avoid ends near intersections)
            // Use 20-80% of segment length to stay away from intersections
            const t = 0.2 + Math.random() * 0.6;
            const centerX = segment.roadStart.x + (segment.roadEnd.x - segment.roadStart.x) * t;
            const centerZ = segment.roadStart.z + (segment.roadEnd.z - segment.roadStart.z) * t;

            // Calculate perpendicular direction (90° from segment angle)
            // Both positions on same side of road
            const parkOnRightSide = Math.random() < 0.5;
            const perpAngle = segment.angle + (parkOnRightSide ? Math.PI / 2 : -Math.PI / 2);

            // Ring location: 8 units from center (driveable area near curb)
            // Note: segment.angle uses Z-axis reference (North=0), so conversion is: x=sin(angle), z=cos(angle)
            const ringOffset = 8;
            const x = centerX + Math.sin(perpAngle) * ringOffset;
            const z = centerZ + Math.cos(perpAngle) * ringOffset;

            // NPC location: 16 units from center (on sidewalk, past the 15-unit curb edge)
            const npcOffset = 16;
            const npcX = centerX + Math.sin(perpAngle) * npcOffset;
            const npcZ = centerZ + Math.cos(perpAngle) * npcOffset;

            // Car faces the direction of the segment (traffic flow)
            const rotation = segment.angle; // Segment angle now matches car rotation system

            // Determine direction and movingDirection based on segment orientation
            const dx = Math.abs(segment.end.x - segment.start.x);
            const dz = Math.abs(segment.end.z - segment.start.z);
            const direction = dx > dz ? 'x' : 'z';
            const movingDirection = parkOnRightSide ? 1 : -1;

            return {x, z, npcX, npcZ, radius, direction, movingDirection, rotation};
        }

        function generateBuildingLocation(worldSize, radius) {
            // Get all buildings from gameConfig
            const buildings = worldCubes.filter(cube =>
                cube.id && cube.id.includes('concrete_cuboid') && cube.size === 30
            );

            if (buildings.length === 0) {
                // Fallback: use center of world if no buildings exist yet
                return {x: 0, z: 0, radius};
            }

            // Pick a random building
            const building = buildings[Math.floor(Math.random() * buildings.length)];
            const buildingSize = building.size; // 30 units
            const buildingHalfSize = buildingSize / 2; // 15 units
            const offsetFromEdge = 2; // 2 units from building edge

            // Pick a random edge: north, south, east, or west
            const edge = Math.floor(Math.random() * 4);
            let x, z;

            switch(edge) {
                case 0: // North edge
                    x = building.x + (Math.random() - 0.5) * buildingSize; // Random along building width
                    z = building.z + buildingHalfSize + offsetFromEdge;
                    break;
                case 1: // South edge
                    x = building.x + (Math.random() - 0.5) * buildingSize; // Random along building width
                    z = building.z - buildingHalfSize - offsetFromEdge;
                    break;
                case 2: // East edge
                    x = building.x + buildingHalfSize + offsetFromEdge;
                    z = building.z + (Math.random() - 0.5) * buildingSize; // Random along building depth
                    break;
                case 3: // West edge
                    x = building.x - buildingHalfSize - offsetFromEdge;
                    z = building.z + (Math.random() - 0.5) * buildingSize; // Random along building depth
                    break;
            }

            return {x, z, radius};
        }

        function generateRoadsideLocation(worldSize, spacing, radius) {
            // Place along a street edge
            const streetIndex = Math.floor(Math.random() * (worldSize / spacing));
            const streetCoord = -worldSize/2 + streetIndex * spacing + spacing/2;

            if (Math.random() < 0.5) {
                // Along north-south street
                const x = streetCoord;
                const z = (Math.random() - 0.5) * worldSize * 0.8;
                return {x, z, radius};
            } else {
                // Along east-west street
                const x = (Math.random() - 0.5) * worldSize * 0.8;
                const z = streetCoord;
                return {x, z, radius};
            }
        }

        function generateLandmarkLocation(worldSize, radius) {
            // Place at prominent world corners
            const corners = [
                {x: worldSize/2 - radius*2, z: worldSize/2 - radius*2},
                {x: -worldSize/2 + radius*2, z: worldSize/2 - radius*2},
                {x: worldSize/2 - radius*2, z: -worldSize/2 + radius*2},
                {x: -worldSize/2 + radius*2, z: -worldSize/2 + radius*2}
            ];

            const corner = corners[Math.floor(Math.random() * corners.length)];
            return {x: corner.x, z: corner.z, radius};
        }

        function generateStreetLocation(worldSize, spacing, radius) {
            // Default - any street-adjacent location
            const x = (Math.random() - 0.5) * worldSize * 0.9;
            const z = (Math.random() - 0.5) * worldSize * 0.9;

            // Snap to nearest street grid
            const snappedX = Math.round(x / (spacing/2)) * (spacing/2);
            const snappedZ = Math.round(z / (spacing/2)) * (spacing/2);

            return {x: snappedX, z: snappedZ, radius};
        }

        function getDistanceToLocation(locationName) {
            const location = getOrCreateLocation(locationName);
            if (!location) return Infinity;

            const playerX = gameState === 'driving' && currentCar ? currentCar.position.x : (character ? character.position.x : 0);
            const playerZ = gameState === 'driving' && currentCar ? currentCar.position.z : (character ? character.position.z : 0);

            return Math.sqrt(
                Math.pow(playerX - location.x, 2) +
                Math.pow(playerZ - location.z, 2)
            );
        }

        // Camera control state
        let cameraHorizontalAngle = 0; // Current horizontal rotation around player
        
        // Character facing system
        let characterFacingAngle = 0; // Character's facing direction (0 = north, PI/2 = east, etc.)

        // Aiming joystick state (right side gun/holdup buttons)
        let aimingJoystickActive = false;
        let aimingJoystickVector = { x: 0, y: 0 };
        let aimingJoystickAnchorX = 0;
        let aimingJoystickAnchorY = 0;
        let activeAimingTouch = null;
        let aimingJoystickDragging = false; // True if moved beyond threshold
        let aimingStartX = 0; // Initial touch position
        let aimingStartY = 0;
        const AIMING_DRAG_THRESHOLD = 20; // Pixels to move before it's considered dragging
        let currentAimingButton = null; // 'fire' or 'holdup'
        let isMouseAiming = false; // Track if mouse is being used for aiming

        // Gun state machine
        let gunState = 'idle'; // 'idle', 'raising', 'firing', 'holding', 'lowering'
        let gunRaised = false; // Legacy variable for compatibility
        let gunAnimationProgress = 0;
        const gunAnimationSpeed = 16; // Speed of arm rotation animation (2x faster when pressing gun button)
        let gunBounceTriggered = false; // Track if bounce has been triggered at 90 degrees
        let armBounceStartTime = 0; // Track when arm bounce started
        let isArmBouncing = false; // Track if arm is currently bouncing
        let buttonPressed = false; // Track if button is currently pressed
        let actionStarted = false; // Track if atomic action has started
        let gunCanFire = true; // Track if current gun action can fire

        // Explosion effects
        let activeExplosions = [];
        let cameraShakeIntensity = 0;
        let cameraShakeDuration = 0;
        
        // Weapon system
        // Weapon system variables are defined above in WEAPONS object

        // Health and Star system
        let playerHealth = 100; // Player starts with 100% health
        let wantedLevel = 0; // Current wanted level (0-5 stars)
        let maxWantedLevel = 5; // Maximum wanted level (5 stars)
        let playerCash = IS_DEV ? 99999 : 0; // Player's cash amount

        // Quest System
        let currentQuest = null; // Current active quest
        let questLocations = []; // Array of quest start locations
        let questTargetCircle = null; // Visual circle around quest target

        // Quest Chain System
        let questChainData = null; // Loaded quest chain data
        let questChainProgress = {
            currentChain: null,     // Current chain ID (e.g., "main_story")
            currentIndex: 0,        // Index in the chain
            completedQuests: [],    // Array of completed quest IDs
            objectiveProgress: {}   // Track partial progress for objectives
        };
        let inventory = new Set(); // Player inventory for items (DELIVER_ITEM, BUY, etc.)
        let targetNPCsKilled = new Set(); // Track killed NPCs for KILL objectives
        let namedLocations = {}; // Named locations with coordinates
        let questNPCNames = {}; // Map NPC IDs to display names
        let completedQuestTargetNPCs = []; // NPCs to cleanup after quest completion
        let deliveryRingMesh = null; // 3D ring mesh for STEAL_CAR delivery location

        // Inventory helper functions
        function addItemToInventory(itemName) {
            inventory.add(itemName);
            updateInventoryUI();
            console.log(`Added to inventory: ${itemName}`);
        }

        function removeItemFromInventory(itemName) {
            inventory.delete(itemName);
            updateInventoryUI();
            console.log(`Removed from inventory: ${itemName}`);
        }

        function hasItemInInventory(itemName) {
            return inventory.has(itemName);
        }

        // Dialog System
        let currentDialog = null;
        let currentDialogIndex = 0;

        // UI State (drawer variables removed)
        
        // Car driving state
        let gameState = 'walking'; // 'walking' or 'driving'
        let currentCar = null; // Reference to the car being driven
        
        // Car control linger state
        let leftRightLingerVelocity = 0; // Current linger velocity for left/right input
        let leftRightInputStartTime = 0; // When the current input started
        let leftRightInputActive = false; // Whether left/right input is currently active
        
        // Camera zoom control state
        let cameraZoomLevel = 1.0; // Current zoom level (1.0 = default distance)
        const minZoomLevel = 0.5; // 50% of current distance (closer)
        const maxZoomLevel = 1.5; // 150% of current distance (farther)
        
        // Touch pinch state for mobile zoom
        let isPinching = false;
        let lastPinchDistance = 0;
        let pinchStartZoom = 1.0;
        let firstTouchTime = null;      // Timestamp of first touch for pinch timing
        let firstTouchInZone = false;   // Whether first touch was in valid pinch zone
        let pinchTimeout = null;        // Timeout for activating joystick if pinch doesn't happen
        let blockedTouchInfo = null;    // Store info about blocked first touch for later activation
        function initAudioContext() {
            if (audioContext) {
                return;
            }

            try {
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContextClass();

                masterGainNode = audioContext.createGain();
                masterGainNode.connect(audioContext.destination);

                musicGainNode = audioContext.createGain();
                musicGainNode.gain.value = 0.3;
                musicGainNode.connect(masterGainNode);

                sfxGainNode = audioContext.createGain();
                sfxGainNode.gain.value = 0.7;
                sfxGainNode.connect(masterGainNode);

                lib.log("Web Audio API initialized successfully");
            } catch (e) {
                console.error("Failed to initialize Web Audio API:", e);
                lib.log("Audio will be disabled");
            }
        }

        async function loadAudioBuffer(url) {
            if (!audioContext) {
                return null;
            }

            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                return audioBuffer;
            } catch (e) {
                console.error("Failed to load audio:", url, e);
                return null;
            }
        }

        async function preloadAudioBuffers(audioAssetIds) {
            if (!audioContext) {
                lib.log("Audio context not initialized, skipping audio preload");
                return;
            }

            const audioAssets = [];

            audioAssetIds.forEach(id => {
                const assetInfo = lib.getAsset(id);
                if (assetInfo && (!assetInfo.type || assetInfo.type === "audio")) {
                    audioAssets.push({
                        id,
                        url: assetInfo.url,
                        loop: assetInfo.loop === true || assetInfo.loop === "true"
                    });
                }
            });

            const audioPromises = audioAssets.map(async ({ id, url, loop }) => {
                const buffer = await loadAudioBuffer(url);
                if (buffer) {
                    audioBuffers[id] = { buffer, loop };
                }
            });

            await Promise.all(audioPromises);
            lib.log("All audio assets loaded");
        }

        function playSound(soundId) {
            if (!audioContext || !audioBuffers[soundId]) {
                return;
            }

            try {
                if (audioContext.state === "suspended") {
                    audioContext.resume();
                }

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffers[soundId].buffer;
                source.connect(sfxGainNode || masterGainNode);
                source.start(0);
            } catch (e) {
                console.error("Failed to play sound:", soundId, e);
            }
        }

        function startAmbientAudio() {
            const ambientBuffer = audioBuffers.ambient_outdoors;
            if (!audioContext || !ambientBuffer) {
                return;
            }

            try {
                if (audioContext.state === "suspended") {
                    audioContext.resume();
                }

                if (musicSource) {
                    try {
                        musicSource.stop();
                    } catch (e) {
                        // Source may already be stopped
                    }
                    musicSource = null;
                }

                musicSource = audioContext.createBufferSource();
                musicSource.buffer = ambientBuffer.buffer;
                musicSource.loop = true;
                musicSource.connect(musicGainNode || masterGainNode);
                musicSource.start(0);
            } catch (e) {
                console.error("Failed to start ambient audio:", e);
            }
        }

        function stopAmbientAudio() {
            if (musicSource) {
                try {
                    musicSource.stop();
                } catch (e) {
                    // Source might already be stopped
                }
                musicSource = null;
            }
        }

        function preloadAssets() {
            const assetIds = AUDIO_ASSET_IDS;
            assetIds.forEach(id => {
                const assetInfo = lib.getAsset(id);
                if (assetInfo && assetInfo.type !== "audio") {
                    assetCache[id] = assetInfo;
                }
            });
        }





        // UI Management Functions

        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background for open world

            // Add fog effect using the current background color
            const fogDistance = getWorldSize() * 0.8;  // 80% of world size
            scene.fog = new THREE.Fog(0x87CEEB, fogDistance * 0.125, fogDistance); // Sky blue fog, starts at 1/8 distance, fully opaque at full distance
            
            // Camera setup (third-person)
            camera = new THREE.PerspectiveCamera(75, 720 / 1280, 0.1, 1000);
            
            // Renderer setup with enhanced shadows
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(720, 1280);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Enhanced lighting for open world
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Directional light that follows the player - reduced brightness by 15%
            const worldLight = new THREE.DirectionalLight(0xffffff, 1.275); // Was 1.5, now 1.275 (15% reduction)
            worldLight.castShadow = true;
            
            // Shadow settings for directional light with high quality shadows
            worldLight.shadow.mapSize.width = 2048;
            worldLight.shadow.mapSize.height = 2048;
            worldLight.shadow.camera.near = 0.5;
            worldLight.shadow.camera.far = 500;
            worldLight.shadow.bias = -0.001; // Increased shadow bias to fix artifacting
            
            // Set shadow box size to 500 total units (250 units in each direction) - half the previous size
            worldLight.shadow.camera.left = -250;
            worldLight.shadow.camera.right = 250;
            worldLight.shadow.camera.top = 250;
            worldLight.shadow.camera.bottom = -250;
            
            scene.add(worldLight);
            
            // Store reference
            window.worldLight = worldLight;
        }

        function initSplashScreen() {
            console.log('Initializing splash screen fade');

            // Splash div already exists in HTML
            const splashDiv = document.getElementById('splashScreen');
            if (!splashDiv) {
                console.error('Splash screen div not found');
                return;
            }

            splashActive = true;

            // Start fade after 2 seconds
            setTimeout(() => {
                console.log('Starting splash fade with JS animation');

                const fadeDuration = 1000; // 1 second
                const startTime = performance.now();

                function animateFade(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / fadeDuration, 1);

                    // Ease-out function
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    const opacity = 1 - easeOut;

                    splashDiv.style.opacity = String(opacity);

                    if (progress < 1) {
                        requestAnimationFrame(animateFade);
                    } else {
                        // Fade complete - remove
                        console.log('Removing splash div');
                        if (splashDiv.parentNode) {
                            splashDiv.parentNode.removeChild(splashDiv);
                        }
                        splashActive = false;
                    }
                }

                requestAnimationFrame(animateFade);
            }, 2000); // 2 second delay
        }

        function getOrCreateNPCAppearance(npcName, appearanceOverride = {}) {
            // If we've seen this NPC before, return stored appearance
            if (npcAppearanceMap[npcName]) {
                return npcAppearanceMap[npcName];
            }

            // First time seeing this NPC - use override, predefined, or randomly generate
            const SHIRT_TEXTURES = [
                'shirt_green_texture',
                'shirt_leather_jacket_texture',
                'shirt_red_texture',
                'shirt_suit_texture'
            ];

            const HAIR_TEXTURES = [
                'hair_black_texture',
                'hair_blonde_texture',
                'hair_blue_texture',
                'hair_brown_texture',
                'hair_grey_texture'
            ];

            // Check for predefined appearance for this NPC
            const predefined = npcDefinitions[npcName] || {};

            const appearance = {
                shirtTexture: appearanceOverride.shirtTexture ||
                             predefined.shirtTexture ||
                             SHIRT_TEXTURES[Math.floor(Math.random() * SHIRT_TEXTURES.length)],
                hairTexture: appearanceOverride.hairTexture ||
                            predefined.hairTexture ||
                            HAIR_TEXTURES[Math.floor(Math.random() * HAIR_TEXTURES.length)],
                pantsColor: appearanceOverride.pantsColor ||
                           predefined.pantsColor ||
                           PANTS_COLORS[Math.floor(Math.random() * PANTS_COLORS.length)]
            };

            // Store for future use
            npcAppearanceMap[npcName] = appearance;
            return appearance;
        }

        function createCharacter(x, z, isPlayer = true, appearance = null, forcePoliceUniform = false) {
            const characterGroup = new THREE.Group();

            // Available textures
            const SHIRT_TEXTURES = [
                'shirt_green_texture',
                'shirt_leather_jacket_texture',
                'shirt_red_texture',
                'shirt_suit_texture'
            ];

            const HAIR_TEXTURES = [
                'hair_black_texture',
                'hair_blonde_texture',
                'hair_blue_texture',
                'hair_brown_texture',
                'hair_grey_texture'
            ];

            // Get fallback color for texture
            function getShirtColor(textureName) {
                const colorMap = {
                    'shirt_green_texture': 0x228B22,
                    'shirt_leather_jacket_texture': 0x3D2914,
                    'shirt_red_texture': 0x8B0000,
                    'shirt_suit_texture': 0x2F2F2F,
                    'shirt_police_texture': 0x0000FF
                };
                return colorMap[textureName] || 0x2F2F2F;
            }

            function getHairColor(textureName) {
                const colorMap = {
                    'hair_black_texture': 0x000000,
                    'hair_blonde_texture': 0xFFE4B5,
                    'hair_blue_texture': 0x4169E1,
                    'hair_brown_texture': 0x3D2914,
                    'hair_grey_texture': 0x808080
                };
                return colorMap[textureName] || 0x000000;
            }

            // Extract from appearance object if provided
            let shirtTexture = appearance?.shirtTexture || null;
            let hairTexture = appearance?.hairTexture || null;
            let pantsColor = appearance?.pantsColor || null;

            // Force police uniform if requested
            if (forcePoliceUniform) {
                shirtTexture = 'shirt_police_texture';
            }

            // Randomly select if not provided
            if (!shirtTexture) {
                shirtTexture = SHIRT_TEXTURES[Math.floor(Math.random() * SHIRT_TEXTURES.length)];
            }

            if (!hairTexture) {
                hairTexture = HAIR_TEXTURES[Math.floor(Math.random() * HAIR_TEXTURES.length)];
            }

            if (!pantsColor) {
                pantsColor = PANTS_COLORS[Math.floor(Math.random() * PANTS_COLORS.length)];
            }

            // Override for player if not specified in appearance object
            if (isPlayer && !appearance) {
                shirtTexture = 'shirt_leather_jacket_texture';
                hairTexture = 'hair_brown_texture';
                pantsColor = 0x333333; // Dark pants for player
            }

            // Body (main torso) - use selected shirt texture
            const bodyGeometry = new THREE.BoxGeometry(0.9, 1.35, 0.45);
            let bodyMaterials = [];

            const shirtColor = getShirtColor(shirtTexture);
            const sideMaterial = new THREE.MeshLambertMaterial({ color: shirtColor });
            const frontMaterial = createPixelatedMaterial(shirtTexture, shirtColor);

            // Materials for each face: right, left, top, bottom, front, back
            if (frontMaterial) {
                bodyMaterials = [
                    sideMaterial,   // right
                    sideMaterial,   // left
                    sideMaterial,   // top
                    sideMaterial,   // bottom
                    frontMaterial,  // front (texture)
                    sideMaterial    // back
                ];
            } else {
                // Fallback if no texture asset
                bodyMaterials = [
                    sideMaterial,  // right
                    sideMaterial,  // left
                    sideMaterial,  // top
                    sideMaterial,  // bottom
                    sideMaterial,  // front
                    sideMaterial   // back
                ];
            }
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterials);
            body.position.y = 1.35; // Raised so legs are visible above ground (1.2 * 1.125 = 1.35)
            body.castShadow = true;
            characterGroup.add(body);
            
            // Head with face texture on front face and hair texture on other faces
            const headGeometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            let headMaterials = [];

            // Use selected hair texture
            const hairColor = getHairColor(hairTexture);
            const hairMaterial = createPixelatedMaterial(hairTexture, hairColor) ||
                                 new THREE.MeshLambertMaterial({ color: hairColor });

            // Get matching face texture based on hair color
            function getFaceTextureName(hairTextureName) {
                const faceMap = {
                    'hair_black_texture': 'face_black_hair',
                    'hair_blonde_texture': 'face_blonde_hair',
                    'hair_blue_texture': 'face_blue_hair',
                    'hair_brown_texture': 'face_brown_hair',
                    'hair_grey_texture': 'face_grey_hair'
                };
                return faceMap[hairTextureName] || 'face_brown_hair'; // Default to brown
            }

            // Create face material with matching texture
            const faceTextureName = getFaceTextureName(hairTexture);
            const faceTexture = loadPixelatedTexture(faceTextureName);
            const faceMaterial = faceTexture
                ? new THREE.MeshLambertMaterial({ map: faceTexture })
                : new THREE.MeshLambertMaterial({ color: 0xc77f4d });

            // Materials for each face: right, left, top, bottom, front, back
            headMaterials = [
                hairMaterial,     // right (hair)
                hairMaterial,     // left (hair)
                hairMaterial,     // top (hair)
                hairMaterial,     // bottom (hair)
                faceMaterial,     // front (face with matching hair color)
                hairMaterial      // back (hair)
            ];
            
            const head = new THREE.Mesh(headGeometry, headMaterials);
            head.position.y = 2.475; // Adjusted for new body position (2.2 * 1.125 = 2.475)
            head.castShadow = true;
            characterGroup.add(head);
            
            // Two-segment Arms
            const upperArmGeometry = new THREE.BoxGeometry(0.45, 0.675, 0.45);
            const lowerArmGeometry = new THREE.BoxGeometry(0.45, 0.675, 0.45);

            // Upper arms match shirt color, lower arms are skin color
            const upperArmMaterial = new THREE.MeshLambertMaterial({ color: shirtColor });
            const lowerArmMaterial = new THREE.MeshLambertMaterial({ color: 0xc77f4d }); // Skin color
            
            // Left arm with two segments
            const leftArmPivot = new THREE.Group();
            leftArmPivot.position.set(-0.675, 2.025, 0);
            
            // Upper left arm (shoulder to elbow)
            const leftUpperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
            leftUpperArm.position.set(0, -0.3375, 0);
            leftUpperArm.castShadow = true;
            leftArmPivot.add(leftUpperArm);
            
            // Lower left arm pivot (elbow joint)
            const leftLowerArmPivot = new THREE.Group();
            leftLowerArmPivot.position.set(0, -0.675, 0);
            
            // Lower left arm (elbow to hand)
            const leftLowerArm = new THREE.Mesh(lowerArmGeometry, lowerArmMaterial);
            leftLowerArm.position.set(0, -0.3375, 0);
            leftLowerArm.castShadow = true;
            leftLowerArmPivot.add(leftLowerArm);
            
            leftArmPivot.add(leftLowerArmPivot);
            characterGroup.add(leftArmPivot);
            
            // Right arm with two segments
            const rightArmPivot = new THREE.Group();
            rightArmPivot.position.set(0.675, 2.025, 0);
            
            // Upper right arm (shoulder to elbow)
            const rightUpperArm = new THREE.Mesh(upperArmGeometry, upperArmMaterial);
            rightUpperArm.position.set(0, -0.3375, 0);
            rightUpperArm.castShadow = true;
            rightArmPivot.add(rightUpperArm);
            
            // Lower right arm pivot (elbow joint)
            const rightLowerArmPivot = new THREE.Group();
            rightLowerArmPivot.position.set(0, -0.675, 0);
            
            // Lower right arm (elbow to hand)
            const rightLowerArm = new THREE.Mesh(lowerArmGeometry, lowerArmMaterial);
            rightLowerArm.position.set(0, -0.3375, 0);
            rightLowerArm.castShadow = true;
            rightLowerArmPivot.add(rightLowerArm);
            
            // Add dark grey cube at the end of the right hand (player only)
            if (isPlayer) {
                const handCubeGeometry = new THREE.BoxGeometry(0.225, 0.675, 0.225); // 1.5x taller (height changed from 0.45 to 0.675)
                const handCubeMaterial = new THREE.MeshLambertMaterial({ color: 0x2F2F2F }); // Dark grey
                const handCube = new THREE.Mesh(handCubeGeometry, handCubeMaterial);
                handCube.position.set(0, -0.975, 0.2125); // Moved up 0.2 units (from -1.175 to -0.975)
                handCube.castShadow = true;
                rightLowerArmPivot.add(handCube);
            }
            
            rightArmPivot.add(rightLowerArmPivot);
            characterGroup.add(rightArmPivot);
            
            // Two-segment Legs
            const upperLegGeometry = new THREE.BoxGeometry(0.45, 0.675, 0.45);
            const lowerLegGeometry = new THREE.BoxGeometry(0.45, 0.675, 0.45);

            // Legs use pants color
            const upperLegMaterial = new THREE.MeshLambertMaterial({ color: pantsColor });
            const lowerLegMaterial = new THREE.MeshLambertMaterial({ color: pantsColor });
            
            // Left leg with two segments
            const leftLegPivot = new THREE.Group();
            leftLegPivot.position.set(-0.225, 0.675, 0);
            
            // Upper left leg (hip to knee)
            const leftUpperLeg = new THREE.Mesh(upperLegGeometry, upperLegMaterial);
            leftUpperLeg.position.set(0, -0.3375, 0);
            leftUpperLeg.castShadow = true;
            leftLegPivot.add(leftUpperLeg);
            
            // Lower left leg pivot (knee joint)
            const leftLowerLegPivot = new THREE.Group();
            leftLowerLegPivot.position.set(0, -0.675, 0);
            
            // Lower left leg (knee to foot)
            const leftLowerLeg = new THREE.Mesh(lowerLegGeometry, lowerLegMaterial);
            leftLowerLeg.position.set(0, -0.3375, 0);
            leftLowerLeg.castShadow = true;
            leftLowerLegPivot.add(leftLowerLeg);
            
            leftLegPivot.add(leftLowerLegPivot);
            characterGroup.add(leftLegPivot);
            
            // Right leg with two segments
            const rightLegPivot = new THREE.Group();
            rightLegPivot.position.set(0.225, 0.675, 0);
            
            // Upper right leg (hip to knee)
            const rightUpperLeg = new THREE.Mesh(upperLegGeometry, upperLegMaterial);
            rightUpperLeg.position.set(0, -0.3375, 0);
            rightUpperLeg.castShadow = true;
            rightLegPivot.add(rightUpperLeg);
            
            // Lower right leg pivot (knee joint)
            const rightLowerLegPivot = new THREE.Group();
            rightLowerLegPivot.position.set(0, -0.675, 0);
            
            // Lower right leg (knee to foot)
            const rightLowerLeg = new THREE.Mesh(lowerLegGeometry, lowerLegMaterial);
            rightLowerLeg.position.set(0, -0.3375, 0);
            rightLowerLeg.castShadow = true;
            rightLowerLegPivot.add(rightLowerLeg);
            
            rightLegPivot.add(rightLowerLegPivot);
            characterGroup.add(rightLegPivot);
            
            // Store references for animation and physics
            characterGroup.userData = {
                leftArmPivot,
                rightArmPivot,
                leftLegPivot,
                rightLegPivot,
                leftLowerArmPivot,
                rightLowerArmPivot,
                leftLowerLegPivot,
                rightLowerLegPivot,
                walkTime: 0,
                velocity: { x: 0, y: 0, z: 0 },
                onGround: false,
                groundHeight: 0,
                isPlayer: isPlayer,
                // Player-specific facing data
                facingAngle: 0, // Character's facing direction (0 = north)
                // NPC-specific data
                whenIdle: !isPlayer ? "patrol" : "stationary", // Regular NPCs patrol, player is stationary
                whenScared: !isPlayer ? "flee" : "none", // Regular NPCs flee when scared
                whenApproached: "none", // No approach behavior by default
                currentEdge: 0, // 0=north, 1=east, 2=south, 3=west
                edgeProgress: 0, // Progress along current edge (0-1)
                curbBounds: null, // Will be set when NPC is placed
                moveSpeed: NPC_MOVE_SPEED,
                // Store appearance for reference
                shirtTexture: shirtTexture,
                hairTexture: hairTexture,
                pantsColor: pantsColor
            };

            // Position the character
            characterGroup.position.set(x, 0.675, z);
            
            scene.add(characterGroup);

            // Create shadow plane for both player and NPCs
            if (isPlayer) {
                shadowPlane = createShadowPlane();
                scene.add(shadowPlane);
            } else {
                // Create individual shadow plane for NPC
                const npcShadow = createShadowPlane();
                scene.add(npcShadow);
                characterGroup.userData.shadowPlane = npcShadow;
            }
            
            return characterGroup;
        }

        function createShadowPlane() {
            // Create a 2.25x2.25 unit plane geometry (2 * 1.125 = 2.25)
            const shadowGeometry = new THREE.PlaneGeometry(2.25, 2.25);
            
            // Create canvas for radial gradient texture
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient: 80% alpha black center to 0% alpha black edge
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)'); // 80% alpha black center
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // 0% alpha black edge
            
            // Fill canvas with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            // Create texture from canvas
            const shadowTexture = new THREE.CanvasTexture(canvas);
            shadowTexture.needsUpdate = true;
            
            // Create material with transparency
            const shadowMaterial = new THREE.MeshBasicMaterial({
                map: shadowTexture,
                transparent: true,
                opacity: 1,
                depthWrite: false // Prevent z-fighting with ground
            });
            
            // Create shadow plane mesh
            const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
            shadow.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
            
            return shadow;
        }

        function createNPCs() {
            // Clear existing NPCs and their shadows
            npcCharacters.forEach(npc => {
                scene.remove(npc);
                if (npc.userData.shadowPlane) {
                    scene.remove(npc.userData.shadowPlane);
                }
            });
            npcCharacters = [];
            
            // Clear existing vendor NPCs and their shadows
            vendorNPCs.forEach(vendor => {
                scene.remove(vendor);
                if (vendor.userData.shadowPlane) {
                    scene.remove(vendor.userData.shadowPlane);
                }
                // Remove vendor button if it exists
                const vendorButton = document.getElementById(`vendorButton_${vendor.userData.vendorId}`);
                if (vendorButton) {
                    vendorButton.remove();
                }
            });
            vendorNPCs = [];
            
            // Clear existing quest giver NPCs and their shadows
            questGivers.forEach(questGiver => {
                scene.remove(questGiver);
                if (questGiver.userData.shadowPlane) {
                    scene.remove(questGiver.userData.shadowPlane);
                }
                // Remove quest giver icon if it exists
                const questIcon = document.getElementById(`questIcon_${questGiver.userData.questGiverId}`);
                if (questIcon) {
                    questIcon.remove();
                }
            });
            questGivers = [];
            
            // Generate one NPC per curb (use local array, not persistent gameConfig)
            const npcsToSpawn = [];

            // Find all curb squares (concrete squares) to place NPCs on
            const curbSquares = [];
            worldCubes.forEach(cube => {
                    if (cube.id && cube.id.startsWith('concrete_square_') && cube.height === 1) {
                        curbSquares.push({
                            x: cube.x,
                            z: cube.z,
                            size: cube.size
                        });
                    }
                });
                
                if (curbSquares.length === 0) {
                    console.log('No curb squares found for NPC placement');
                    return;
                }
                
                // Create one NPC for each curb square
                curbSquares.forEach((curb, i) => {
                    // Pick a random edge (0=north, 1=east, 2=south, 3=west)
                    const randomEdge = Math.floor(Math.random() * 4);
                    
                    // Calculate position 4 units away from the edge
                    const curbHalfSize = curb.size / 2;
                    const margin = 4;
                    let npcX, npcZ;
                    
                    switch (randomEdge) {
                        case 0: // North edge
                            npcX = curb.x + (Math.random() - 0.5) * (curb.size - margin * 2);
                            npcZ = curb.z - curbHalfSize + margin;
                            break;
                        case 1: // East edge
                            npcX = curb.x + curbHalfSize - margin;
                            npcZ = curb.z + (Math.random() - 0.5) * (curb.size - margin * 2);
                            break;
                        case 2: // South edge
                            npcX = curb.x + (Math.random() - 0.5) * (curb.size - margin * 2);
                            npcZ = curb.z + curbHalfSize - margin;
                            break;
                        case 3: // West edge
                            npcX = curb.x - curbHalfSize + margin;
                            npcZ = curb.z + (Math.random() - 0.5) * (curb.size - margin * 2);
                            break;
                    }
                    
                    const npcData = {
                        id: `npc_${i}`,
                        x: npcX,
                        z: npcZ,
                        curbX: curb.x,
                        curbZ: curb.z,
                        curbSize: curb.size,
                        currentEdge: randomEdge,
                        edgeProgress: Math.random()
                    };

                    npcsToSpawn.push(npcData);
                });

            // Create visual NPCs from spawn data
            npcsToSpawn.forEach(npcData => {
                const npcCharacter = createCharacter(npcData.x, npcData.z, false);
                
                // Set NPC-specific data
                npcCharacter.userData.curbBounds = {
                    centerX: npcData.curbX,
                    centerZ: npcData.curbZ,
                    size: npcData.curbSize
                };
                npcCharacter.userData.currentEdge = npcData.currentEdge;
                npcCharacter.userData.edgeProgress = npcData.edgeProgress;
                npcCharacter.userData.npcId = npcData.id;
                
                // Position NPC at correct height (on top of curb)
                applyCollisionHeight(npcCharacter, npcData.x, npcData.z, npcCharacter.position.y);
                
                npcCharacters.push(npcCharacter);
            });
            
            console.log(`Created ${npcCharacters.length} NPCs (one per curb)`);
            
            // Create vendor NPCs at street corners
            createVendorNPCs();
            
            // Create quest giver NPCs
            createQuestGiverNPCs();
        }

        function createVendorNPCs() {
            // Clear existing vendor NPCs
            vendorNPCs.forEach(vendor => {
                scene.remove(vendor);
                if (vendor.userData.shadowPlane) {
                    scene.remove(vendor.userData.shadowPlane);
                }
            });
            vendorNPCs = [];
            
            // Generate vendors (use local array, not persistent gameConfig)
            const vendorsToSpawn = [];
            const worldSize = getWorldSize();
                const spacing = BLOCK_SPACING;
                const gridStart = -Math.floor(worldSize / spacing) * spacing / 2;
                const gridEnd = Math.floor(worldSize / spacing) * spacing / 2;
                
                // Find street corner intersections
                const corners = [];
                for (let x = gridStart - spacing/2; x <= gridEnd + spacing/2; x += spacing) {
                    for (let z = gridStart - spacing/2; z <= gridEnd + spacing/2; z += spacing) {
                        if (Math.abs(x) <= worldSize/2 && Math.abs(z) <= worldSize/2) {
                            corners.push({ x, z });
                        }
                    }
                }
                
                // Create vendors at 25% of corners (randomly selected)
                const vendorCount = Math.floor(corners.length * 0.25);
                const shuffledCorners = [...corners].sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < vendorCount; i++) {
                    const corner = shuffledCorners[i];
                    
                    // Position vendor on the corner of the curbs (at the intersection)
                    // Find the nearest curb corner position
                    const curbHalfSize = 30; // 60/2 = 30 units (half of curb size)
                    const margin = 4; // 4 units from curb edge
                    
                    // Position vendor at one of the four corners of the nearest curb intersection
                    const cornerOptions = [
                        { x: corner.x - curbHalfSize + margin, z: corner.z - curbHalfSize + margin }, // SW corner
                        { x: corner.x + curbHalfSize - margin, z: corner.z - curbHalfSize + margin }, // SE corner
                        { x: corner.x - curbHalfSize + margin, z: corner.z + curbHalfSize - margin }, // NW corner
                        { x: corner.x + curbHalfSize - margin, z: corner.z + curbHalfSize - margin }  // NE corner
                    ];
                    
                    // Pick a random corner
                    const selectedCorner = cornerOptions[Math.floor(Math.random() * 4)];
                    const offsetX = selectedCorner.x - corner.x;
                    const offsetZ = selectedCorner.z - corner.z;
                    
                    // Determine vendor type (weapons or health)
                    const vendorType = Math.random() < 0.6 ? 'weapons' : 'health';
                    
                    const vendorData = {
                        id: `vendor_${i}`,
                        x: corner.x + offsetX,
                        z: corner.z + offsetZ,
                        type: vendorType
                    };

                    vendorsToSpawn.push(vendorData);
                }

            // Create visual vendor NPCs from spawn data
            vendorsToSpawn.forEach(vendorData => {
                const vendorCharacter = createCharacter(vendorData.x, vendorData.z, false);
                
                // Set vendor-specific data
                vendorCharacter.userData.isVendor = true;
                vendorCharacter.userData.vendorType = vendorData.type;
                vendorCharacter.userData.vendorId = vendorData.id;
                vendorCharacter.userData.whenIdle = "stationary";
                vendorCharacter.userData.whenScared = "none";
                vendorCharacter.userData.whenApproached = "none";
                
                // Position vendor at correct height
                applyCollisionHeight(vendorCharacter, vendorData.x, vendorData.z, vendorCharacter.position.y);
                
                // Make vendor face a random direction
                vendorCharacter.rotation.y = Math.random() * Math.PI * 2;
                
                vendorNPCs.push(vendorCharacter);
            });
            
            console.log(`Created ${vendorNPCs.length} vendor NPCs at street corners`);
        }

        function updateCarjackNPC(npc, deltaTime) {
            const fadeSpeed = 5; // Fade speed (5 units per second = quick fade)

            if (!npc.userData.isRunningAway) {
                // FADE IN PHASE
                npc.userData.fadeInProgress += deltaTime * fadeSpeed;

                if (npc.userData.fadeInProgress >= 1) {
                    // Fade in complete
                    npc.userData.fadeInProgress = 1;
                    npc.visible = true;

                    // Set NPC opacity to fully visible
                    setMaterialOpacity(npc, 1);

                    // Check if this is an aggressive NPC (police officer)
                    if (npc.userData.isAggressive || npc.userData.isPoliceOfficer) {
                        // Convert to regular NPC behavior (will shoot at player)
                        npc.userData.isCarjackNPC = false;
                        npc.userData.whenIdle = "stationary";
                    } else {
                        // Regular civilian - start running away
                        npc.userData.isRunningAway = true;
                    }
                } else {
                    // Still fading in
                    npc.visible = true;
                    const opacity = npc.userData.fadeInProgress;

                    // Set NPC opacity based on fade progress
                    setMaterialOpacity(npc, opacity);
                }
            } else if (!npc.userData.isFadingOut) {
                // RUNNING PHASE
                const runSpeed = npc.userData.runSpeed;

                // Move NPC away from car
                const moveX = npc.userData.runDirectionX * runSpeed * deltaTime;
                const moveZ = npc.userData.runDirectionZ * runSpeed * deltaTime;

                npc.position.x += moveX;
                npc.position.z += moveZ;
                
                // Update distance from original car position
                const carX = npc.userData.originalCar.position.x;
                const carZ = npc.userData.originalCar.position.z;
                npc.userData.distanceFromCar = Math.sqrt(
                    Math.pow(npc.position.x - carX, 2) + 
                    Math.pow(npc.position.z - carZ, 2)
                );
                
                // Check if NPC has reached 30 units distance (3x further)
                if (npc.userData.distanceFromCar >= 30) {
                    npc.userData.isFadingOut = true;
                    npc.userData.fadeOutProgress = 0;
                }
                
                // Make NPC face the direction they're running
                const runAngle = Math.atan2(npc.userData.runDirectionX, npc.userData.runDirectionZ);
                npc.rotation.y = runAngle;
                
                // Update walk animation while running
                npc.userData.walkTime += deltaTime * 12; // Faster animation for running
                animateWalkForCharacter(npc);
                
                // Update height based on ground collision
                const collision = applyCollisionHeight(npc, npc.position.x, npc.position.z, npc.position.y);
                
                // Update NPC shadow position if it exists
                updateNPCShadowPosition(npc, collision);
            } else {
                // FADE OUT PHASE (while still running)
                npc.userData.fadeOutProgress += deltaTime * fadeSpeed;
                
                // Continue running while fading out
                const runSpeed = npc.userData.runSpeed;
                const moveX = npc.userData.runDirectionX * runSpeed * deltaTime;
                const moveZ = npc.userData.runDirectionZ * runSpeed * deltaTime;
                
                npc.position.x += moveX;
                npc.position.z += moveZ;
                
                // Continue walk animation
                npc.userData.walkTime += deltaTime * 12;
                animateWalkForCharacter(npc);
                
                // Update height
                const collision = checkCollisions(npc.position.x, npc.position.z, npc.position.y);
                npc.position.y = collision.stepUpHeight;
                
                // Update shadow
                updateNPCShadowPosition(npc, collision);
                
                if (npc.userData.fadeOutProgress >= 1) {
                    // Fade out complete, destroy NPC
                    scene.remove(npc);
                    if (npc.userData.shadowPlane) {
                        scene.remove(npc.userData.shadowPlane);
                    }
                    
                    // Remove from NPC list
                    const index = npcCharacters.indexOf(npc);
                    if (index > -1) {
                        npcCharacters.splice(index, 1);
                    }
                } else {
                    // Still fading out
                    const opacity = 1 - npc.userData.fadeOutProgress;
                    
                    // Set NPC opacity based on fade progress
                    setMaterialOpacity(npc, opacity);
                }
            }
        }

        function updateNPCMovement(npc, deltaTime) {
            // Handle carjack NPCs separately
            if (npc.userData.isCarjackNPC) {
                updateCarjackNPC(npc, deltaTime);
                return;
            }

            // Handle flying NPCs (from any source: car, explosion, etc.)
            if (npc.userData.isFlying) {
                updateNPCPhysics(npc, deltaTime);
                return;
            }
            
            // Handle NPCs hit by bullet (ground sliding)
            if (npc.userData.isSliding) {
                updateNPCSliding(npc, deltaTime);
                return;
            }

            // Skip dead NPCs that have stopped sliding but haven't faded out yet
            if (npc.userData.isDead) {
                // Still update death rotation animation
                updateDeathRotation(npc, deltaTime);

                // Handle fade out
                if (npc.userData.isFadingOut) {
                    if (npc.userData.deathDelayTimer > 0) {
                        npc.userData.deathDelayTimer -= deltaTime;
                        setMaterialOpacity(npc, 1);
                    } else {
                        npc.userData.fadeOutProgress += deltaTime * npc.userData.fadeSpeed;

                        if (npc.userData.fadeOutProgress >= 1) {
                            // Fade complete - remove NPC
                            scene.remove(npc);
                            if (npc.userData.shadowPlane) {
                                scene.remove(npc.userData.shadowPlane);
                            }
                            const index = npcCharacters.indexOf(npc);
                            if (index > -1) {
                                npcCharacters.splice(index, 1);
                            }
                        } else {
                            const opacity = 1 - npc.userData.fadeOutProgress;
                            setMaterialOpacity(npc, opacity);
                        }
                    }
                }
                return;
            }

            // Handle vendor NPCs (they don't move)
            if (npc.userData.isVendor) {
                updateVendorNPC(npc, deltaTime);
                return;
            }

            // Skip NPCs with no behavior defined
            if (!npc.userData.whenIdle && !npc.userData.whenScared && !npc.userData.whenApproached) return;

            // Skip patrol NPCs without curb bounds
            if (npc.userData.whenIdle === "patrol" && !npc.userData.curbBounds) return;
            
            // Initialize scared state properties if not present
            if (npc.userData.isScared === undefined) {
                npc.userData.isScared = false;
                npc.userData.scaredAnimationTime = 0;
                npc.userData.wasScaredLastFrame = false;
                npc.userData.hasSpawnedCash = false; // Track if this NPC has already spawned cash
            }
            
            // Check if player is within 5 unit radius with gun raised
            const playerDistance = Math.sqrt(
                Math.pow(character.position.x - npc.position.x, 2) + 
                Math.pow(character.position.z - npc.position.z, 2)
            );
            
            const shouldBeScared = playerDistance <= 5 && (gunState === 'firing' || gunState === 'holding' || gunAnimationProgress >= 0.95);
            
            // Check if this NPC is a police officer by examining their body material color
            let isPoliceOfficer = false;
            if (npc.children && npc.children.length > 0) {
                // Find the body mesh (first child with materials)
                const bodyMesh = npc.children.find(child => child.material && Array.isArray(child.material));
                if (bodyMesh && bodyMesh.material[4] && bodyMesh.material[4].color) {
                    // Check if front face material is blue (police officer)
                    isPoliceOfficer = bodyMesh.material[4].color.getHex() === 0x0000FF;
                }
            }
            
            // Handle state transitions based on whenScared behavior
            if (shouldBeScared && !npc.userData.isScared && !npc.userData.isShooting) {
                if (npc.userData.whenScared === "aggressive") {
                    // Become aggressive - start shooting at player
                    npc.userData.isShooting = true;
                    npc.userData.isAggressive = true; // Mark as aggressive
                    npc.userData.shootingStartTime = Date.now();
                    npc.userData.lastShotTime = 0;
                    npc.userData.shotCount = 0;
                } else if (npc.userData.whenScared === "flee") {
                    // Enter scared state - will flee or shake
                    npc.userData.isScared = true;
                    npc.userData.scaredAnimationTime = 0;
                    if (!npc.userData.hasSpawnedCash) {
                        // 70% chance for cash, 30% chance for ammo
                        if (Math.random() < 0.7) {
                            spawnCashBundle(npc.position.x, npc.position.y + 1.2, npc.position.z);
                        } else {
                            // Police more likely to drop Uzi ammo
                            const weaponType = isPoliceOfficer && Math.random() < 0.6 ? 'uzi' : null;
                            spawnAmmoPickup(npc.position.x, npc.position.y + 1.2, npc.position.z, weaponType);
                        }
                        npc.userData.hasSpawnedCash = true; // Mark as spawned

                        // Raise wanted level to 1 star (or 2 if police nearby)
                        setWantedLevelForInfraction(1);
                    }
                }
                // whenScared === "none" - no reaction
            } else if (!shouldBeScared && npc.userData.isScared) {
                // Exiting scared state
                npc.userData.isScared = false;
                npc.userData.scaredAnimationTime = 0;
            }
            // Police officers NEVER stop being aggressive once they start
            // Remove the condition that stops police shooting
            
            if (npc.userData.isScared || npc.userData.isShooting) {
                // SCARED STATE OR SHOOTING STATE

                if (npc.userData.isAggressive && !npc.userData.isDead && !npc.userData.isSliding && !npc.userData.isShot) {
                    // AGGRESSIVE NPC (Police or Quest Target): Chase player and shoot continuously

                    // Calculate direction to player for chasing
                    const directionX = character.position.x - npc.position.x;
                    const directionZ = character.position.z - npc.position.z;
                    const distance = Math.sqrt(directionX * directionX + directionZ * directionZ);

                    if (distance > 0.1) { // Avoid division by zero
                        const normalizedDirX = directionX / distance;
                        const normalizedDirZ = directionZ / distance;

                        // Only chase if farther than 10 units - stop at engagement range
                        if (distance > 10) {
                            // Move towards player at normal NPC speed
                            const chaseSpeed = npc.userData.moveSpeed;
                            const moveX = normalizedDirX * chaseSpeed * deltaTime;
                            const moveZ = normalizedDirZ * chaseSpeed * deltaTime;

                            // Update position (chase the player)
                            const newX = npc.position.x + moveX;
                            const newZ = npc.position.z + moveZ;

                            // Check collision for new position
                            const collision = checkCollisions(newX, newZ, npc.position.y);
                            if (collision.canMove) {
                                npc.position.x = newX;
                                npc.position.z = newZ;
                                npc.position.y = collision.stepUpHeight;

                                // Update shadow position
                                if (npc.userData.shadowPlane) {
                                    npc.userData.shadowPlane.position.set(newX, collision.groundHeight + 0.01, newZ);
                                }
                            }

                            // Update walk animation while chasing
                            npc.userData.walkTime += deltaTime * 8;
                            animateWalkForCharacter(npc);
                        }

                        // Always face the player regardless of distance
                        const faceAngle = Math.atan2(directionX, directionZ);
                        npc.rotation.y = faceAngle;

                        // Continuous shooting every 800ms if within range
                        const currentTime = Date.now();
                        const timeSinceLastShot = currentTime - npc.userData.lastShotTime;

                        if (timeSinceLastShot >= 800 && distance <= NPC_SHOOTING_RANGE) {
                            // Spawn projectile from police officer toward player
                            const gunTipX = npc.position.x + normalizedDirX * 1.5; // 1.5 units in front of NPC
                            const gunTipY = npc.position.y + 1.5; // At chest height
                            const gunTipZ = npc.position.z + normalizedDirZ * 1.5;

                            spawnPoliceProjectile(gunTipX, gunTipY, gunTipZ, normalizedDirX, normalizedDirZ);

                            // Spawn muzzle flash particles
                            spawnYellowWhiteParticleBurst(gunTipX, gunTipY, gunTipZ, 50);

                            npc.userData.lastShotTime = currentTime;
                            npc.userData.shotCount++;
                        }
                    }
                } else {
                    // REGULAR SCARED NPC OR NON-AGGRESSIVE POLICE: Stop moving, raise arms, shake
                    
                    // Don't update position or edge progress - NPC stays in place
                    
                    // Update scared animation time for shaking
                    npc.userData.scaredAnimationTime += deltaTime * 10; // Fast shaking frequency
                    
                    // Apply shaking to entire NPC (doubled shake distance)
                    const shakeAmount = 0.1; // Doubled shake amplitude (was 0.05, now 0.1)
                    const shakeX = (Math.random() - 0.5) * shakeAmount;
                    const shakeZ = (Math.random() - 0.5) * shakeAmount;
                    
                    // Get base position without shake
                    const baseX = npc.position.x - (npc.userData.lastShakeX || 0);
                    const baseZ = npc.position.z - (npc.userData.lastShakeZ || 0);
                    
                    // Apply new shake
                    npc.position.x = baseX + shakeX;
                    npc.position.z = baseZ + shakeZ;
                    
                    // Store shake offset for next frame
                    npc.userData.lastShakeX = shakeX;
                    npc.userData.lastShakeZ = shakeZ;
                    
                    // Update height based on ground collision (no bouncing when scared)
                    const collision = checkCollisions(baseX, baseZ, npc.position.y);
                    const baseHeight = collision.stepUpHeight;
                    npc.position.y = baseHeight;
                    
                    // Update NPC shadow position (shadow doesn't shake)
                    if (npc.userData.shadowPlane) {
                        npc.userData.shadowPlane.position.set(baseX, collision.groundHeight + 0.01, baseZ);
                    }
                    
                    // Handle non-aggressive police officer shooting (limited time/shots)
                    if (npc.userData.isShooting && isPoliceOfficer && !npc.userData.isAggressive) {
                        const currentTime = Date.now();
                        const shootingDuration = currentTime - npc.userData.shootingStartTime;
                        const timeSinceLastShot = currentTime - npc.userData.lastShotTime;

                        // Calculate direction to player
                        const directionX = character.position.x - npc.position.x;
                        const directionZ = character.position.z - npc.position.z;
                        const distance = Math.sqrt(directionX * directionX + directionZ * directionZ);

                        // Shoot every 800ms (slower than player) for up to 5 seconds, only if within range
                        if (timeSinceLastShot >= 800 && shootingDuration <= 5000 && npc.userData.shotCount < 6 && distance <= NPC_SHOOTING_RANGE) {
                            const normalizedDirX = directionX / distance;
                            const normalizedDirZ = directionZ / distance;

                            // Spawn projectile from police officer toward player
                            const gunTipX = npc.position.x + normalizedDirX * 1.5; // 1.5 units in front of NPC
                            const gunTipY = npc.position.y + 1.5; // At chest height
                            const gunTipZ = npc.position.z + normalizedDirZ * 1.5;

                            spawnPoliceProjectile(gunTipX, gunTipY, gunTipZ, normalizedDirX, normalizedDirZ);

                            // Spawn muzzle flash particles
                            spawnYellowWhiteParticleBurst(gunTipX, gunTipY, gunTipZ, 50);

                            npc.userData.lastShotTime = currentTime;
                            npc.userData.shotCount++;
                        }
                        
                        // Make NPC face the player while shooting
                        const faceAngle = Math.atan2(character.position.x - npc.position.x, character.position.z - npc.position.z);
                        npc.rotation.y = faceAngle;
                    }
                }
                
                // SCARED ANIMATION: Arms are now handled in animateWalkForCharacter function
                // Call the walk animation function to handle scared arm animation
                animateWalkForCharacter(npc);
                
                // Keep legs in neutral position (no walking animation)
                npc.userData.leftLegPivot.rotation.x = 0;
                npc.userData.rightLegPivot.rotation.x = 0;
                npc.userData.leftLowerLegPivot.rotation.x = 0;
                npc.userData.rightLowerLegPivot.rotation.x = 0;
                
            } else {
                // NORMAL STATE: Patrol or stand still based on whenIdle behavior

                // Aggressive NPCs (police/quest targets) never return to normal patrol behavior
                if (npc.userData.isAggressive && (isPoliceOfficer || npc.userData.isQuestTarget)) {
                    // Continue aggressive behavior even when player is not in range
                    // This ensures they remain aggressive forever (police) or until deactivated (quest targets)
                    npc.userData.isShooting = true;
                    return; // Skip normal idle behavior
                }

                // Handle returning to spawn location after deactivating aggression
                if (npc.userData.isReturningToSpawn && npc.userData.spawnX !== undefined && npc.userData.spawnZ !== undefined) {
                    const dx = npc.userData.spawnX - npc.position.x;
                    const dz = npc.userData.spawnZ - npc.position.z;
                    const distanceToSpawn = Math.sqrt(dx * dx + dz * dz);

                    if (distanceToSpawn < 0.5) {
                        // Reached spawn location - stop moving
                        npc.position.x = npc.userData.spawnX;
                        npc.position.z = npc.userData.spawnZ;
                        npc.userData.isReturningToSpawn = false;
                        console.log(`NPC returned to spawn location`);
                        return;
                    }

                    // Move towards spawn location
                    const angle = Math.atan2(dx, dz);
                    const moveSpeed = npc.userData.moveSpeed;
                    const moveX = Math.sin(angle) * moveSpeed * deltaTime;
                    const moveZ = Math.cos(angle) * moveSpeed * deltaTime;

                    const newX = npc.position.x + moveX;
                    const newZ = npc.position.z + moveZ;

                    // Check collision for new position
                    const collision = checkCollisions(newX, newZ, npc.position.y);
                    if (collision.canMove) {
                        npc.position.x = newX;
                        npc.position.z = newZ;
                        npc.position.y = collision.stepUpHeight;

                        // Update shadow position
                        if (npc.userData.shadowPlane) {
                            npc.userData.shadowPlane.position.set(newX, collision.groundHeight + 0.01, newZ);
                        }
                    }

                    // Face the direction of movement
                    npc.rotation.y = angle;

                    // Animate walking
                    npc.userData.walkTime += deltaTime * 8;
                    animateWalkForCharacter(npc);

                    return;
                }

                // Only patrol if whenIdle is "patrol"
                if (npc.userData.whenIdle !== "patrol") {
                    // Stationary NPCs just stand still
                    return;
                }

                // Clear any shake offset
                npc.userData.lastShakeX = 0;
                npc.userData.lastShakeZ = 0;

                const bounds = npc.userData.curbBounds;
                const halfSize = bounds.size / 2;
                const margin = 4;
                const walkableSize = bounds.size - margin * 2;
                const moveSpeed = npc.userData.moveSpeed;
                
                // Update edge progress
                npc.userData.edgeProgress += (moveSpeed * deltaTime) / walkableSize;
                
                // Check if we've completed the current edge
                if (npc.userData.edgeProgress >= 1.0) {
                    npc.userData.edgeProgress = 0.0;
                    npc.userData.currentEdge = (npc.userData.currentEdge + 1) % 4; // Turn 90 degrees clockwise
                }
                
                // Calculate position based on current edge and progress
                let newX, newZ, facingAngle;
                const progress = npc.userData.edgeProgress;
                
                switch (npc.userData.currentEdge) {
                    case 0: // North edge (walking east)
                        newX = bounds.centerX - halfSize + margin + progress * walkableSize;
                        newZ = bounds.centerZ - halfSize + margin;
                        facingAngle = Math.PI / 2; // Face east (flipped uniformly)
                        break;
                    case 1: // East edge (walking south)
                        newX = bounds.centerX + halfSize - margin;
                        newZ = bounds.centerZ - halfSize + margin + progress * walkableSize;
                        facingAngle = 0; // Face south (flipped uniformly)
                        break;
                    case 2: // South edge (walking west)
                        newX = bounds.centerX + halfSize - margin - progress * walkableSize;
                        newZ = bounds.centerZ + halfSize - margin;
                        facingAngle = -Math.PI / 2; // Face west (flipped uniformly)
                        break;
                    case 3: // West edge (walking north)
                        newX = bounds.centerX - halfSize + margin;
                        newZ = bounds.centerZ + halfSize - margin - progress * walkableSize;
                        facingAngle = Math.PI; // Face north (flipped uniformly)
                        break;
                }
                
                // Update position and rotation
                npc.position.x = newX;
                npc.position.z = newZ;
                npc.rotation.y = facingAngle;
                
                // Update height based on ground collision
                const collision = checkCollisions(newX, newZ, npc.position.y);
                const baseHeight = collision.stepUpHeight;
                npc.position.y = baseHeight;
                
                // Add smooth wave-like bouncing while moving (0.2 units) - NPCs are always moving
                npc.userData.walkTime += deltaTime * 8;
                const bounceAmount = Math.sin(npc.userData.walkTime * 2) * 0.2;
                npc.position.y += bounceAmount;
                
                // Update NPC shadow position if it exists (shadow does NOT bounce)
                if (npc.userData.shadowPlane) {
                    npc.userData.shadowPlane.position.set(newX, collision.groundHeight + 0.01, newZ);
                }
                
                // Update walk animation
                animateWalkForCharacter(npc);
            }
            
            // Handle transition from scared to normal: lower arms THEN resume running
            if (npc.userData.wasScaredLastFrame && !npc.userData.isScared) {
                // Just exited scared state - arms should be lowering
                // The normal walking animation will handle this automatically
                // by resetting arm positions in animateWalkForCharacter
            }
            
            // Store state for next frame
            npc.userData.wasScaredLastFrame = npc.userData.isScared;
        }

        function updateVendorNPC(vendor, deltaTime) {
            // Vendors stand still and don't move
            // Always show vendor button when vendor is on screen (regardless of distance)
            showVendorButton(vendor);
        }

        function showNPCIcon(npc, config) {
            // Handle dialog hiding
            if (config.hideInDialog && isDialogActive()) {
                const icon = document.getElementById(config.id);
                if (icon) {
                    icon.style.display = 'none';
                }
                return;
            }

            // Create or get icon element
            let icon = document.getElementById(config.id);
            if (!icon) {
                icon = document.createElement('div');
                icon.id = config.id;
                icon.className = 'vendor-button';
                icon.innerHTML = config.icon;

                // Set styling
                if (config.color) icon.style.color = config.color;
                if (config.fontWeight) icon.style.fontWeight = config.fontWeight;

                // Set fixed sizes if not scaling
                if (!config.scalingEnabled && config.inRangeSize) {
                    icon.style.width = config.inRangeSize.size + 'px';
                    icon.style.height = config.inRangeSize.size + 'px';
                    icon.style.fontSize = config.inRangeSize.fontSize;
                    icon.style.lineHeight = config.inRangeSize.size + 'px';
                    icon.style.textAlign = 'center';
                }

                // Add click handler
                icon.addEventListener('click', (e) => {
                    const dx = character.position.x - npc.position.x;
                    const dz = character.position.z - npc.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance <= config.interactionRange) {
                        config.onClick(npc, distance);
                    }
                });

                document.body.appendChild(icon);
            }

            // Calculate distance to player
            const dx = character.position.x - npc.position.x;
            const dz = character.position.z - npc.position.z;
            const playerDistance = Math.sqrt(dx * dx + dz * dz);

            // Check visibility range
            if (config.visibilityRange !== null && playerDistance > config.visibilityRange) {
                icon.style.display = 'none';
                return;
            }

            // Handle scaling based on distance
            let iconSize, fontSize;
            if (config.scalingEnabled) {
                if (playerDistance <= config.interactionRange) {
                    iconSize = config.inRangeSize.size;
                    fontSize = config.inRangeSize.fontSize;
                } else {
                    iconSize = config.outOfRangeSize.size;
                    fontSize = config.outOfRangeSize.fontSize;
                }

                icon.style.width = iconSize + 'px';
                icon.style.height = iconSize + 'px';
                icon.style.fontSize = fontSize;
            } else {
                iconSize = config.inRangeSize.size;
            }

            // Project world position to screen coordinates
            const worldPos = new THREE.Vector3(
                npc.position.x,
                npc.position.y + config.heightOffset,
                npc.position.z
            );
            worldPos.project(camera);

            // Convert to screen coordinates (using current window dimensions)
            const screenX = (worldPos.x * 0.5 + 0.5) * window.innerWidth;
            const screenY = (-worldPos.y * 0.5 + 0.5) * window.innerHeight;

            // Update icon position
            icon.style.left = (screenX - iconSize/2) + 'px';
            icon.style.top = (screenY - iconSize) + 'px';

            // Show/hide based on whether NPC is in front of camera
            if (worldPos.z <= 1) {
                icon.style.display = 'flex';
            } else {
                icon.style.display = 'none';
            }
        }

        function showQuestGiverIcon(questGiver) {
            showNPCIcon(questGiver, {
                id: `questIcon_${questGiver.userData.questGiverId}`,
                icon: '?',
                color: '#FFD700',
                fontWeight: 'bold',
                onClick: (npc) => showQuestDialog(npc),
                interactionRange: 8,
                visibilityRange: 50,
                heightOffset: 6,
                scalingEnabled: true,
                inRangeSize: { size: 90, fontSize: '64px' },
                outOfRangeSize: { size: 60, fontSize: '36px' },
                hideInDialog: true
            });
        }

        function hideQuestGiverIcon(questGiver) {
            const questIcon = document.getElementById(`questIcon_${questGiver.userData.questGiverId}`);
            if (questIcon) {
                questIcon.style.display = 'none';
            }
        }

        function showQuestTargetIcon(targetNPC) {
            showNPCIcon(targetNPC, {
                id: `questTargetIcon_${targetNPC.userData.questTargetId}`,
                icon: '!',
                color: '#FFD700',
                fontWeight: 'bold',
                onClick: (npc, distance) => {
                    if (currentQuest && currentQuest.objective) {
                        const progress = questChainProgress.objectiveProgress[currentQuest.id];

                        // For BUY quest, open vendor shop
                        if (currentQuest.objective.type === 'BUY') {
                            if (!progress.itemBought) {
                                openVendorShop(npc);
                            }
                        } else {
                            // For other quest types (TALK, DELIVER_ITEM)
                            if (progress && !progress.dialogShown) {
                                progress.dialogShown = true;

                                // For DELIVER_ITEM, remove the item from inventory
                                if (currentQuest.objective.type === 'DELIVER_ITEM') {
                                    removeItemFromInventory(currentQuest.objective.item);
                                }

                                // Complete the quest
                                completeQuest();

                                // Remove the icon
                                const icon = document.getElementById(`questTargetIcon_${npc.userData.questTargetId}`);
                                if (icon) icon.remove();
                            }
                        }
                    }
                },
                interactionRange: 8,
                visibilityRange: 25,
                heightOffset: 6,
                scalingEnabled: true,
                inRangeSize: { size: 90, fontSize: '64px' },
                outOfRangeSize: { size: 60, fontSize: '36px' },
                hideInDialog: true
            });
        }

        function hideQuestTargetIcon(targetNPC) {
            const questTargetIcon = document.getElementById(`questTargetIcon_${targetNPC.userData.questTargetId}`);
            if (questTargetIcon) {
                questTargetIcon.style.display = 'none';
            }
        }

        function showQuestDialog(questGiver) {
            // Get current quest from chain
            let questToOffer = getCurrentChainQuest();

            if (!questToOffer) {
                // Fallback to random quest if no chain quest available
                if (questGiver.userData.storedQuest) {
                    questToOffer = questGiver.userData.storedQuest;
                } else {
                    questToOffer = generateRandomQuest();
                    if (!questToOffer) return;
                    questGiver.userData.storedQuest = questToOffer;
                }
            } else {
                // Assign this quest giver as the NPC for this chain quest
                questToOffer.giverNPC = questGiver.userData.questGiverId;

                // Store the quest giver name for this NPC
                if (questToOffer.giverName) {
                    questNPCNames[questGiver.userData.questGiverId] = questToOffer.giverName;
                }
            }

            // Use quest's own intro dialog if it has one, otherwise generate
            const introDialogs = questToOffer.intro_dialog || generateQuestIntroDialog(questToOffer);

            // Show intro dialog first, then quest dialog
            showDialog({
                lines: introDialogs,
                transparentBackground: !questToOffer.dialog_solid_background,
                onComplete: () => {
                    // After intro dialog completes, show the quest dialog
                    showActualQuestDialog(questToOffer, questGiver);
                }
            });
        }

        function getCurrentChainQuest() {
            if (!questChainData || !questChainProgress.currentChain) {
                return null;
            }

            const chain = questChainData[questChainProgress.currentChain];
            if (!chain || questChainProgress.currentIndex >= chain.length) {
                return null;
            }

            const quest = chain[questChainProgress.currentIndex];

            if (questChainProgress.completedQuests.includes(quest.id)) {
                return null;
            }

            return quest;
        }

        function getNextQuestInChain() {
            if (!questChainData || !questChainProgress.currentChain) {
                return null;
            }

            const chain = questChainData[questChainProgress.currentChain];
            const nextIndex = questChainProgress.currentIndex + 1;

            if (!chain || nextIndex >= chain.length) {
                return null;
            }

            return chain[nextIndex];
        }
        
        function generateQuestIntroDialog(quest) {
            const dialogOptions = [
                // Generic greetings
                [
                    { speaker: "Quest Giver", text: "Hey there, stranger. You look like someone who can handle trouble." },
                    { speaker: "Player", text: "Depends on the pay. What do you need?" },
                    { speaker: "Quest Giver", text: "I've got a job that's right up your alley..." }
                ],
                [
                    { speaker: "Quest Giver", text: "You've got that look about you. The kind that gets things done." },
                    { speaker: "Player", text: "I'm listening." },
                    { speaker: "Quest Giver", text: "Good. I need someone with your... particular skills." }
                ],
                [
                    { speaker: "Quest Giver", text: "Perfect timing. I was just looking for someone like you." },
                    { speaker: "Player", text: "Someone like me?" },
                    { speaker: "Quest Giver", text: "Someone who isn't afraid to get their hands dirty for the right price." }
                ],
                // Quest-specific intros
                [
                    { speaker: "Quest Giver", text: "I've been watching you work. Impressive." },
                    { speaker: "Player", text: "Flattery will get you nowhere. What's the job?" },
                    { speaker: "Quest Giver", text: "Direct. I like that. Here's what I need..." }
                ],
                [
                    { speaker: "Quest Giver", text: "Word on the street is you're the one to call for difficult jobs." },
                    { speaker: "Player", text: "The street talks too much. But it's not wrong." },
                    { speaker: "Quest Giver", text: "Then you're exactly who I need." }
                ]
            ];
            
            // Return a random dialog option
            return dialogOptions[Math.floor(Math.random() * dialogOptions.length)];
        }
        
        function showActualQuestDialog(questToOffer, questGiver) {
            // Create quest dialog
            let questDialog = document.getElementById('questDialog');
            if (!questDialog) {
                questDialog = document.createElement('div');
                questDialog.id = 'questDialog';
                questDialog.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 600px;
                    max-width: 90vw;
                    background: rgba(0, 0, 0, 0.9);
                    border: 3px solid rgba(255, 255, 255, 0.6);
                    border-radius: 16px;
                    padding: 20px;
                    z-index: 2000;
                    backdrop-filter: blur(12px);
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                    display: none;
                `;
                document.body.appendChild(questDialog);
            }
            
            // Set dialog content
            questDialog.innerHTML = `
                <div style="font-family: 'Denk One', cursive; font-size: 24px; color: #FFD700; text-align: center; margin-bottom: 20px; text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black;">
                    ${questToOffer.title}
                </div>
                <div style="font-family: 'Poppins', sans-serif; font-size: 16px; color: white; margin-bottom: 30px; line-height: 1.5; text-align: center;">
                    ${questToOffer.description}
                </div>
                <div style="display: flex; gap: 20px; justify-content: center;">
                    <button id="questAcceptButton" style="background: rgba(0, 255, 0, 0.8); border: 2px solid white; border-radius: 8px; padding: 10px 20px; color: white; font-family: 'Denk One', cursive; font-size: 16px; cursor: pointer; transition: all 0.3s ease;">
                        Accept
                    </button>
                    <button id="questCancelButton" style="background: rgba(255, 0, 0, 0.8); border: 2px solid white; border-radius: 8px; padding: 10px 20px; color: white; font-family: 'Denk One', cursive; font-size: 16px; cursor: pointer; transition: all 0.3s ease;">
                        Cancel
                    </button>
                </div>
            `;
            
            // Add button event listeners
            const acceptButton = document.getElementById('questAcceptButton');
            const cancelButton = document.getElementById('questCancelButton');
            
            acceptButton.addEventListener('click', () => {
                acceptQuest(questToOffer, questGiver);
                closeQuestDialog();
            });
            
            cancelButton.addEventListener('click', () => {
                // When canceling, keep the stored quest so it can be offered again
                closeQuestDialog();
            });
            
            // Show the dialog
            questDialog.style.display = 'block';
        }

        function acceptQuest(quest, questGiver) {
            // Start the quest
            startQuest(quest);

            // Mark quest giver as having offered a quest
            questGiver.userData.questOffered = true;
            questGiver.userData.hasQuest = false;

            // Clear the stored quest since it's been accepted
            questGiver.userData.storedQuest = null;

            // Hide quest giver icon
            hideQuestGiverIcon(questGiver);

            // Initialize objective progress for this quest
            questChainProgress.objectiveProgress[quest.id] = {
                started: true,
                pickupLocation: null,
                targetKilled: false
            };
        }

        function closeQuestDialog() {
            const questDialog = document.getElementById('questDialog');
            if (questDialog) {
                questDialog.style.display = 'none';
            }
        }

        // Dialog System Functions
        function hideUIForDialog() {
            // Cleanup aiming joystick state when dialog opens
            aimingJoystickActive = false;
            aimingJoystickDragging = false;
            aimingJoystickVector = { x: 0, y: 0 };
            activeAimingTouch = null;
            currentAimingButton = null;

            // Hide all main UI elements when dialog is active
            const uiElements = [
                'healthHeart',
                'healthBarFill', 
                'star1', 'star2', 'star3', 'star4', 'star5',
                'questContainer',
                'bulletIcon',
                'cashIcon', 
                'ammoText',
                'moneyText',
                'holdUpButton',
                'gunButton',
                'weaponSwitchButton',
                'joystick'
            ];
            
            uiElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.display = 'none';
                }
            });
            
            // Hide health bar container
            const healthBarContainer = document.querySelector('.health-bar-container');
            if (healthBarContainer) {
                healthBarContainer.style.display = 'none';
            }
            
            // Hide star container
            const starContainer = document.querySelector('.star-container');
            if (starContainer) {
                starContainer.style.display = 'none';
            }
            
            // Hide minimap
            const minimapContainer = document.querySelector('.minimap-container');
            if (minimapContainer) {
                minimapContainer.style.display = 'none';
            }
            
            // Hide quest giver icons during dialog
            questGivers.forEach(questGiver => {
                const questIcon = document.getElementById(`questIcon_${questGiver.userData.questGiverId}`);
                if (questIcon) {
                    questIcon.style.display = 'none';
                }
            });
        }
        
        function showUIAfterDialog() {
            // Show all main UI elements when dialog is closed
            const uiElements = [
                'healthHeart',
                'healthBarFill',
                'star1', 'star2', 'star3', 'star4', 'star5', 
                'questContainer',
                'bulletIcon',
                'cashIcon',
                'ammoText', 
                'moneyText',
                'holdUpButton',
                'gunButton',
                'weaponSwitchButton',
                'joystick'
            ];
            
            uiElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.display = '';
                }
            });
            
            // Show health bar container
            const healthBarContainer = document.querySelector('.health-bar-container');
            if (healthBarContainer) {
                healthBarContainer.style.display = 'flex';
            }
            
            // Show star container
            const starContainer = document.querySelector('.star-container');
            if (starContainer) {
                starContainer.style.display = 'flex';
            }
            
            // Show minimap
            const minimapContainer = document.querySelector('.minimap-container');
            if (minimapContainer) {
                minimapContainer.style.display = 'block';
            }
            
            // Show quest container if there's an active quest
            if (currentQuest) {
                const questContainer = document.getElementById('questContainer');
                if (questContainer) {
                    questContainer.style.display = 'block';
                }
            }
            
            // Show quest giver icons again (they will be managed by the normal update cycle)
            questGivers.forEach(questGiver => {
                if (questGiver.userData.hasQuest && !questGiver.userData.questOffered) {
                    showQuestGiverIcon(questGiver);
                }
            });
        }

        function createDialogPlayerModel() {
            // Create or get the dialog player model container
            let dialogPlayerModel = document.getElementById('dialogPlayerModel');
            if (!dialogPlayerModel) {
                dialogPlayerModel = document.createElement('div');
                dialogPlayerModel.id = 'dialogPlayerModel';
                dialogPlayerModel.className = 'dialog-player-model';
                dialogPlayerModel.style.cursor = 'pointer';
                
                // Add click handler to dialog player model to advance dialog
                dialogPlayerModel.addEventListener('click', advanceDialog);
                
                document.body.appendChild(dialogPlayerModel);
                
                // Create a separate Three.js scene for the player model
                const dialogScene = new THREE.Scene();
                const dialogCamera = new THREE.PerspectiveCamera(75, 720 / 1280, 0.1, 1000);
                const dialogRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                dialogRenderer.setSize(720, 1280);
                dialogRenderer.domElement.style.width = '100%';
                dialogRenderer.domElement.style.height = '100%';
                dialogPlayerModel.appendChild(dialogRenderer.domElement);
                
                // Position camera to show player from front - full screen size
                dialogCamera.position.set(0, 1.5, 5);
                dialogCamera.lookAt(0, 1.5, 0);
                
                // Add lighting for the dialog scene
                const dialogAmbientLight = new THREE.AmbientLight(0xffffff, 0.8);
                dialogScene.add(dialogAmbientLight);
                
                const dialogDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dialogDirectionalLight.position.set(0, 4, 10);
                dialogScene.add(dialogDirectionalLight);
                
                // Create a copy of the player character for dialog
                const dialogPlayer = createCharacter(1, 2, true);
                dialogPlayer.position.set(1, 0, 2);
                dialogPlayer.rotation.y = -Math.PI / 4; // Rotate -45 degrees on Y axis
                dialogScene.add(dialogPlayer);
                
                // Create a copy of an NPC character for dialog (representing the quest giver/vendor)
                const dialogNPC = createCharacter(-1, 2, false);
                dialogNPC.position.set(-1, 0, 2);
                dialogNPC.rotation.y = Math.PI / 4; // Rotate 45 degrees on Y axis
                dialogScene.add(dialogNPC);
                
                // Store references for animation and cleanup
                window.dialogPlayerModel = {
                    scene: dialogScene,
                    camera: dialogCamera,
                    renderer: dialogRenderer,
                    player: dialogPlayer,
                    npc: dialogNPC,
                    container: dialogPlayerModel
                };
                
                // Start dialog model animation loop
                animateDialogPlayerModel();
            }

            // Show the dialog player model
            dialogPlayerModel.style.display = 'block';

            // Always restart the animation loop when showing dialog
            animateDialogPlayerModel();
        }
        
        function animateDialogPlayerModel() {
            if (!window.dialogPlayerModel || !window.dialogPlayerModel.renderer) return;
            
            const { scene, camera, renderer, player, npc } = window.dialogPlayerModel;
            
            // Simple idle animation for the dialog player
            const time = Date.now() * 0.001;
            
            // Check who is currently talking
            const isPlayerTalking = currentDialog && currentDialog.lines[currentDialogIndex] &&
                                   currentDialog.lines[currentDialogIndex].speaker === "Player";
            const isNPCTalking = currentDialog && currentDialog.lines[currentDialogIndex] &&
                                currentDialog.lines[currentDialogIndex].speaker !== "Player";

            // Animate both dialog characters
            animateDialogCharacter(player, time * 2, time * 0.8, isPlayerTalking, isNPCTalking, 0.1);
            animateDialogCharacter(npc, time * 1.8, time * 0.6, isNPCTalking, isPlayerTalking, 0.08);
            
            // Render the dialog scene
            renderer.render(scene, camera);
            
            // Continue animation if dialog is still active
            if (isDialogActive()) {
                requestAnimationFrame(animateDialogPlayerModel);
            }
        }
        
        function hideDialogPlayerModel() {
            const dialogPlayerModel = document.getElementById('dialogPlayerModel');
            if (dialogPlayerModel) {
                dialogPlayerModel.style.display = 'none';
            }
        }
        
        function cleanupDialogPlayerModel() {
            if (window.dialogPlayerModel) {
                // Clean up Three.js resources
                if (window.dialogPlayerModel.renderer) {
                    window.dialogPlayerModel.renderer.dispose();
                }
                if (window.dialogPlayerModel.scene) {
                    // Remove all objects from scene
                    while (window.dialogPlayerModel.scene.children.length > 0) {
                        window.dialogPlayerModel.scene.remove(window.dialogPlayerModel.scene.children[0]);
                    }
                }
                
                // Remove DOM element
                if (window.dialogPlayerModel.container && window.dialogPlayerModel.container.parentNode) {
                    window.dialogPlayerModel.container.parentNode.removeChild(window.dialogPlayerModel.container);
                }
                
                window.dialogPlayerModel = null;
            }
        }

        function showDialog(dialogData) {
            if (!dialogData || !dialogData.lines || dialogData.lines.length === 0) {
                console.log('Invalid dialog data provided');
                return;
            }

            currentDialog = dialogData;
            currentDialogIndex = 0;

            // Create dialog window if it doesn't exist
            let dialogWindow = document.getElementById('dialogWindow');
            if (!dialogWindow) {
                dialogWindow = document.createElement('div');
                dialogWindow.id = 'dialogWindow';
                dialogWindow.className = 'dialog-window';

                dialogWindow.innerHTML = `
                    <div class="dialog-content">
                        <div class="dialog-speaker" id="dialogSpeaker"></div>
                        <div class="dialog-text" id="dialogText"></div>
                    </div>
                    <div class="dialog-next-button" id="dialogNextButton">NEXT</div>
                `;

                document.body.appendChild(dialogWindow);

                // Add click handlers
                dialogWindow.addEventListener('click', advanceDialog);

                const nextButton = document.getElementById('dialogNextButton');
                nextButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent double-triggering
                    advanceDialog();
                });
            }

            // Create full screen background
            let dialogBackground = document.getElementById('dialogBackground');
            if (!dialogBackground) {
                dialogBackground = document.createElement('div');
                dialogBackground.id = 'dialogBackground';
                dialogBackground.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 2399;
                    display: none;
                    cursor: pointer;
                `;

                // Add click handler to background to advance dialog
                dialogBackground.addEventListener('click', advanceDialog);

                document.body.appendChild(dialogBackground);
            }

            // Update background style based on transparentBackground option
            if (dialogData.transparentBackground) {
                // Transparent background: use semi-transparent black
                dialogBackground.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                dialogBackground.style.backgroundImage = 'none';
                dialogBackground.style.backgroundSize = '';
                dialogBackground.style.backgroundPosition = '';
                dialogBackground.style.backgroundBlendMode = '';
            } else {
                // Solid background: use city sunset image
                const citySunsetAsset = lib.getAsset('city_sunset_background');
                if (citySunsetAsset) {
                    dialogBackground.style.backgroundColor = '#666666';
                    dialogBackground.style.backgroundImage = `url(${citySunsetAsset.url})`;
                    dialogBackground.style.backgroundSize = 'cover';
                    dialogBackground.style.backgroundPosition = 'center';
                    dialogBackground.style.backgroundBlendMode = 'multiply';
                } else {
                    // Fallback to black if asset not found
                    dialogBackground.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
                    dialogBackground.style.backgroundImage = 'none';
                    dialogBackground.style.backgroundBlendMode = '';
                }
            }

            // Create or show dialog player model
            createDialogPlayerModel();

            // Hide all other UI elements when dialog is visible
            hideUIForDialog();

            // Show the background and dialog window
            dialogBackground.style.display = 'block';
            dialogWindow.classList.add('show');

            // Display first line
            displayCurrentDialogLine();
        }

        function displayCurrentDialogLine() {
            if (!currentDialog || currentDialogIndex >= currentDialog.lines.length) {
                closeDialog();
                return;
            }

            const currentLine = currentDialog.lines[currentDialogIndex];
            const speakerElement = document.getElementById('dialogSpeaker');
            const textElement = document.getElementById('dialogText');
            const nextButton = document.getElementById('dialogNextButton');

            if (speakerElement && textElement) {
                speakerElement.textContent = currentLine.speaker || '';
                textElement.textContent = currentLine.text || '';

                // Update dialog NPC appearance if speaker changed
                updateDialogNPCAppearance(currentLine.speaker);

                // Update next button text
                if (nextButton) {
                    if (currentDialogIndex >= currentDialog.lines.length - 1) {
                        nextButton.textContent = 'CLOSE';
                    } else {
                        nextButton.textContent = 'NEXT';
                    }
                }
            }
        }

        function updateDialogNPCAppearance(speakerName) {
            if (!window.dialogPlayerModel || speakerName === "Player") return;

            const dialogModel = window.dialogPlayerModel;

            // Check if speaker has changed from last time
            if (dialogModel.currentSpeaker === speakerName) return;

            dialogModel.currentSpeaker = speakerName;

            // Get consistent appearance for this named NPC
            const appearance = getOrCreateNPCAppearance(speakerName);

            // Remove old NPC
            if (dialogModel.npc) {
                dialogModel.scene.remove(dialogModel.npc);
            }

            // Create new NPC with consistent appearance
            const dialogNPC = createCharacter(-1, 2, false, appearance);
            dialogNPC.position.set(-1, 0, 2);
            dialogNPC.rotation.y = Math.PI / 4; // Rotate 45 degrees on Y axis
            dialogModel.scene.add(dialogNPC);

            // Update reference
            dialogModel.npc = dialogNPC;
        }

        function advanceDialog() {
            if (!currentDialog) return;

            currentDialogIndex++;
            
            if (currentDialogIndex >= currentDialog.lines.length) {
                closeDialog();
            } else {
                displayCurrentDialogLine();
            }
        }

        function closeDialog() {
            const dialogWindow = document.getElementById('dialogWindow');
            if (dialogWindow) {
                dialogWindow.classList.remove('show');
            }

            // Hide dialog background
            const dialogBackground = document.getElementById('dialogBackground');
            if (dialogBackground) {
                dialogBackground.style.display = 'none';
            }

            // Hide dialog player model
            hideDialogPlayerModel();

            // Show all UI elements again when dialog closes
            showUIAfterDialog();

            // Call completion callback if provided
            if (currentDialog && currentDialog.onComplete) {
                currentDialog.onComplete();
            }

            currentDialog = null;
            currentDialogIndex = 0;
        }

        function isDialogActive() {
            return currentDialog !== null;
        }

        function updateQuestGiverNPC(questGiver, deltaTime) {
            // Quest givers stand still and don't move
            // The quest icon display is handled in checkForQuestStart
        }

        function createQuestGiverNPCs() {
            // Generate quest giver NPCs (use local array, not persistent gameConfig)
            const questGiversToSpawn = [];

            // Find all curb squares (concrete squares) to place quest givers on
            const curbSquares = [];
                worldCubes.forEach(cube => {
                    if (cube.id && cube.id.startsWith('concrete_square_') && cube.height === 1) {
                        curbSquares.push({
                            x: cube.x,
                            z: cube.z,
                            size: cube.size
                        });
                    }
                });
                
                if (curbSquares.length === 0) {
                    console.log('No curb squares found for quest giver placement');
                    return;
                }
                
                // Create quest giver NPCs at 30% of curb squares
                const questGiverCount = Math.floor(curbSquares.length * 0.3);
                const shuffledCurbs = [...curbSquares].sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < questGiverCount; i++) {
                    const curb = shuffledCurbs[i];
                    
                    // Position quest giver towards the middle of a block on the curb
                    // Pick a random edge (0=north, 1=east, 2=south, 3=west)
                    const randomEdge = Math.floor(Math.random() * 4);
                    
                    // Calculate position towards the middle of the curb edge (not at corners)
                    const curbHalfSize = curb.size / 2;
                    const margin = 8; // 8 units from curb corners towards center
                    let questGiverX, questGiverZ;
                    
                    switch (randomEdge) {
                        case 0: // North edge
                            questGiverX = curb.x + (Math.random() - 0.5) * (curb.size - margin * 2);
                            questGiverZ = curb.z - curbHalfSize + 4; // 4 units inward from edge
                            break;
                        case 1: // East edge
                            questGiverX = curb.x + curbHalfSize - 4; // 4 units inward from edge
                            questGiverZ = curb.z + (Math.random() - 0.5) * (curb.size - margin * 2);
                            break;
                        case 2: // South edge
                            questGiverX = curb.x + (Math.random() - 0.5) * (curb.size - margin * 2);
                            questGiverZ = curb.z + curbHalfSize - 4; // 4 units inward from edge
                            break;
                        case 3: // West edge
                            questGiverX = curb.x - curbHalfSize + 4; // 4 units inward from edge
                            questGiverZ = curb.z + (Math.random() - 0.5) * (curb.size - margin * 2);
                            break;
                    }
                    
                    const questGiverData = {
                        id: `questgiver_${i}`,
                        x: questGiverX,
                        z: questGiverZ,
                        hasQuest: true,
                        questOffered: false
                    };

                    questGiversToSpawn.push(questGiverData);
                }

            // Create visual quest giver NPCs from spawn data
            questGiversToSpawn.forEach(questGiverData => {
                const questGiverNPC = createNPCWithData(questGiverData, 'questGiver');
                questGivers.push(questGiverNPC);
            });
            
            console.log(`Created ${questGivers.length} quest giver NPCs on curbs towards the middle of blocks`);
        }

        function showVendorButton(vendor) {
            showNPCIcon(vendor, {
                id: `vendorButton_${vendor.userData.vendorId}`,
                icon: '🏪',
                onClick: (npc) => openVendorShop(npc),
                interactionRange: 8,
                visibilityRange: 50,
                heightOffset: 6,
                scalingEnabled: true,
                inRangeSize: { size: 90, fontSize: '64px' },
                outOfRangeSize: { size: 60, fontSize: '36px' },
                hideInDialog: true
            });
        }

        function hideVendorButton(vendor) {
            const vendorButton = document.getElementById(`vendorButton_${vendor.userData.vendorId}`);
            if (vendorButton) {
                vendorButton.style.display = 'none';
            }
        }

        function openVendorShop(vendor) {
            const vendorShop = document.getElementById('vendorShop');
            const vendorTitle = document.getElementById('vendorShopTitle');
            const vendorItems = document.getElementById('vendorShopItems');
            
            // Set shop title based on vendor type
            if (vendor.userData.vendorType === 'weapons') {
                vendorTitle.textContent = 'Weapons Shop';
            } else if (vendor.userData.vendorType === 'quest') {
                vendorTitle.textContent = 'Shop';
            } else {
                vendorTitle.textContent = 'Health Shop';
            }
            
            // Clear existing items
            vendorItems.innerHTML = '';
            
            // Create shop items based on vendor type
            const shopItems = getShopItems(vendor.userData.vendorType);
            
            shopItems.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'vendor-item';
                
                itemElement.innerHTML = `
                    <div class="vendor-item-icon" style="background-image: url(${item.icon})"></div>
                    <div class="vendor-item-info">
                        <div class="vendor-item-name">${item.name}</div>
                        <div class="vendor-item-price">$${item.price}</div>
                    </div>
                `;
                
                // Add click and touch handlers for purchasing
                const purchaseHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    purchaseItem(item, vendor);
                };
                itemElement.addEventListener('click', purchaseHandler);
                itemElement.addEventListener('touchstart', purchaseHandler);

                vendorItems.appendChild(itemElement);
            });
            
            // Show the shop
            vendorShop.classList.add('show');
        }

        function getShopItems(vendorType) {
            if (vendorType === 'quest') {
                // Quest vendor - return the quest item
                if (currentQuest && currentQuest.objective && currentQuest.objective.type === 'BUY') {
                    const itemName = currentQuest.objective.item || "Quest Item";
                    const itemPrice = currentQuest.objective.price || 0;
                    return [{
                        id: 'quest_item',
                        name: itemName,
                        price: itemPrice,
                        icon: lib.getAsset('bullet_box_icon')?.url || '',
                        type: 'quest'
                    }];
                }
                return [];
            } else if (vendorType === 'weapons') {
                const items = [];

                // Add weapons if not owned
                if (!ownedWeapons.has('uzi')) {
                    items.push({
                        id: 'weapon_uzi',
                        name: '🔫 Uzi',
                        price: WEAPON_PRICES.uzi,
                        icon: lib.getAsset('ui_uzi_icon')?.url || '',
                        type: 'weapon',
                        weaponKey: 'uzi'
                    });
                }

                if (!ownedWeapons.has('rocketLauncher')) {
                    items.push({
                        id: 'weapon_rocket',
                        name: '🚀 Rocket Launcher',
                        price: WEAPON_PRICES.rocketLauncher,
                        icon: lib.getAsset('ui_rocketlauncher_icon')?.url || '',
                        type: 'weapon',
                        weaponKey: 'rocketLauncher'
                    });
                }

                // Always show ammo
                items.push(
                    {
                        id: 'pistol_ammo',
                        name: 'Pistol Ammo',
                        price: 200,
                        icon: lib.getAsset('bullet_box_icon')?.url || '',
                        type: 'ammo',
                        weapon: 'pistol',
                        amount: 24
                    },
                    {
                        id: 'uzi_ammo',
                        name: 'Uzi Ammo',
                        price: 400,
                        icon: lib.getAsset('bullet_box_icon')?.url || '',
                        type: 'ammo',
                        weapon: 'uzi',
                        amount: 60
                    },
                    {
                        id: 'rocket_ammo',
                        name: 'Rockets',
                        price: 1000,
                        icon: lib.getAsset('bullet_box_icon')?.url || '',
                        type: 'ammo',
                        weapon: 'rocketLauncher',
                        amount: 3
                    }
                );

                return items;
            } else {
                return [
                    {
                        id: 'health_pack',
                        name: 'Health Pack',
                        price: 300,
                        icon: lib.getAsset('pixelated_heart_icon')?.url || '',
                        type: 'health',
                        amount: 50
                    },
                    {
                        id: 'full_heal',
                        name: 'Full Heal',
                        price: 600,
                        icon: lib.getAsset('pixelated_heart_icon')?.url || '',
                        type: 'health',
                        amount: 100
                    }
                ];
            }
        }

        function purchaseItem(item, vendor) {
            // Check if player has enough money
            if (playerCash < item.price) {
                // Not enough money - show feedback
                triggerRedScreenFlash();
                console.log('Not enough money to purchase item');
                return;
            }

            // Deduct money
            playerCash -= item.price;
            updateCashDisplay();

            // Apply item effect
            if (item.type === 'weapon') {
                // Purchase weapon
                if (acquireWeapon(item.weaponKey)) {
                    console.log(`Purchased ${item.name}`);
                    // Automatically equip the newly purchased weapon
                    switchWeapon(item.weaponKey);
                }
            } else if (item.type === 'ammo') {
                const weaponType = item.weapon || 'pistol';
                // Check if player owns the weapon before selling ammo
                if (!ownedWeapons.has(weaponType)) {
                    showNotification(`You don't own the ${WEAPONS[weaponType].name} yet!`);
                    // Refund the money
                    playerCash += item.price;
                    updateCashDisplay();
                    return;
                }
                WEAPONS[weaponType].currentAmmo = Math.min(
                    WEAPONS[weaponType].currentAmmo + item.amount,
                    WEAPONS[weaponType].maxAmmo
                );
                updateWeaponUI();
                console.log(`Purchased ${item.name} - Added ${item.amount} ${weaponType} ammo`);
            } else if (item.type === 'health') {
                playerHealth = Math.min(100, playerHealth + item.amount);
                updateHealthBar();
                console.log(`Purchased ${item.name} - Restored ${item.amount} health`);
            } else if (item.type === 'quest') {
                // Quest item purchase
                if (currentQuest && currentQuest.objective && currentQuest.objective.type === 'BUY') {
                    const progress = questChainProgress.objectiveProgress[currentQuest.id];
                    if (progress) {
                        progress.itemBought = true;
                        addItemToInventory(item.name);
                        showNotification(`Purchased ${item.name}`);
                        console.log(`Purchased quest item: ${item.name}`);
                    }
                }
            }

            // Trigger success effects
            triggerScreenFlash();

            // Close shop
            closeVendorShop();
        }

        function closeVendorShop() {
            const vendorShop = document.getElementById('vendorShop');
            vendorShop.classList.remove('show');
        }

        function createCar(x, z, direction, movingDirection = 1, lowerBodyColor = 0x404040, upperBodyColor = 0x404040, isPolice = false) {
            const carGroup = new THREE.Group();

            // Lower cube: 7x13x3 units (width x length x height) - 2x scale + 1 unit wider
            // Positioned 0.5 units higher than before
            const lowerGeometry = new THREE.BoxGeometry(7, 3, 13);

            // Create materials for lower body with front and back textures
            const frontAsset = lib.getAsset('car_front_texture');
            const backAsset = lib.getAsset('car_back_texture');
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: lowerBodyColor }); // Body color (grey for regular, blue for police)

            let frontMaterial = bodyMaterial;
            if (frontAsset) {
                const frontTexture = new THREE.TextureLoader().load(frontAsset.url);
                frontTexture.magFilter = THREE.NearestFilter;
                frontTexture.minFilter = THREE.NearestFilter;
                frontMaterial = new THREE.MeshLambertMaterial({
                    map: frontTexture
                });
            }

            let backMaterial = bodyMaterial;
            if (backAsset) {
                const backTexture = new THREE.TextureLoader().load(backAsset.url);
                backTexture.magFilter = THREE.NearestFilter;
                backTexture.minFilter = THREE.NearestFilter;
                backMaterial = new THREE.MeshLambertMaterial({
                    map: backTexture
                });
            }

            // Materials for each face: right, left, top, bottom, front, back
            const lowerMaterials = [
                bodyMaterial,      // right (body color)
                bodyMaterial,      // left (body color)
                bodyMaterial,      // top (body color)
                bodyMaterial,      // bottom (body color)
                frontMaterial,     // front (car front texture)
                backMaterial       // back (car back texture)
            ];
            
            const lowerBody = new THREE.Mesh(lowerGeometry, lowerMaterials);
            lowerBody.position.y = 2.0; // Raised by 0.5 units (was 1.5, now 2.0)
            lowerBody.castShadow = true;
            carGroup.add(lowerBody);
            
            // Upper cube: 7x7x3 units (width x length x height) - 2x scale + 1 unit wider
            // Positioned directly on top of lower cube (no intersection), also raised by 0.5 units
            // Create custom geometry with modified vertices
            const upperGeometry = new THREE.BoxGeometry(7, 3, 7);
            
            // Access the position attribute to modify vertices
            const positionAttribute = upperGeometry.attributes.position;
            const vertices = positionAttribute.array;
            
            // BoxGeometry vertices are arranged as follows (for a 7x3x7 box):
            // We need to identify and modify the top vertices on front and back faces
            // Top vertices have y = 1.5 (half of height 3)
            // Front face has z = -3.5 (negative half of depth 7)
            // Back face has z = 3.5 (positive half of depth 7)
            
            // Iterate through vertices to find and modify the correct ones
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const z = vertices[i + 2];
                
                // Check if this is a top vertex (y = 1.5)
                if (Math.abs(y - 1.5) < 0.01) {
                    // Top front vertices (z = -3.5) - move back 1 unit (towards center)
                    if (Math.abs(z - (-3.5)) < 0.01) {
                        vertices[i + 2] = z + 1; // Move from -3.5 to -2.5
                    } else if (Math.abs(z - 3.5) < 0.01) {
                        // Top back vertices (z = 3.5) - move forward 1 unit (towards center)
                        vertices[i + 2] = z - 1; // Move from 3.5 to 2.5
                    }
                }
            }
            
            // Mark the position attribute as needing update
            positionAttribute.needsUpdate = true;
            
            // Recompute normals for proper lighting after vertex modification
            upperGeometry.computeVertexNormals();
            
            // Create materials for the upper cuboid with window texture on side/front/back faces
            const windowAsset = lib.getAsset('car_window_texture');
            let windowMaterial;
            if (windowAsset) {
                const windowTexture = new THREE.TextureLoader().load(windowAsset.url);
                windowTexture.magFilter = THREE.NearestFilter;
                windowTexture.minFilter = THREE.NearestFilter;
                windowMaterial = new THREE.MeshLambertMaterial({ 
                    map: windowTexture 
                });
            } else {
                // Fallback to light blue glass color
                windowMaterial = new THREE.MeshLambertMaterial({ color: 0x87CEEB });
            }
            
            const upperBodyMaterial = new THREE.MeshLambertMaterial({ color: upperBodyColor }); // Upper body color (grey for regular, white for police)
            
            // Materials for each face: right, left, top, bottom, front, back
            const upperMaterials = [
                windowMaterial,       // right (window texture)
                windowMaterial,       // left (window texture)
                upperBodyMaterial,    // top (upper body color)
                upperBodyMaterial,    // bottom (upper body color)
                windowMaterial,       // front (window texture)
                windowMaterial        // back (window texture)
            ];
            
            const upperBody = new THREE.Mesh(upperGeometry, upperMaterials);
            upperBody.position.y = 5.0; // Raised by 0.5 units (was 4.5, now 5.0)
            upperBody.castShadow = true;
            carGroup.add(upperBody);

            // Store light bar materials if this is a police car (will be added to userData later)
            let lightBarMaterials = null;
            if (isPolice) {
                const lightBarHeight = 0.4;
                const lightBarDepth = 1.2;
                const sectionWidth = 2.1; // 90% of 7 units = 6.3 total, divided by 3 = 2.1 each
                const lightBarY = 6.5 + lightBarHeight / 2; // Top of upper body + half light bar height

                // Red section (left)
                const redGeometry = new THREE.BoxGeometry(sectionWidth, lightBarHeight, lightBarDepth);
                const redMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const redLight = new THREE.Mesh(redGeometry, redMaterial);
                redLight.position.set(-sectionWidth, lightBarY, 0); // Left side
                redLight.castShadow = true;
                carGroup.add(redLight);

                // Grey section (middle)
                const greyGeometry = new THREE.BoxGeometry(sectionWidth, lightBarHeight, lightBarDepth);
                const greyMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const greyLight = new THREE.Mesh(greyGeometry, greyMaterial);
                greyLight.position.set(0, lightBarY, 0); // Center
                greyLight.castShadow = true;
                carGroup.add(greyLight);

                // Blue section (right)
                const blueGeometry = new THREE.BoxGeometry(sectionWidth, lightBarHeight, lightBarDepth);
                const blueMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });
                const blueLight = new THREE.Mesh(blueGeometry, blueMaterial);
                blueLight.position.set(sectionWidth, lightBarY, 0); // Right side
                blueLight.castShadow = true;
                carGroup.add(blueLight);

                // Create radial gradient texture for red glow
                const redCanvas = document.createElement('canvas');
                redCanvas.width = 64;
                redCanvas.height = 64;
                const redCtx = redCanvas.getContext('2d');
                const redGradient = redCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
                redGradient.addColorStop(0, 'rgba(255, 0, 0, 1)');
                redGradient.addColorStop(0.4, 'rgba(255, 0, 0, 0.6)');
                redGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                redCtx.fillStyle = redGradient;
                redCtx.fillRect(0, 0, 64, 64);

                // Create radial gradient texture for blue glow
                const blueCanvas = document.createElement('canvas');
                blueCanvas.width = 64;
                blueCanvas.height = 64;
                const blueCtx = blueCanvas.getContext('2d');
                const blueGradient = blueCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
                blueGradient.addColorStop(0, 'rgba(0, 100, 255, 1)');
                blueGradient.addColorStop(0.4, 'rgba(0, 100, 255, 0.6)');
                blueGradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
                blueCtx.fillStyle = blueGradient;
                blueCtx.fillRect(0, 0, 64, 64);

                // Create horizontal quad materials
                const redGlowTexture = new THREE.CanvasTexture(redCanvas);
                const redGlowMaterial = new THREE.MeshBasicMaterial({
                    map: redGlowTexture,
//                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1.0,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const blueGlowTexture = new THREE.CanvasTexture(blueCanvas);
                const blueGlowMaterial = new THREE.MeshBasicMaterial({
                    map: blueGlowTexture,
//                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1.0,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                // Create horizontal quads (planes) positioned just above the lights
                const glowSize = 9; // Size of glow effect
                const glowPlaneGeometry = new THREE.PlaneGeometry(glowSize, glowSize);

                const redGlowPlane = new THREE.Mesh(glowPlaneGeometry, redGlowMaterial);
                redGlowPlane.position.set(-sectionWidth, lightBarY + 0.5, 0); // Left side, slightly above light
                redGlowPlane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
                carGroup.add(redGlowPlane);

                const blueGlowPlane = new THREE.Mesh(glowPlaneGeometry, blueGlowMaterial);
                blueGlowPlane.position.set(sectionWidth, lightBarY + 0.5, 0); // Right side, slightly above light
                blueGlowPlane.rotation.x = -Math.PI / 2; // Rotate to be horizontal
                carGroup.add(blueGlowPlane);

                // Store material references for animation (will be added to userData below)
                lightBarMaterials = {
                    redMaterial: redMaterial,
                    blueMaterial: blueMaterial,
                    redGlowPlane: redGlowPlane,
                    blueGlowPlane: blueGlowPlane,
                    animationOffset: Math.random() * 1000 // Random offset so lights aren't in sync
                };
            }

            // Add four tires as 1x1x1 perfect black cubes
            // Positioned 1 unit inward from each corner of the lower cube
            // Tires stay at ground level (NOT raised)
            const tireGeometry = new THREE.BoxGeometry(1, 3, 3);
            const tireMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); // All black
            
            // Calculate tire positions - 1 unit inward from corners of 7x13 lower cube
            const tirePositions = [
                { x: -3.5, z: -4.5 }, // Front-left (1 unit in from -3.5, -6.5)
                { x: 3.5, z: -4.5 },  // Front-right (1 unit in from 3.5, -6.5)
                { x: -3.5, z: 4.5 },  // Back-left (1 unit in from -3.5, 6.5)
                { x: 3.5, z: 4.5 }    // Back-right (1 unit in from 3.5, 6.5)
            ];
            
            const tires = [];
            tirePositions.forEach(pos => {
                const tire = new THREE.Mesh(tireGeometry, tireMaterial);
                tire.position.set(pos.x, 0.5, pos.z); // Height 1/2 = 0.5 above ground (NOT raised)
                tire.castShadow = true;
                carGroup.add(tire);
                tires.push(tire);
            });
            
            // Create 12x12 unit drop shadow for each car
            const carShadowGeometry = new THREE.PlaneGeometry(12, 12);
            
            // Create canvas for car shadow gradient
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient: 80% alpha black center to 0% alpha black edge
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)'); // 80% alpha black center
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // 0% alpha black edge
            
            // Fill canvas with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            // Create texture from canvas
            const carShadowTexture = new THREE.CanvasTexture(canvas);
            carShadowTexture.needsUpdate = true;
            
            // Create material with transparency
            const carShadowMaterial = new THREE.MeshBasicMaterial({
                map: carShadowTexture,
                transparent: true,
                opacity: 1,
                depthWrite: false // Prevent z-fighting with ground
            });
            
            // Create car shadow plane mesh
            const carShadow = new THREE.Mesh(carShadowGeometry, carShadowMaterial);
            carShadow.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
            carShadow.position.set(0, 0.01, 0); // Y = 0.01 as specified
            
            // Add shadow to car group
            carGroup.add(carShadow);
            
            // Position the car
            carGroup.position.set(x, 0, z);
            
            // Store car data including references to body parts for animation
            carGroup.userData = {
                isCar: true,
                isPolice: isPolice, // Explicit flag for police cars
                direction: direction,
                movingDirection: movingDirection,
                moveSpeed: 24,
                lowerBody: lowerBody,
                upperBody: upperBody,
                tires: tires,
                bounceTime: Math.random() * Math.PI * 2, // Random starting bounce phase
                shadowPlane: carShadow, // Store reference to shadow plane
                angularVelocity: 0, // Initialize with ZERO rotational force
                lightBar: lightBarMaterials // Store light bar materials for animation (null if not police car)
            };
            
            scene.add(carGroup);
            return carGroup;
        }

        function generateRoadNetwork() {
            const worldSize = getWorldSize();
            const spacing = BLOCK_SPACING;
            const roadWidth = ROAD_WIDTH;

            const network = {
                nodes: {},
                segments: {}
            };

            const gridStart = -Math.floor(worldSize / spacing) * spacing / 2;
            const gridEnd = Math.floor(worldSize / spacing) * spacing / 2;

            const roadPositions = [];
            for (let pos = gridStart - spacing / 2; pos <= gridEnd + spacing / 2; pos += spacing) {
                if (Math.abs(pos) <= worldSize / 2) {
                    roadPositions.push(pos);
                }
            }

            const gridPositions = [];
            for (let x of roadPositions) {
                for (let z of roadPositions) {
                    gridPositions.push({ x, z });
                }
            }

            gridPositions.forEach((pos, index) => {
                const nodeId = `node_${index}`;
                network.nodes[nodeId] = {
                    id: nodeId,
                    x: pos.x,
                    z: pos.z,
                    segments: [],
                    intersectionRadius: 15
                };
            });

            let segmentCount = 0;
            const nodeArray = Object.values(network.nodes);

            for (let i = 0; i < nodeArray.length; i++) {
                const node1 = nodeArray[i];

                for (let j = i + 1; j < nodeArray.length; j++) {
                    const node2 = nodeArray[j];

                    const dx = Math.abs(node2.x - node1.x);
                    const dz = Math.abs(node2.z - node1.z);

                    if ((dx === spacing && dz === 0) || (dx === 0 && dz === spacing)) {
                        const segId = `seg_${segmentCount++}`;
                        network.segments[segId] = createSegment(segId, node1.id, node2.id, network.nodes);
                    }
                }
            }

            // Create dead-end segments at world edges
            const minPos = Math.min(...roadPositions);
            const maxPos = Math.max(...roadPositions);
            const worldBoundary = worldSize / 2;

            for (let i = 0; i < nodeArray.length; i++) {
                const node = nodeArray[i];

                // Check if node is on west edge (minimum x)
                if (node.x === minPos) {
                    const deadEndId = `deadend_w_${i}`;
                    network.nodes[deadEndId] = {
                        id: deadEndId,
                        x: -worldBoundary,
                        z: node.z,
                        segments: [],
                        intersectionRadius: 15
                    };
                    const segId = `seg_${segmentCount++}`;
                    network.segments[segId] = createSegment(segId, node.id, deadEndId, network.nodes);
                }

                // Check if node is on east edge (maximum x)
                if (node.x === maxPos) {
                    const deadEndId = `deadend_e_${i}`;
                    network.nodes[deadEndId] = {
                        id: deadEndId,
                        x: worldBoundary,
                        z: node.z,
                        segments: [],
                        intersectionRadius: 15
                    };
                    const segId = `seg_${segmentCount++}`;
                    network.segments[segId] = createSegment(segId, node.id, deadEndId, network.nodes);
                }

                // Check if node is on south edge (minimum z)
                if (node.z === minPos) {
                    const deadEndId = `deadend_s_${i}`;
                    network.nodes[deadEndId] = {
                        id: deadEndId,
                        x: node.x,
                        z: -worldBoundary,
                        segments: [],
                        intersectionRadius: 15
                    };
                    const segId = `seg_${segmentCount++}`;
                    network.segments[segId] = createSegment(segId, node.id, deadEndId, network.nodes);
                }

                // Check if node is on north edge (maximum z)
                if (node.z === maxPos) {
                    const deadEndId = `deadend_n_${i}`;
                    network.nodes[deadEndId] = {
                        id: deadEndId,
                        x: node.x,
                        z: worldBoundary,
                        segments: [],
                        intersectionRadius: 15
                    };
                    const segId = `seg_${segmentCount++}`;
                    network.segments[segId] = createSegment(segId, node.id, deadEndId, network.nodes);
                }
            }

            console.log(`Generated road network: ${nodeArray.length} nodes, ${segmentCount} segments`);
            return network;
        }

        function createSegment(id, startNodeId, endNodeId, nodes) {
            const start = nodes[startNodeId];
            const end = nodes[endNodeId];

            const dx = end.x - start.x;
            const dz = end.z - start.z;
            const length = Math.sqrt(dx * dx + dz * dz);

            const dirX = dx / length;
            const dirZ = dz / length;

            const intersectionRadius = start.intersectionRadius;

            const roadStart = {
                x: start.x + dirX * intersectionRadius,
                z: start.z + dirZ * intersectionRadius
            };

            const roadEnd = {
                x: end.x - dirX * intersectionRadius,
                z: end.z - dirZ * intersectionRadius
            };

            const roadLength = length - 2 * intersectionRadius;

            const segment = {
                id,
                startNode: startNodeId,
                endNode: endNodeId,

                start: { x: start.x, z: start.z },
                end: { x: end.x, z: end.z },
                direction: { x: dirX, z: dirZ },
                perpendicular: { x: -dirZ, z: dirX },
                length,
                angle: Math.atan2(dirX, dirZ),  // Fixed: use (X, Z) order to match player angle calculation
                width: 30,

                roadStart,
                roadEnd,
                roadLength
            };

            nodes[startNodeId].segments.push(id);
            nodes[endNodeId].segments.push(id);

            return segment;
        }

        function getOtherNode(segment, currentNodeId) {
            return segment.startNode === currentNodeId
                ? segment.endNode
                : segment.startNode;
        }

        function getSegmentDirection(segment, targetNodeId) {
            return segment.endNode === targetNodeId ? 1 : -1;
        }

        function getExitAngle(segment, fromNodeId) {
            return segment.startNode === fromNodeId
                ? segment.angle
                : segment.angle + Math.PI;
        }

        function getWorldBoundary() {
            const worldSize = getWorldSize();
            return worldSize / 2;
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;
            return angle;
        }

        function lerpAngle(from, to, t) {
            let delta = to - from;
            while (delta > Math.PI) delta -= 2 * Math.PI;
            while (delta < -Math.PI) delta += 2 * Math.PI;
            return normalizeAngle(from + delta * t);
        }

        function evaluateCubicBezier(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;

            return {
                x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,
                z: mt3 * p0.z + 3 * mt2 * t * p1.z + 3 * mt * t2 * p2.z + t3 * p3.z
            };
        }

        function evaluateCubicBezierTangent(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const mt = 1 - t;
            const mt2 = mt * mt;

            const dx = 3 * mt2 * (p1.x - p0.x) + 6 * mt * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x);
            const dz = 3 * mt2 * (p1.z - p0.z) + 6 * mt * t * (p2.z - p1.z) + 3 * t2 * (p3.z - p2.z);

            const length = Math.sqrt(dx * dx + dz * dz);
            return { x: dx / length, z: dz / length };
        }

        function findClosestSegment(position) {
            let minDist = Infinity;
            let closestSeg = null;

            for (let segId in window.roadNetwork.segments) {
                const seg = window.roadNetwork.segments[segId];
                const dist = distanceToSegment(position, seg.start, seg.end);
                if (dist < minDist) {
                    minDist = dist;
                    closestSeg = seg;
                }
            }

            return { segment: closestSeg, distance: minDist };
        }

        function distanceToSegment(point, segStart, segEnd) {
            const dx = segEnd.x - segStart.x;
            const dz = segEnd.z - segStart.z;
            const lengthSq = dx * dx + dz * dz;

            if (lengthSq === 0) {
                const distX = point.x - segStart.x;
                const distZ = point.z - segStart.z;
                return Math.sqrt(distX * distX + distZ * distZ);
            }

            const toPointX = point.x - segStart.x;
            const toPointZ = point.z - segStart.z;
            let t = (toPointX * dx + toPointZ * dz) / lengthSq;
            t = Math.max(0, Math.min(1, t));

            const closestX = segStart.x + t * dx;
            const closestZ = segStart.z + t * dz;

            const distX = point.x - closestX;
            const distZ = point.z - closestZ;
            return Math.sqrt(distX * distX + distZ * distZ);
        }

        function assignCarToRoadNetwork(car) {
            if (car.userData.isPlayerControlled ||
                car.userData.isQuestCar ||
                car.userData.state === 'stopped') {
                car.userData.navigation = null;
                return;
            }

            const result = findClosestSegment(car.position);

            if (result.distance > 20) {
                console.warn('Car too far from road network, skipping navigation assignment');
                car.userData.navigation = null;
                return;
            }

            const seg = result.segment;

            const carAngle = car.rotation.y;
            const forwardAngleDiff = Math.abs(normalizeAngle(carAngle - seg.angle));
            const backwardAngleDiff = Math.abs(normalizeAngle(carAngle - (seg.angle + Math.PI)));

            const direction = forwardAngleDiff < backwardAngleDiff ? 1 : -1;

            const toCarX = car.position.x - seg.roadStart.x;
            const toCarZ = car.position.z - seg.roadStart.z;
            const progress = (toCarX * seg.direction.x + toCarZ * seg.direction.z) / seg.roadLength;

            car.userData.navigation = {
                segment: seg.id,
                progress: Math.max(0, Math.min(1, progress)),
                targetNode: direction > 0 ? seg.endNode : seg.startNode,
                direction: direction,
                laneOffset: 7.5,
                inIntersection: false,
                intersectionProgress: 0,
                intersectionEntry: null,
                intersectionExit: null,
                entryRotation: 0
            };
        }

        function createTextSprite(text, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.fillStyle = 'rgba(0, 0, 0, 0.6)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = 'Bold 32px Arial';
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 5, 1);

            return sprite;
        }

        function renderRoadNetworkDebug() {
            const network = window.roadNetwork;
            if (!network) return;

            const segmentLines = [];
            const nodeMarkers = [];

            for (let segId in network.segments) {
                const seg = network.segments[segId];

                const dx = seg.end.x - seg.start.x;
                const dz = seg.end.z - seg.start.z;
                const length = Math.sqrt(dx * dx + dz * dz);
                const dirX = dx / length;
                const dirZ = dz / length;

                const shortenAmount = 4;

                const startX = seg.start.x + dirX * shortenAmount;
                const startZ = seg.start.z + dirZ * shortenAmount;
                const endX = seg.end.x - dirX * shortenAmount;
                const endZ = seg.end.z - dirZ * shortenAmount;

                segmentLines.push(startX, 0.2, startZ);
                segmentLines.push(endX, 0.2, endZ);

                const midX = (seg.start.x + seg.end.x) / 2;
                const midZ = (seg.start.z + seg.end.z) / 2;
                const segmentLabel = createTextSprite(seg.id, '#00ff00');
                segmentLabel.position.set(midX, 3, midZ);
                scene.add(segmentLabel);

                const startNodeLabel = createTextSprite(seg.startNode, '#ffff00');
                startNodeLabel.position.set(seg.start.x + dirX * 2, 1.5, seg.start.z + dirZ * 2);
                scene.add(startNodeLabel);

                const endNodeLabel = createTextSprite(seg.endNode, '#ffff00');
                endNodeLabel.position.set(seg.end.x - dirX * 2, 1.5, seg.end.z - dirZ * 2);
                scene.add(endNodeLabel);
            }

            for (let nodeId in network.nodes) {
                const node = network.nodes[nodeId];

                const size = 2;
                nodeMarkers.push(node.x - size, 0.3, node.z - size);
                nodeMarkers.push(node.x + size, 0.3, node.z - size);

                nodeMarkers.push(node.x + size, 0.3, node.z - size);
                nodeMarkers.push(node.x + size, 0.3, node.z + size);

                nodeMarkers.push(node.x + size, 0.3, node.z + size);
                nodeMarkers.push(node.x - size, 0.3, node.z + size);

                nodeMarkers.push(node.x - size, 0.3, node.z + size);
                nodeMarkers.push(node.x - size, 0.3, node.z - size);

                const nodeLabel = createTextSprite(nodeId, '#ff0000');
                nodeLabel.position.set(node.x, 5, node.z);
                scene.add(nodeLabel);
            }

            const segmentGeometry = new THREE.BufferGeometry();
            segmentGeometry.setAttribute('position', new THREE.Float32BufferAttribute(segmentLines, 3));
            const segmentMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
            const segmentLinesMesh = new THREE.LineSegments(segmentGeometry, segmentMaterial);
            scene.add(segmentLinesMesh);

            const nodeGeometry = new THREE.BufferGeometry();
            nodeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodeMarkers, 3));
            const nodeMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
            const nodeLinesMesh = new THREE.LineSegments(nodeGeometry, nodeMaterial);
            scene.add(nodeLinesMesh);

            console.log('Road network debug visualization added');
        }

        function createCars() {
            if (!window.roadNetwork) {
                window.roadNetwork = generateRoadNetwork();
            }

            // Clear existing cars
            carObjects.forEach(car => scene.remove(car));
            carObjects = [];
            
            // Generate cars fresh every time (use local array, not persistent gameConfig)
            const carsToSpawn = [];
            const worldSize = getWorldSize();
            const squareSize = BLOCK_SIZE;
            const spacing = BLOCK_SPACING;
            const roadWidth = ROAD_WIDTH;
            const carLength = 13;
            const minCarSpacing = carLength * 2;
                
                // Calculate grid bounds
                const gridStart = -Math.floor(worldSize / spacing) * spacing / 2;
                const gridEnd = Math.floor(worldSize / spacing) * spacing / 2;
                
                // Find all X-axis roads (horizontal roads between curb rows)
                const xAxisRoads = [];
                for (let z = gridStart - spacing/2; z <= gridEnd + spacing/2; z += spacing) {
                    if (Math.abs(z) <= worldSize/2) { // Within world bounds
                        xAxisRoads.push({
                            centerZ: z,
                            startX: -worldSize/2,
                            endX: worldSize/2,
                            direction: 'x',
                            length: worldSize
                        });
                    }
                }
                
                // Find all Z-axis roads (vertical roads between curb columns)
                const zAxisRoads = [];
                for (let x = gridStart - spacing/2; x <= gridEnd + spacing/2; x += spacing) {
                    if (Math.abs(x) <= worldSize/2) { // Within world bounds
                        zAxisRoads.push({
                            centerX: x,
                            startZ: -worldSize/2,
                            endZ: worldSize/2,
                            direction: 'z',
                            length: worldSize
                        });
                    }
                }
                
                function isPositionValid(newX, newZ, direction, existingCars) {
                    // Check if position is on water
                    if (isOnWater(newX, newZ)) {
                        return false;
                    }

                    for (const existingCar of existingCars) {
                        const distX = Math.abs(newX - existingCar.x);
                        const distZ = Math.abs(newZ - existingCar.z);

                        // Check spacing based on road direction
                        if (direction === 'x' && existingCar.direction === 'x') {
                            // Same X-axis road, check X spacing
                            if (Math.abs(newZ - existingCar.z) < 1 && distX < minCarSpacing) {
                                return false;
                            }
                        } else if (direction === 'z' && existingCar.direction === 'z') {
                            // Same Z-axis road, check Z spacing
                            if (Math.abs(newX - existingCar.x) < 1 && distZ < minCarSpacing) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
                
                function findValidPosition(road, direction, laneOffset, existingCars, maxRetries = 50) {
                    for (let attempt = 0; attempt < maxRetries; attempt++) {
                        let carX, carZ;
                        
                        if (direction === 'x') {
                            const randomPosition = Math.random();
                            carX = road.startX + randomPosition * road.length;
                            carZ = road.centerZ + laneOffset;
                        } else {
                            const randomPosition = Math.random();
                            carX = road.centerX + laneOffset;
                            carZ = road.startZ + randomPosition * road.length;
                        }
                        
                        if (isPositionValid(carX, carZ, direction, existingCars)) {
                            return { x: carX, z: carZ };
                        }
                    }
                    
                    // If no valid position found after retries, place at road start with offset
                    if (direction === 'x') {
                        return { 
                            x: road.startX + (existingCars.length * minCarSpacing) % road.length, 
                            z: road.centerZ + laneOffset 
                        };
                    } else {
                        return { 
                            x: road.centerX + laneOffset, 
                            z: road.startZ + (existingCars.length * minCarSpacing) % road.length 
                        };
                    }
                }
                
                // Calculate number of cars based on total road distance
                const allRoads = [...xAxisRoads, ...zAxisRoads];

                // Total road distance = sum of all road lengths
                const totalRoadDistance = allRoads.reduce((sum, road) => sum + road.length, 0);

                // Calculate number of cars using global constant
                const numCars = Math.max(1, Math.floor(totalRoadDistance / ROAD_UNITS_PER_CAR));

                for (let i = 0; i < numCars; i++) {
                    const road = allRoads[Math.floor(Math.random() * allRoads.length)];
                    const direction = road.direction;
                    const laneOffset = 7.5;
                    const position = findValidPosition(road, direction, -laneOffset, carsToSpawn);

                    // Determine if this car is a police car (10% chance)
                    const isPolice = Math.random() < POLICE_CAR_SPAWN_RATE;

                    const carData = {
                        id: `car_${i}`,
                        x: position.x,
                        z: position.z,
                        direction: direction,
                        movingDirection: 1,
                        isPolice: isPolice
                    };
                    carsToSpawn.push(carData);
                }

            // Create visual cars from spawn data
            carsToSpawn.forEach(carData => {
                // Select colors based on whether this is a police car
                const colors = carData.isPolice ? POLICE_CAR_COLORS : getRandomCarColor();
                const car = createCar(
                    carData.x, carData.z, carData.direction, carData.movingDirection,
                    colors.lower, colors.upper, carData.isPolice
                );
                car.userData.carId = carData.id;
                car.userData.movingDirection = carData.movingDirection;
                
                // Set initial rotation to perfectly orthogonal orientations (multiples of 90 degrees)
                // ZERO rotation until player-controlled car collides with them
                if (carData.direction === 'x') {
                    if (carData.movingDirection === 1) {
                        car.rotation.y = Math.PI / 2; // Exactly 90 degrees - Face east (positive X direction)
                    } else {
                        car.rotation.y = -Math.PI / 2; // Exactly -90 degrees - Face west (negative X direction)
                    }
                } else {
                    if (carData.movingDirection === 1) {
                        car.rotation.y = 0; // Exactly 0 degrees - Face north (positive Z direction)
                    } else {
                        car.rotation.y = Math.PI; // Exactly 180 degrees - Face south (negative Z direction)
                    }
                }
                
                // Ensure angular velocity is ZERO for all cars initially
                car.userData.angularVelocity = 0;
                
                carObjects.push(car);
            });

            console.log(`Created ${carObjects.length} cars driving in the streets (1 car per ${ROAD_UNITS_PER_CAR} units of road)`);

            console.log('Assigning cars to road network...');
            carObjects.forEach(car => {
                assignCarToRoadNetwork(car);
            });
            const assignedCount = carObjects.filter(c => c.userData.navigation != null).length;
            console.log(`Assigned ${assignedCount}/${carObjects.length} cars to road network`);

//            renderRoadNetworkDebug();
        }

        function spawnCarjackNPC(car) {
            // Calculate car's front left position based on direction and movement
            let frontLeftX, frontLeftZ;
            const carX = car.position.x;
            const carZ = car.position.z;
            
            if (car.userData.direction === 'x') {
                // Car is on X-axis road
                if (car.userData.movingDirection === 1) {
                    // Moving east (+X), front is at +X side, left is at -Z side
                    frontLeftX = carX + 6.5; // Front of car (13/2 = 6.5 units forward)
                    frontLeftZ = carZ - 3.5; // Left side of car (7/2 = 3.5 units left)
                } else {
                    // Moving west (-X), front is at -X side, left is at +Z side
                    frontLeftX = carX - 6.5; // Front of car
                    frontLeftZ = carZ + 3.5; // Left side of car
                }
            } else {
                // Car is on Z-axis road
                if (car.userData.movingDirection === 1) {
                    // Moving north (+Z), front is at +Z side, left is at -X side
                    frontLeftX = carX - 3.5; // Left side of car
                    frontLeftZ = carZ + 6.5; // Front of car
                } else {
                    // Moving south (-Z), front is at -Z side, left is at +X side
                    frontLeftX = carX + 3.5; // Left side of car
                    frontLeftZ = carZ - 6.5; // Front of car
                }
            }
            
            // Move 4 units further to the left from front left position
            if (car.userData.direction === 'x') {
                if (car.userData.movingDirection === 1) {
                    frontLeftZ -= 4; // 4 more units to the left (negative Z)
                } else {
                    frontLeftZ += 4; // 4 more units to the left (positive Z)
                }
            } else {
                if (car.userData.movingDirection === 1) {
                    frontLeftX -= 4; // 4 more units to the left (negative X)
                } else {
                    frontLeftX += 4; // 4 more units to the left (positive X)
                }
            }
            
            // Check if this is a police car
            const isPoliceCar = car.userData.isPolice || false;

            // Create NPC at the calculated position (force police uniform if police car)
            const carjackNPC = createCharacter(frontLeftX, frontLeftZ, false, null, isPoliceCar);

            // Set special carjack NPC properties
            carjackNPC.userData.isCarjackNPC = true;
            carjackNPC.userData.whenIdle = "stationary";
            carjackNPC.userData.fadeInProgress = 0;
            carjackNPC.userData.fadeOutProgress = 0;
            carjackNPC.userData.runSpeed = CARJACK_NPC_RUN_SPEED;
            carjackNPC.userData.distanceFromCar = 0;
            carjackNPC.userData.isRunningAway = false;
            carjackNPC.userData.isFadingOut = false;
            carjackNPC.userData.originalCar = car;

            if (isPoliceCar) {
                // Police officer exits and immediately attacks
                carjackNPC.userData.isPoliceOfficer = true;
                carjackNPC.userData.whenScared = "aggressive";
                carjackNPC.userData.whenApproached = "none";
                carjackNPC.userData.isAggressive = true;
                carjackNPC.userData.isShooting = true;
                carjackNPC.userData.shootingStartTime = Date.now();
                carjackNPC.userData.lastShotTime = 0;
            } else {
                // Regular civilian flees
                carjackNPC.userData.whenScared = "flee";
                carjackNPC.userData.whenApproached = "none";
            }
            
            // Calculate run direction (away from car)
            const directionX = frontLeftX - carX;
            const directionZ = frontLeftZ - carZ;
            const distance = Math.sqrt(directionX * directionX + directionZ * directionZ);

            // Safety check: if distance is too small, use a default direction
            if (distance < 0.1) {
                carjackNPC.userData.runDirectionX = 1; // Default: run in +X direction
                carjackNPC.userData.runDirectionZ = 0;
            } else {
                carjackNPC.userData.runDirectionX = directionX / distance;
                carjackNPC.userData.runDirectionZ = directionZ / distance;
            }
            
            // Set initial position and make invisible for fade-in
            carjackNPC.position.y = 0.6; // Ground level
            carjackNPC.visible = false;
            
            // Add to scene and NPC list
            scene.add(carjackNPC);
            npcCharacters.push(carjackNPC);
        }

        function spawnHealthPack(x, y, z) {
            const healthPackGroup = new THREE.Group();
            
            // Create 1x1x1 unit cube for health pack
            const packGeometry = new THREE.BoxGeometry(1, 1, 1);
            
            // Get health pack crate texture
            const crateAsset = lib.getAsset('health_pack_crate');
            let crateMaterial;
            
            if (crateAsset) {
                const crateTexture = new THREE.TextureLoader().load(crateAsset.url);
                crateTexture.magFilter = THREE.NearestFilter;
                crateTexture.minFilter = THREE.NearestFilter;
                crateTexture.wrapS = THREE.RepeatWrapping;
                crateTexture.wrapT = THREE.RepeatWrapping;
                
                crateMaterial = new THREE.MeshLambertMaterial({ 
                    map: crateTexture 
                });
            } else {
                // Fallback to brown crate with red heart
                crateMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown wood color
            }
            
            const pack = new THREE.Mesh(packGeometry, crateMaterial);
            pack.castShadow = true;
            healthPackGroup.add(pack);
            
            // Create drop shadow for health pack (same size as player shadow: 2x2 units)
            const healthShadowGeometry = new THREE.PlaneGeometry(2, 2);
            
            // Create canvas for health pack shadow gradient (same as player shadow)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient: 80% alpha black center to 0% alpha black edge (same as player)
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)'); // 80% alpha black center
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // 0% alpha black edge
            
            // Fill canvas with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            // Create texture from canvas
            const healthShadowTexture = new THREE.CanvasTexture(canvas);
            healthShadowTexture.needsUpdate = true;
            
            // Create material with transparency
            const healthShadowMaterial = new THREE.MeshBasicMaterial({
                map: healthShadowTexture,
                transparent: true,
                opacity: 1,
                depthWrite: false // Prevent z-fighting with ground
            });
            
            // Create health pack shadow plane mesh
            const healthShadow = new THREE.Mesh(healthShadowGeometry, healthShadowMaterial);
            healthShadow.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
            
            // Add shadow to scene (not to health pack group, so it stays on ground)
            scene.add(healthShadow);
            
            // Position the health pack
            healthPackGroup.position.set(x, y, z);
            
            // Store physics data
            healthPackGroup.userData = {
                isHealthPack: true,
                hoverTime: 0,
                rotationSpeed: 1 + Math.random() * 1, // 1-2 radians/sec Y rotation
                isCollectable: true, // Always collectable
                shadowPlane: healthShadow // Store reference to shadow plane
            };
            
            scene.add(healthPackGroup);
            healthPacks.push(healthPackGroup);
        }

        function spawnAmmoPickup(x, y, z, weaponType = null) {
            // Randomly select weapon type if not specified
            if (!weaponType) {
                const weapons = Object.keys(WEAPONS);
                weaponType = weapons[Math.floor(Math.random() * weapons.length)];
            }

            const weapon = WEAPONS[weaponType];
            const pickupGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.8);
            const pickupMaterial = new THREE.MeshBasicMaterial({
                color: weaponType === 'rocketLauncher' ? 0xFF4500 :
                       weaponType === 'uzi' ? 0xFFD700 : 0xFFFF00
            });
            const pickup = new THREE.Mesh(pickupGeometry, pickupMaterial);

            pickup.position.set(x, y, z);
            pickup.userData = {
                type: 'ammo',
                isAmmoPickup: true,  // Mark as ammo pickup
                weaponType: weaponType,
                ammoAmount: Math.floor(weapon.maxAmmo * 0.3),  // 30% of max ammo
                hoverTime: Math.random() * Math.PI * 2,
                isCollectable: true,  // Start as collectable
                targetGroundHeight: 1.0  // Float 1 unit above ground
            };

            scene.add(pickup);
            cashBundles.push(pickup);  // Add directly as mesh, like cash bundles
        }

        function spawnCashBundle(x, y, z) {
            const cashGroup = new THREE.Group();
            
            // Create 1.125x2x0.5 unit cuboid (width x length x height)
            const bundleGeometry = new THREE.BoxGeometry(1.125, 0.5, 2);
            
            // Get dollar bill texture for top and bottom faces
            const dollarAsset = lib.getAsset('dollar_bill_texture');
            let topBottomMaterial;
            
            if (dollarAsset) {
                const dollarTexture = new THREE.TextureLoader().load(dollarAsset.url);
                dollarTexture.magFilter = THREE.NearestFilter;
                dollarTexture.minFilter = THREE.NearestFilter;
                dollarTexture.wrapS = THREE.RepeatWrapping;
                dollarTexture.wrapT = THREE.RepeatWrapping;
                
                // Fix texture mapping: dollar bill is 9:16 (taller), cuboid top is 1.125x2 (longer)
                // The texture was incorrectly rotated 90 degrees - now map it correctly
                // Scale to fit cuboid dimensions properly
                dollarTexture.repeat.set(1, 1); // Use natural texture scaling
                
                topBottomMaterial = new THREE.MeshLambertMaterial({ 
                    map: dollarTexture 
                });
            } else {
                // Fallback to green color
                topBottomMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            }
            
            // Get paper stack texture for sides (front, back, left, right)
            const paperAsset = lib.getAsset('paper_stack_texture') || lib.getAsset('paper_stack_side_texture') || lib.getAsset('paper_edge_texture');
            let sideMaterial;
            
            if (paperAsset) {
                const paperTexture = new THREE.TextureLoader().load(paperAsset.url);
                paperTexture.magFilter = THREE.NearestFilter;
                paperTexture.minFilter = THREE.NearestFilter;
                paperTexture.wrapS = THREE.RepeatWrapping;
                paperTexture.wrapT = THREE.RepeatWrapping;
                
                sideMaterial = new THREE.MeshLambertMaterial({ 
                    map: paperTexture 
                });
            } else {
                // Fallback to pale off-white color with slight yellow tint for paper stack sides
                sideMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFAE6 }); // Very pale yellow-white
            }
            
            // Materials for each face: right, left, top, bottom, front, back
            const bundleMaterials = [
                sideMaterial,      // right (paper stack texture)
                sideMaterial,      // left (paper stack texture)
                topBottomMaterial, // top (dollar bill texture)
                topBottomMaterial, // bottom (dollar bill texture)
                sideMaterial,      // front (paper stack texture)
                sideMaterial       // back (paper stack texture)
            ];
            
            const bundle = new THREE.Mesh(bundleGeometry, bundleMaterials);
            bundle.castShadow = true;
            cashGroup.add(bundle);
            
            // Create drop shadow for cash bundle (same size as player shadow: 2x2 units)
            const cashShadowGeometry = new THREE.PlaneGeometry(2, 2);
            
            // Create canvas for cash shadow gradient (same as player shadow)
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient: 80% alpha black center to 0% alpha black edge (same as player)
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)'); // 80% alpha black center
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // 0% alpha black edge
            
            // Fill canvas with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            // Create texture from canvas
            const cashShadowTexture = new THREE.CanvasTexture(canvas);
            cashShadowTexture.needsUpdate = true;
            
            // Create material with transparency
            const cashShadowMaterial = new THREE.MeshBasicMaterial({
                map: cashShadowTexture,
                transparent: true,
                opacity: 1,
                depthWrite: false // Prevent z-fighting with ground
            });
            
            // Create cash shadow plane mesh
            const cashShadow = new THREE.Mesh(cashShadowGeometry, cashShadowMaterial);
            cashShadow.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
            
            // Add shadow to scene (not to cash group, so it stays on ground)
            scene.add(cashShadow);
            
            // Position the cash bundle
            cashGroup.position.set(x, y, z);
            
            // Random direction for lobbing - SLOWER SPEEDS, only 2 units away
            const randomAngle = Math.random() * Math.PI * 2;
            const horizontalSpeed = 2; // Fixed 2 units total distance
            const verticalSpeed = 6 + Math.random() * 2; // 6-8 units/sec initial upward (higher arc)
            
            // Store physics data
            cashGroup.userData = {
                isCashBundle: true,
                velocity: {
                    x: Math.cos(randomAngle) * horizontalSpeed,
                    y: verticalSpeed,
                    z: Math.sin(randomAngle) * horizontalSpeed
                },
                targetGroundHeight: 1, // Will hover 1 unit above ground
                isFlying: true,
                hoverTime: 0,
                rotationSpeed: 1 + Math.random() * 2, // 1-3 radians/sec Y rotation
                isCollectable: false, // Not collectable until it lands and starts hovering
                shadowPlane: cashShadow // Store reference to shadow plane
            };
            
            scene.add(cashGroup);
            cashBundles.push(cashGroup);
        }

        function updateHealthPacks(deltaTime) {
            healthPacks.forEach((pack, index) => {
                if (!pack.userData.isHealthPack) return;
                
                // Hovering behavior - smooth up and down 0.5 units
                pack.userData.hoverTime += deltaTime * 2; // Hover frequency
                const collision = checkCollisions(pack.position.x, pack.position.z, pack.position.y);
                const baseHoverHeight = collision.groundHeight + 1.1 + 0.5; // On top of grass + half pack height
                const hoverOffset = Math.sin(pack.userData.hoverTime) * 0.25; // ±0.25 units (0.5 unit total range)
                pack.position.y = baseHoverHeight + hoverOffset;
                
                // Check for player collision if collectable
                if (pack.userData.isCollectable && character) {
                    const distanceToPlayer = Math.sqrt(
                        Math.pow(character.position.x - pack.position.x, 2) + 
                        Math.pow(character.position.z - pack.position.z, 2)
                    );
                    
                    if (distanceToPlayer <= 1.6875) { // Player collision radius (1.5 * 1.125 = 1.6875)
                        // Player collected the health pack!
                        collectHealthPack(pack, index);
                    }
                }
                
                // Update shadow position
                if (pack.userData.shadowPlane) {
                    const shadowGroundHeight = collision.groundHeight + 0.01; // Same height as other shadows
                    pack.userData.shadowPlane.position.set(pack.position.x, shadowGroundHeight, pack.position.z);
                }
                
                // Gentle Y-axis rotation (always)
                pack.rotation.y += pack.userData.rotationSpeed * deltaTime;
            });
        }

        function updateCashBundles(deltaTime) {
            cashBundles.forEach((bundle, index) => {
                // Skip if not a cash bundle or ammo pickup
                if (!bundle.userData.isCashBundle && !bundle.userData.isAmmoPickup) return;
                
                if (bundle.userData.isFlying) {
                    // Physics simulation during flight
                    const gravity = -9.8; // Gravity acceleration
                    
                    // Update velocity
                    bundle.userData.velocity.y += gravity * deltaTime;
                    
                    // Update position
                    bundle.position.x += bundle.userData.velocity.x * deltaTime;
                    bundle.position.y += bundle.userData.velocity.y * deltaTime;
                    bundle.position.z += bundle.userData.velocity.z * deltaTime;
                    
                    // Check ground collision
                    const collision = checkCollisions(bundle.position.x, bundle.position.z, bundle.position.y);
                    const landingHeight = collision.groundHeight + bundle.userData.targetGroundHeight;
                    
                    if (bundle.position.y <= landingHeight && bundle.userData.velocity.y <= 0) {
                        // Land and start hovering
                        bundle.position.y = landingHeight;
                        bundle.userData.isFlying = false;
                        bundle.userData.hoverTime = 0;
                        bundle.userData.isCollectable = true; // Now collectable
                    }
                } else {
                    // Hovering behavior - smooth up and down 1 unit
                    bundle.userData.hoverTime += deltaTime * 2; // Hover frequency
                    const collision = checkCollisions(bundle.position.x, bundle.position.z, bundle.position.y);
                    const baseHoverHeight = collision.groundHeight + bundle.userData.targetGroundHeight;
                    const hoverOffset = Math.sin(bundle.userData.hoverTime) * 0.5; // ±0.5 units (1 unit total range)
                    bundle.position.y = baseHoverHeight + hoverOffset;
                    
                    // Check for player collision if collectable
                    if (bundle.userData.isCollectable && character) {
                        const distanceToPlayer = Math.sqrt(
                            Math.pow(character.position.x - bundle.position.x, 2) + 
                            Math.pow(character.position.z - bundle.position.z, 2)
                        );
                        
                        if (distanceToPlayer <= 1.6875) { // Player collision radius (1.5 * 1.125 = 1.6875)
                            // Player collected the pickup!
                            if (bundle.userData.isAmmoPickup) {
                                collectAmmo(bundle, index);
                            } else {
                                collectCash(bundle, index);
                            }
                        }
                    }
                }
                
                // Update shadow position and size based on cash bundle height
                if (bundle.userData.shadowPlane) {
                    const collision = checkCollisions(bundle.position.x, bundle.position.z, bundle.position.y);
                    const shadowGroundHeight = collision.groundHeight + 0.01; // Same height as player shadow
                    
                    // Position shadow at cash bundle's X, Z coordinates but at ground level
                    bundle.userData.shadowPlane.position.set(bundle.position.x, shadowGroundHeight, bundle.position.z);
                    
                    // Scale shadow based on height: smaller when higher, bigger when lower (doubled scale factor)
                    const heightAboveGround = bundle.position.y - collision.groundHeight;
                    const maxHeight = 10; // Maximum expected height for scaling
                    const minScale = 0.25; // Minimum shadow size (25% of original) - doubled scale factor
                    const maxScale = 2.0; // Maximum shadow size (200% of original) - doubled scale factor
                    
                    // Inverse relationship: higher = smaller shadow, lower = bigger shadow
                    const heightRatio = Math.min(heightAboveGround / maxHeight, 1.0); // 0 to 1
                    const shadowScale = maxScale - (heightRatio * (maxScale - minScale)); // 2.0 to 0.25
                    
                    bundle.userData.shadowPlane.scale.setScalar(shadowScale);
                }
                
                // Gentle Y-axis rotation (always)
                bundle.rotation.y += bundle.userData.rotationSpeed * deltaTime;
            });
        }
        
        function collectHealthPack(pack, packIndex) {
            // Spawn green particle burst (same as cash)
            spawnGreenParticles(pack.position.x, pack.position.y, pack.position.z);
            
            // Restore player's health to full
            playerHealth = 100;
            updateHealthBar();
            
            // Trigger green screen flash effect (same as cash)
            triggerScreenFlash();
            
            // Remove shadow plane from scene
            if (pack.userData.shadowPlane) {
                scene.remove(pack.userData.shadowPlane);
            }
            
            // Remove health pack from scene and array
            scene.remove(pack);
            healthPacks.splice(packIndex, 1);
        }

        function collectAmmo(pickup, pickupIndex) {
            const weapon = WEAPONS[pickup.userData.weaponType];
            const ammoAdded = Math.min(pickup.userData.ammoAmount, weapon.maxAmmo - weapon.currentAmmo);

            if (ammoAdded > 0) {
                weapon.currentAmmo += ammoAdded;
                updateWeaponUI();

                // Spawn yellow particle burst
                spawnYellowWhiteParticleBurst(pickup.position.x, pickup.position.y, pickup.position.z, 30);

                // Remove pickup
                scene.remove(pickup);
                cashBundles.splice(pickupIndex, 1);
            }
        }

        function collectCash(bundle, bundleIndex) {
            // Spawn green particle burst
            spawnGreenParticles(bundle.position.x, bundle.position.y, bundle.position.z);
            
            // Update money display with scaling animation
            updateMoneyDisplay(100);
            
            // Trigger screen flash effect
            triggerScreenFlash();
            
            // Remove shadow plane from scene
            if (bundle.userData.shadowPlane) {
                scene.remove(bundle.userData.shadowPlane);
            }
            
            // Remove cash bundle from scene and array
            scene.remove(bundle);
            cashBundles.splice(bundleIndex, 1);
        }
        
        function spawnGreenParticles(x, y, z) {
            const particleCount = 40; // 2x as dense (was 20, now 40)
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Create small green cube particle
                const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                
                // Random green color from green to near-white
                const greenIntensity = 0.5 + Math.random() * 0.5; // 0.5 to 1.0
                const redBlue = greenIntensity * 0.8 + Math.random() * 0.2; // Add some white tint
                const particleColor = new THREE.Color(redBlue, 1.0, redBlue); // Green with white tint
                
                const particleMaterial = new THREE.MeshLambertMaterial({ color: particleColor });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position at cash location
                particle.position.set(x, y, z);
                
                // Random velocity in all directions
                const speed = 3 + Math.random() * 2; // 3-5 units/sec
                const angle = Math.random() * Math.PI * 2;
                const elevation = Math.random() * Math.PI - Math.PI/2; // -90 to +90 degrees
                
                particle.userData = {
                    isParticle: true,
                    velocity: {
                        x: Math.cos(angle) * Math.cos(elevation) * speed,
                        y: Math.sin(elevation) * speed,
                        z: Math.sin(angle) * Math.cos(elevation) * speed
                    },
                    life: 1.0, // 1 second lifetime
                    maxLife: 1.0,
                    baseScale: 1.0, // Base scale for fluctuation
                    scaleTime: Math.random() * Math.PI * 2, // Random starting phase for scale animation
                    flickerTime: Math.random() * Math.PI * 2 // Random starting phase for color flicker
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Store particles for cleanup
            if (!window.gameParticles) window.gameParticles = [];
            window.gameParticles.push(...particles);
        }

        function updateCashDisplay() {
            const moneyText = document.getElementById('moneyText');
            if (moneyText) {
                moneyText.textContent = '$' + playerCash;
            }
        }

        function updateMoneyDisplay(amount) {
            playerCash += amount;
            updateCashDisplay();
            triggerMoneyScaleAnimation();
        }
        
        
        function showWeaponSwitchFeedback() {
            // Create or get the weapon switch feedback
            let weaponFeedback = document.getElementById('weaponSwitchFeedback');
            if (!weaponFeedback) {
                weaponFeedback = document.createElement('div');
                weaponFeedback.id = 'weaponSwitchFeedback';
                weaponFeedback.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    font-family: 'Denk One', cursive;
                    font-size: 32px;
                    font-weight: bold;
                    padding: 20px 40px;
                    border-radius: 10px;
                    border: 2px solid white;
                    text-align: center;
                    z-index: 9999;
                    opacity: 0;
                    transition: opacity 0.2s ease-out;
                    pointer-events: none;
                    text-shadow: 
                        -1px -1px 0 black,
                        1px -1px 0 black,
                        -1px 1px 0 black,
                        1px 1px 0 black;
                `;
                document.body.appendChild(weaponFeedback);
            }
            
            // Update text and show
            weaponFeedback.textContent = `${currentWeapon.toUpperCase()} SELECTED`;
            weaponFeedback.style.opacity = '1';
            
            // Hide after 1 second
            setTimeout(() => {
                weaponFeedback.style.opacity = '0';
            }, 1000);
        }
        
        
        function triggerScreenFlash() {
            // Create or get the screen flash overlay
            let flashOverlay = document.getElementById('screenFlash');
            if (!flashOverlay) {
                flashOverlay = document.createElement('div');
                flashOverlay.id = 'screenFlash';
                flashOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 255, 0, 0.65);
                    pointer-events: none;
                    z-index: 9999;
                    opacity: 0;
                    transition: opacity 0.15s ease-out;
                `;
                document.body.appendChild(flashOverlay);
            }
            
            // Trigger the flash animation
            flashOverlay.style.opacity = '1';
            setTimeout(() => {
                flashOverlay.style.opacity = '0';
            }, 150); // Flash for 150ms then fade out
        }
        
        function triggerMoneyScaleAnimation() {
            const moneyText = document.getElementById('moneyText');
            if (!moneyText) return;
            
            // Remove any existing animation class
            moneyText.classList.remove('money-scale-animation');
            
            // Force reflow to ensure class removal takes effect
            moneyText.offsetHeight;
            
            // Add animation class
            moneyText.classList.add('money-scale-animation');
            
            // Remove animation class after animation completes
            setTimeout(() => {
                moneyText.classList.remove('money-scale-animation');
            }, 300); // Match animation duration
        }

        function updateHealthBar() {
            const healthBarFill = document.getElementById('healthBarFill');
            if (healthBarFill) {
                const healthPercentage = Math.max(0, Math.min(100, playerHealth));
                healthBarFill.style.width = healthPercentage + '%';
            }
        }

        function updateStarSystem() {
            const filledStars = Math.min(wantedLevel, maxWantedLevel);

            for (let i = 1; i <= 5; i++) {
                const star = document.getElementById(`star${i}`);
                if (star) {
                    star.classList.remove('filled', 'flashing');

                    if (i <= filledStars) {
                        star.classList.add('filled');

                        // If all stars are filled, make them flash
                        if (filledStars === maxWantedLevel) {
                            star.classList.add('flashing');
                        }
                    }
                }
            }
        }

        function setWantedLevelForInfraction(baseLevel) {
            // Check if any police are within 100m of player
            const policeRange = 100;
            let policeNearby = false;

            // Check for police officers on foot
            for (const npc of npcCharacters) {
                if (npc.userData.isPoliceOfficer) {
                    const distance = Math.sqrt(
                        Math.pow(character.position.x - npc.position.x, 2) +
                        Math.pow(character.position.z - npc.position.z, 2)
                    );
                    if (distance <= policeRange) {
                        policeNearby = true;
                        break;
                    }
                }
            }

            // Check for police cars if no officers found yet
            if (!policeNearby) {
                for (const car of carObjects) {
                    if (car.userData.isPolice) {
                        const distance = Math.sqrt(
                            Math.pow(character.position.x - car.position.x, 2) +
                            Math.pow(character.position.z - car.position.z, 2)
                        );
                        if (distance <= policeRange) {
                            policeNearby = true;
                            break;
                        }
                    }
                }
            }

            // Set wanted level: +1 if police nearby, otherwise base level
            const targetLevel = policeNearby ? baseLevel + 1 : baseLevel;
            wantedLevel = Math.max(wantedLevel, targetLevel);
            updateStarSystem();
        }

        // Quest System Functions
        function initializeQuestSystem() {
            console.log('Quest system initialized - quest givers will be created with NPCs');

            const firstQuest = getCurrentChainQuest();
            if (firstQuest && firstQuest.intro_dialog) {
                const introDialogs = firstQuest.intro_dialog || generateQuestIntroDialog(firstQuest);

                showDialog({
                    lines: introDialogs,
                    transparentBackground: !firstQuest.dialog_solid_background,
                    onComplete: () => {
                        startQuest(firstQuest);
                        console.log('Auto-started first quest:', firstQuest.title);
                    }
                });
            } else if (firstQuest) {
                startQuest(firstQuest);
                console.log('Auto-started first quest:', firstQuest.title);
            }
        }

        function generateRandomQuest() {
            const availableQuestTypes = [];

            if (npcCharacters.length > 0) {
                availableQuestTypes.push('kill_npc');
            }
            if (carObjects.length > 0) {
                availableQuestTypes.push('steal_car');
            }
            if (cashBundles.length > 0) {
                availableQuestTypes.push('collect_cash');
            }

            availableQuestTypes.push('deliver_item');
            availableQuestTypes.push('reach_location');

            if (availableQuestTypes.length === 0) {
                return null;
            }

            const questType = availableQuestTypes[Math.floor(Math.random() * availableQuestTypes.length)];
            let quest = null;
            
            switch (questType) {
                case 'kill_npc':
                    // Find a random NPC to target
                    if (npcCharacters.length > 0) {
                        const targetNPC = npcCharacters[Math.floor(Math.random() * npcCharacters.length)];
                        // Decide reward type - sometimes give weapons for kill quests
                        let reward = { type: 'money', amount: 500 };
                        if (!ownedWeapons.has('uzi') && Math.random() < 0.4) {
                            reward = { type: 'weapon', weaponKey: 'uzi', name: 'Uzi' };
                        } else if (!ownedWeapons.has('rocketLauncher') && Math.random() < 0.2) {
                            reward = { type: 'weapon', weaponKey: 'rocketLauncher', name: 'Rocket Launcher' };
                        }

                        quest = {
                            type: 'kill_npc',
                            title: 'Eliminate Target',
                            description: 'Take out the marked NPC',
                            target: {
                                type: 'npc',
                                npc: targetNPC,
                                x: targetNPC.position.x,
                                z: targetNPC.position.z
                            },
                            reward: reward,
                            completed: false
                        };
                    }
                    break;
                    
                case 'deliver_item':
                    // Generate a random location within the world bounds
                    const worldSize = getWorldSize();
                    const deliveryX = (Math.random() - 0.5) * worldSize * 0.8; // Within 80% of world bounds
                    const deliveryZ = (Math.random() - 0.5) * worldSize * 0.8;
                    quest = {
                        type: 'deliver_item',
                        title: 'Package Delivery',
                        description: `Deliver the package to the marked location`,
                        target: {
                            type: 'location',
                            x: deliveryX,
                            z: deliveryZ
                        },
                        completed: false
                    };
                    break;
                    
                case 'steal_car':
                    // Find a random car to steal
                    if (carObjects.length > 0) {
                        const targetCar = carObjects[Math.floor(Math.random() * carObjects.length)];
                        quest = {
                            type: 'steal_car',
                            title: 'Grand Theft Auto',
                            description: 'Steal the marked vehicle',
                            target: {
                                type: 'car',
                                car: targetCar,
                                x: targetCar.position.x,
                                z: targetCar.position.z
                            },
                            completed: false
                        };
                    }
                    break;
                    
                case 'reach_location':
                    // Generate a random location within the world bounds
                    const worldSize2 = getWorldSize();
                    const targetX = (Math.random() - 0.5) * worldSize2 * 0.8; // Within 80% of world bounds
                    const targetZ = (Math.random() - 0.5) * worldSize2 * 0.8;
                    quest = {
                        type: 'reach_location',
                        title: 'Reconnaissance',
                        description: `Reach the marked location`,
                        target: {
                            type: 'location',
                            x: targetX,
                            z: targetZ
                        },
                        completed: false
                    };
                    break;
                    
                case 'collect_cash':
                    // Spawn cash bundles and target them
                    if (cashBundles.length > 0) {
                        const targetCash = cashBundles[Math.floor(Math.random() * cashBundles.length)];
                        quest = {
                            type: 'collect_cash',
                            title: 'Money Grab',
                            description: 'Collect the marked cash bundle',
                            target: {
                                type: 'cash',
                                cash: targetCash,
                                x: targetCash.position.x,
                                z: targetCash.position.z
                            },
                            completed: false
                        };
                    }
                    break;
            }
            
            return quest;
        }

        function checkQuestObjective(deltaTime) {
            if (!currentQuest || !currentQuest.objective) return;

            const objective = currentQuest.objective;

            if (!questChainProgress.objectiveProgress[currentQuest.id]) {
                questChainProgress.objectiveProgress[currentQuest.id] = {};
            }
            const progress = questChainProgress.objectiveProgress[currentQuest.id];

            switch(objective.type) {
                case 'TALK':
                    if (!progress.targetSpawned) {
                        const spawnDistance = getDistanceToLocation(objective.targetLocation);
                        if (spawnDistance < 50) {
                            const targetName = currentQuest.giverName || objective.targetName || "Quest NPC";
                            spawnQuestTargetNPC(targetName, objective.targetLocation);
                            progress.targetSpawned = true;
                            progress.targetNPC = targetName;
                        }
                    }

                    // For TALK quests, completion is now handled by clicking the ! icon
                    // The icon is shown/hidden and positioned in the animation loop
                    break;

                case 'DELIVER_ITEM':
                    if (!hasItemInInventory(objective.item)) {
                        // Pick up phase
                        const pickupDistance = getDistanceToLocation(objective.fromLocation);
                        if (pickupDistance < 10) {
                            addItemToInventory(objective.item);
                            showNotification(`Picked up: ${objective.item}`);
                            const questDescription = document.getElementById('questDescription');
                            if (questDescription) {
                                questDescription.textContent = `Deliver ${objective.item} to ${objective.toLocation}`;
                            }
                        }
                    } else {
                        // Delivery phase - spawn NPC at delivery location
                        if (!progress.deliveryTargetSpawned) {
                            const spawnDistance = getDistanceToLocation(objective.toLocation);
                            if (spawnDistance < 50) {
                                const nextQuest = getNextQuestInChain();
                                const targetName = nextQuest ? nextQuest.giverName : "Quest NPC";
                                spawnQuestTargetNPC(targetName, objective.toLocation);
                                progress.deliveryTargetSpawned = true;
                            }
                        }

                        // For DELIVER_ITEM quests, completion is now handled by clicking the ! icon
                        // The icon is shown/hidden and positioned in the animation loop
                    }
                    break;

                case 'STEAL_CAR':
                    if (!progress.questCarSpawned) {
                        const carSpawnDistance = getDistanceToLocation(objective.fromLocation);
                        if (carSpawnDistance < 50) {
                            const carLocation = getOrCreateLocation(objective.fromLocation);

                            // Use direction and movingDirection from location if available, otherwise defaults
                            const direction = carLocation.direction || 'x';
                            const movingDirection = carLocation.movingDirection !== undefined ? carLocation.movingDirection : 0;
                            const questCar = createCar(carLocation.x, carLocation.z, direction, movingDirection);

                            questCar.userData.isQuestCar = true;
                            questCar.userData.questId = currentQuest.id;
                            questCar.userData.state = 'stopped';
                            questCar.userData.speed = 0;
                            questCar.userData.velocity = { x: 0, z: 0 };
                            questCar.userData.movingDirection = movingDirection;
                            questCar.userData.angularVelocity = 0;
                            questCar.userData.carId = `quest_car_${currentQuest.id}`;

                            // Use rotation from location if available, otherwise default to 0
                            questCar.rotation.y = carLocation.rotation !== undefined ? carLocation.rotation : 0;

                            questCar.traverse(child => {
                                if (child.material) {
                                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                                    materials.forEach(mat => {
                                        if (mat.color) {
                                            mat.color.setHex(0xFFD700);
                                        }
                                    });
                                }
                            });

                            carObjects.push(questCar);
                            progress.questCarSpawned = true;
                            progress.questCar = questCar;
                            console.log(`Spawned quest car at ${objective.fromLocation} (${carLocation.x}, ${carLocation.z})`);
                        }
                    }

                    if (!progress.npcTargetSpawned) {
                        const npcSpawnDistance = getDistanceToLocation(objective.toLocation);
                        if (npcSpawnDistance < 50) {
                            const nextQuest = getNextQuestInChain();
                            const targetName = nextQuest ? nextQuest.giverName : "Quest NPC";
                            spawnQuestTargetNPC(targetName, objective.toLocation);
                            createDeliveryRing(objective.toLocation);
                            progress.npcTargetSpawned = true;
                        }
                    }

                    if (progress.npcTargetSpawned && !progress.dialogShown && gameState === 'driving' && currentCar) {
                        if (currentCar === progress.questCar) {
                            // Check if car is inside the yellow ring (ring location, not NPC location)
                            const deliveryLocation = getOrCreateLocation(objective.toLocation);
                            const ringCenterX = deliveryLocation.x;
                            const ringCenterZ = deliveryLocation.z;

                            const distanceToRing = Math.sqrt(
                                Math.pow(currentCar.position.x - ringCenterX, 2) +
                                Math.pow(currentCar.position.z - ringCenterZ, 2)
                            );

                            if (distanceToRing < 8) {
                                progress.dialogShown = true;

                                const carToRemove = progress.questCar;

                                // Exit car and position player halfway between ring and NPC
                                exitCar();

                                // Calculate position halfway between ring and NPC
                                const npcX = deliveryLocation.npcX !== undefined ? deliveryLocation.npcX : deliveryLocation.x;
                                const npcZ = deliveryLocation.npcZ !== undefined ? deliveryLocation.npcZ : deliveryLocation.z;

                                const midpointX = (ringCenterX + npcX) / 2;
                                const midpointZ = (ringCenterZ + npcZ) / 2;

                                character.position.x = midpointX;
                                character.position.z = midpointZ;

                                // Apply collision height to player at new position
                                applyCollisionHeight(character, midpointX, midpointZ, character.position.y);

                                // Make player face the NPC
                                const angleToNPC = Math.atan2(npcX - midpointX, npcZ - midpointZ);
                                character.rotation.y = angleToNPC;

                                // Destroy the car
                                scene.remove(carToRemove);
                                const carIndex = carObjects.indexOf(carToRemove);
                                if (carIndex > -1) {
                                    carObjects.splice(carIndex, 1);
                                }

                                // Clear and block player input
                                moveForward = false;
                                moveBackward = false;
                                moveLeft = false;
                                moveRight = false;
                                playerInputDisabled = true;

                                // Wait 0.5 seconds before completing quest
                                setTimeout(() => {
                                    completeQuest();
                                }, 500);
                            }
                        }
                    }
                    break;

                case 'BUY':
                    if (!progress.vendorSpawned) {
                        const vendorDistance = getDistanceToLocation(objective.vendorLocation);
                        if (vendorDistance < 50) {
                            const vendorName = objective.vendorName || "Vendor";
                            spawnQuestTargetNPC(vendorName, objective.vendorLocation);
                            progress.vendorSpawned = true;
                        }
                    }

                    if (progress.itemBought && !progress.dialogShown) {
                        progress.dialogShown = true;
                        completeQuest();
                    }
                    break;

                case 'KILL':
                    if (!progress.targetSpawned) {
                        const targetDistance = getDistanceToLocation(objective.targetLocation);
                        if (targetDistance < 50) {
                            spawnQuestTargetNPC(objective.targetName, objective.targetLocation);
                            progress.targetSpawned = true;
                        }
                    }

                    // Handle range-based behavior for quest target NPC based on whenApproached
                    if (progress.targetSpawned && progress.targetNPCObject) {
                        const npc = progress.targetNPCObject;

                        // Don't update behavior for dead/dying NPCs
                        if (!npc.userData.isSliding && !npc.userData.isDead && !npc.userData.isShot && !npc.userData.isFadingOut) {
                            const distanceToNPC = Math.sqrt(
                                Math.pow(character.position.x - npc.position.x, 2) +
                                Math.pow(character.position.z - npc.position.z, 2)
                            );

                            // Check whenApproached behavior
                            if (npc.userData.whenApproached === "aggressive") {
                                // Activate aggression when player gets within 25 units
                                if (distanceToNPC < 25 && !npc.userData.isAggressive) {
                                    npc.userData.isAggressive = true;
                                    npc.userData.isShooting = true;
                                    npc.userData.lastShotTime = Date.now();
                                    npc.userData.shotCount = 0;
                                    console.log(`Quest target "${objective.targetName}" became aggressive!`);
                                }

                                // Deactivate aggression when player escapes beyond 100 units
                                // Note: Only quest targets can deactivate - police NPCs stay aggressive forever
                                if (distanceToNPC > 100 && npc.userData.isAggressive && npc.userData.isQuestTarget) {
                                    npc.userData.isAggressive = false;
                                    npc.userData.isShooting = false;
                                    npc.userData.isReturningToSpawn = true;
                                    console.log(`Quest target "${objective.targetName}" lost aggression (player escaped), returning to spawn`);
                                }
                            }
                            // Could add "flee" behavior here in the future if needed
                        }
                    }

                    if (targetNPCsKilled.has(objective.targetName) && !progress.dialogShown) {
                        progress.dialogShown = true;

                        // Wait 1 second before completing quest
                        setTimeout(() => {
                            completeQuest();
                        }, 1000);
                    }
                    break;
            }

            // Update quest arrow to point to objective location
            updateQuestArrowForChain();
        }

        function updateInventoryUI() {
            // Find or create inventory indicator
            let inventoryIndicator = document.getElementById('inventoryIndicator');
            if (!inventoryIndicator) {
                inventoryIndicator = document.createElement('div');
                inventoryIndicator.id = 'inventoryIndicator';
                inventoryIndicator.style.cssText = `
                    position: absolute;
                    bottom: 250px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 8px 16px;
                    background: rgba(0, 0, 0, 0.8);
                    border: 2px solid rgba(255, 255, 255, 0.4);
                    border-radius: 8px;
                    color: white;
                    font-family: 'Denk One', cursive;
                    font-size: 18px;
                    text-align: center;
                    z-index: 100;
                    pointer-events: none;
                `;
                document.body.appendChild(inventoryIndicator);
            }

            if (inventory.size > 0) {
                inventoryIndicator.style.display = 'block';
                const itemsArray = Array.from(inventory);
                inventoryIndicator.textContent = `Carrying: ${itemsArray.join(', ')}`;
            } else {
                inventoryIndicator.style.display = 'none';
            }
        }

        function spawnQuestTargetNPC(targetName, locationName) {
            const location = getOrCreateLocation(locationName);

            // Use NPC position if available (car drop locations), otherwise use primary position
            const npcX = location.npcX !== undefined ? location.npcX : location.x;
            const npcZ = location.npcZ !== undefined ? location.npcZ : location.z;

            // Get consistent appearance for this named NPC
            const appearance = getOrCreateNPCAppearance(targetName);

            // Create a special NPC at the location
            const targetNPC = createCharacter(npcX, npcZ, false, appearance);
            targetNPC.userData.isQuestTarget = true;
            targetNPC.userData.targetName = targetName;
            targetNPC.userData.questTargetId = `quest_target_${Date.now()}`;

            // Store spawn location for returning after aggression
            targetNPC.userData.spawnX = npcX;
            targetNPC.userData.spawnZ = npcZ;
            targetNPC.userData.isReturningToSpawn = false;

            // Set behavior based on quest type
            targetNPC.userData.whenIdle = "stationary";
            targetNPC.userData.whenApproached = "none";

            if (currentQuest && currentQuest.objective) {
                if (currentQuest.objective.type === 'KILL') {
                    // KILL quest targets are aggressive
                    targetNPC.userData.whenScared = "aggressive";
                    targetNPC.userData.whenApproached = "aggressive";
                } else {
                    // TALK/DELIVER_ITEM/BUY quest targets flee when scared
                    targetNPC.userData.whenScared = "flee";
                }
            } else {
                // Default: flee when scared
                targetNPC.userData.whenScared = "flee";
            }

            // Position at correct height
            applyCollisionHeight(targetNPC, npcX, npcZ, targetNPC.position.y);

            npcCharacters.push(targetNPC);

            // Store reference to quest target NPC for TALK, DELIVER_ITEM, BUY, and KILL quests
            if (currentQuest && currentQuest.objective) {
                const objType = currentQuest.objective.type;
                if (objType === 'TALK' || objType === 'DELIVER_ITEM' || objType === 'BUY' || objType === 'KILL') {
                    if (!questChainProgress.objectiveProgress[currentQuest.id]) {
                        questChainProgress.objectiveProgress[currentQuest.id] = {};
                    }
                    questChainProgress.objectiveProgress[currentQuest.id].targetNPCObject = targetNPC;

                    // For BUY quests, set up vendor data
                    if (objType === 'BUY') {
                        targetNPC.userData.vendorType = 'quest';
                        targetNPC.userData.vendorId = targetNPC.userData.questTargetId;
                    }
                }
            }

            console.log(`Spawned quest target "${targetName}" at ${locationName} (${npcX.toFixed(1)}, ${npcZ.toFixed(1)})`);
        }

        function createDeliveryRing(locationName) {
            // Remove existing ring if present
            removeDeliveryRing();

            // Get the delivery location
            const location = getOrCreateLocation(locationName);
            if (!location || location.x === undefined || location.z === undefined) {
                console.warn(`Cannot create delivery ring: invalid location ${locationName}`);
                return;
            }

            // Create a glowing yellow ring using TorusGeometry
            const ringGeometry = new THREE.TorusGeometry(8, 0.5, 16, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 1,
                transparent: true,
                opacity: 0.8
            });

            deliveryRingMesh = new THREE.Mesh(ringGeometry, ringMaterial);
            deliveryRingMesh.position.set(location.x, 0.2, location.z);
            deliveryRingMesh.rotation.x = Math.PI / 2; // Rotate to be flat on ground

            scene.add(deliveryRingMesh);
            console.log(`Created delivery ring at ${locationName} (${location.x.toFixed(1)}, ${location.z.toFixed(1)})`);
        }

        function removeDeliveryRing() {
            if (deliveryRingMesh) {
                scene.remove(deliveryRingMesh);
                deliveryRingMesh.geometry.dispose();
                deliveryRingMesh.material.dispose();
                deliveryRingMesh = null;
            }
        }

        function updateQuestArrowForChain() {
            if (!currentQuest || !currentQuest.objective || !character) return;

            const objective = currentQuest.objective;
            let targetLocation = null;

            // Determine target location based on objective type and phase
            switch(objective.type) {
                case 'TALK':
                    targetLocation = getOrCreateLocation(objective.targetLocation);
                    break;
                case 'DELIVER_ITEM':
                    if (!hasItemInInventory(objective.item)) {
                        targetLocation = getOrCreateLocation(objective.fromLocation);
                    } else {
                        targetLocation = getOrCreateLocation(objective.toLocation);
                    }
                    break;
                case 'STEAL_CAR':
                    const progress = questChainProgress.objectiveProgress[currentQuest.id];
                    const hasQuestCar = gameState === 'driving' && currentCar && progress && currentCar === progress.questCar;

                    if (!hasQuestCar) {
                        targetLocation = getOrCreateLocation(objective.fromLocation);
                    } else {
                        targetLocation = getOrCreateLocation(objective.toLocation);
                    }
                    break;
                case 'BUY':
                    targetLocation = getOrCreateLocation(objective.vendorLocation);
                    break;
                case 'KILL':
                    targetLocation = getOrCreateLocation(objective.targetLocation);
                    break;
            }

            // Update arrow rotation and distance if we have a target location
            if (targetLocation && targetLocation.x !== undefined && targetLocation.z !== undefined) {
                // Call the original updateQuestArrow with coordinates
                updateQuestArrow(targetLocation.x, targetLocation.z);
            }
        }

        function startQuest(quest) {
            if (!quest) return;

            // Pre-generate all locations needed for this quest with proper distance constraints
            // IMPORTANT: Do this BEFORE setting currentQuest to prevent game loop from creating locations without constraints
            if (quest.objective) {
                const objective = quest.objective;
                const distanceOptions = {
                    minDistance: objective.minDistance,
                    maxDistance: objective.maxDistance
                };

                switch (objective.type) {
                    case 'TALK':
                        // Generate target location for talking
                        if (objective.targetLocation && !namedLocations[objective.targetLocation]) {
                            getOrCreateLocation(objective.targetLocation, distanceOptions);
                        }
                        break;

                    case 'DELIVER_ITEM':
                        // Generate delivery destination
                        if (objective.toLocation && !namedLocations[objective.toLocation]) {
                            getOrCreateLocation(objective.toLocation, distanceOptions);
                        }
                        break;

                    case 'STEAL_CAR':
                        // Generate car location
                        if (objective.fromLocation && !namedLocations[objective.fromLocation]) {
                            getOrCreateLocation(objective.fromLocation, distanceOptions);
                        }
                        // Generate drop-off location relative to car location
                        if (objective.toLocation && !namedLocations[objective.toLocation]) {
                            const carLocation = getOrCreateLocation(objective.fromLocation);
                            getOrCreateLocation(objective.toLocation, {
                                fromLocation: carLocation,
                                minDistance: 200,
                                maxDistance: objective.maxDistance
                            });
                        }
                        break;

                    case 'BUY':
                        // Generate vendor location
                        if (objective.vendorLocation && !namedLocations[objective.vendorLocation]) {
                            getOrCreateLocation(objective.vendorLocation, distanceOptions);
                        }
                        break;

                    case 'KILL':
                        // Generate target location
                        if (objective.targetLocation && !namedLocations[objective.targetLocation]) {
                            getOrCreateLocation(objective.targetLocation, distanceOptions);
                        }
                        break;
                }
            }

            // Set currentQuest AFTER pre-generating locations to avoid race condition
            currentQuest = quest;

            // Update UI
            const questContainer = document.getElementById('questContainer');
            const questTitle = document.getElementById('questTitle');
            const questDescription = document.getElementById('questDescription');
            const questArrow = document.getElementById('questArrow');
            
            questContainer.style.display = 'block';
            questTitle.textContent = quest.title || 'Unknown Quest';

            // Use quest's description if available, otherwise use objective description
            const description = quest.description ||
                               (quest.objective && quest.objective.description) ||
                               'Complete the objective';
            questDescription.textContent = description;
            
            // Show quest arrow
            if (questArrow) {
                questArrow.style.display = 'block';
            }
            
            // Show quest distance text
            const questDistanceText = document.getElementById('questDistanceText');
            if (questDistanceText) {
                questDistanceText.style.display = 'block';
            }
            
            // Create target circle
            createQuestTargetCircle();

            // Initialize quest arrow to point to the objective
            updateQuestArrowForChain();

            console.log(`Started quest: ${quest.title}`);
        }

        function createQuestTargetCircle() {
            // Remove existing circle
            if (questTargetCircle) {
                document.body.removeChild(questTargetCircle);
                questTargetCircle = null;
            }
            
            if (!currentQuest || !currentQuest.target) return;
            
            // Create visual circle element
            questTargetCircle = document.createElement('div');
            questTargetCircle.className = 'quest-target-circle';
            questTargetCircle.style.width = '100px';
            questTargetCircle.style.height = '100px';
            questTargetCircle.style.left = '0px';
            questTargetCircle.style.top = '0px';
            
            document.body.appendChild(questTargetCircle);
        }

        function updateQuestTargetCircle() {
            if (!questTargetCircle || !currentQuest || !currentQuest.target) return;
            
            // Get target world position
            let targetX, targetZ;
            
            if (currentQuest.target.type === 'npc' && currentQuest.target.npc) {
                targetX = currentQuest.target.npc.position.x;
                targetZ = currentQuest.target.npc.position.z;
            } else if (currentQuest.target.type === 'car' && currentQuest.target.car) {
                targetX = currentQuest.target.car.position.x;
                targetZ = currentQuest.target.car.position.z;
            } else if (currentQuest.target.type === 'cash' && currentQuest.target.cash) {
                targetX = currentQuest.target.cash.position.x;
                targetZ = currentQuest.target.cash.position.z;
            } else {
                targetX = currentQuest.target.x;
                targetZ = currentQuest.target.z;
            }
            
            // Convert world position to screen position
            const targetVector = new THREE.Vector3(targetX, 2, targetZ);
            targetVector.project(camera);
            
            // Convert to screen coordinates
            const screenX = (targetVector.x * 0.5 + 0.5) * 720;
            const screenY = (targetVector.y * -0.5 + 0.5) * 1280;
            
            // Update circle position
            questTargetCircle.style.left = (screenX - 50) + 'px';
            questTargetCircle.style.top = (screenY - 50) + 'px';
            
            // Hide circle if target is behind camera or too far
            if (targetVector.z > 1) {
                questTargetCircle.style.display = 'none';
            } else {
                questTargetCircle.style.display = 'block';
            }
            
            // Update quest arrow rotation
            updateQuestArrow(targetX, targetZ);
        }

        function updateQuestArrow(targetX, targetZ) {
            const questArrow = document.getElementById('questArrow');
            if (!questArrow || !currentQuest || !character) return;
            
            // Get player position
            const playerX = gameState === 'driving' && currentCar ? currentCar.position.x : character.position.x;
            const playerZ = gameState === 'driving' && currentCar ? currentCar.position.z : character.position.z;
            
            // Calculate direction from player to target in world space
            const deltaX = targetX - playerX;
            const deltaZ = targetZ - playerZ;
            
            // Calculate distance between player and target
            const distance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);
            
            // Calculate angle in world space (atan2 gives angle from -π to π)
            // In world space: +Z is north, +X is east
            const worldAngleRadians = Math.atan2(deltaX, deltaZ);
            
            // Convert to camera/screen space angle
            // The camera looks down the Z-axis with 180-degree rotation applied to minimap
            // So we need to adjust for the camera's orientation and reverse the direction
            const cameraAngleRadians = -worldAngleRadians - Math.PI/2; // Negate the angle and subtract 90 degrees
            
            // Convert to degrees
            const angleDegrees = cameraAngleRadians * (180 / Math.PI);
            
            // Apply rotation to arrow (rotate around center) - create proper arrow shape
            questArrow.style.transform = `translateY(-50%) rotate(${angleDegrees}deg)`;
            
            // Create or update distance text element immediately to the left of the arrow
            let distanceText = document.getElementById('questDistanceText');
            if (!distanceText) {
                distanceText = document.createElement('div');
                distanceText.id = 'questDistanceText';
                distanceText.style.cssText = `
                    position: absolute;
                    right: 32px;
                    top: 50%;
                    transform: translateY(-50%);
                    color: #FFD700;
                    font-family: 'Denk One', cursive;
                    font-size: 14px;
                    font-weight: bold;
                    text-shadow: 
                        -1px -1px 0 black,
                        1px -1px 0 black,
                        -1px 1px 0 black,
                        1px 1px 0 black;
                    pointer-events: none;
                `;
                
                // Add to quest container
                const questContainer = document.getElementById('questContainer');
                if (questContainer) {
                    questContainer.appendChild(distanceText);
                }
            }
            
            // Update distance text - round to whole number meters
            if (distanceText) {
                distanceText.textContent = Math.round(distance) + 'm';
            }
            
            // Update quest description (remove distance from here since it's now separate)
            const questDescription = document.getElementById('questDescription');
            if (questDescription && currentQuest) {
                const baseDescription = currentQuest.description ||
                                       (currentQuest.objective && currentQuest.objective.description) ||
                                       'Complete the objective';
                questDescription.textContent = baseDescription;
            }
        }

        function updateWorldArrow() {
            // Remove the world arrow functionality completely
            const worldArrow = document.getElementById('worldArrow');
            if (worldArrow) {
                worldArrow.style.display = 'none';
            }
        }

        function checkQuestProgress() {
            if (!currentQuest || currentQuest.completed) return;
            
            const playerX = gameState === 'driving' && currentCar ? currentCar.position.x : character.position.x;
            const playerZ = gameState === 'driving' && currentCar ? currentCar.position.z : character.position.z;
            
            switch (currentQuest.type) {
                case 'kill_npc':
                    // Check if target NPC still exists
                    if (currentQuest.target.npc && !npcCharacters.includes(currentQuest.target.npc)) {
                        completeQuest();
                    }
                    break;
                    
                case 'deliver_item':
                case 'reach_location':
                    // Check if player is within range of target location
                    const distanceToTarget = Math.sqrt(
                        Math.pow(playerX - currentQuest.target.x, 2) + 
                        Math.pow(playerZ - currentQuest.target.z, 2)
                    );
                    if (distanceToTarget <= 10) {
                        completeQuest();
                    }
                    break;
                    
                case 'steal_car':
                    // Check if player is driving the target car
                    if (gameState === 'driving' && currentCar === currentQuest.target.car) {
                        completeQuest();
                    }
                    break;
                    
                case 'collect_cash':
                    // Check if target cash still exists
                    if (currentQuest.target.cash && !cashBundles.includes(currentQuest.target.cash)) {
                        completeQuest();
                    }
                    break;
            }
        }

        function completeQuest() {
            if (!currentQuest) return;

            currentQuest.completed = true;

            // Award rewards
            if (currentQuest.reward) {
                // Award cash if present
                if (currentQuest.reward.cash) {
                    updateMoneyDisplay(currentQuest.reward.cash);
                    console.log(`Quest completed: ${currentQuest.title} - Awarded $${currentQuest.reward.cash}`);
                }

                // Award weapon if present
                if (currentQuest.reward.weapon) {
                    acquireWeapon(currentQuest.reward.weapon);
                    console.log(`Quest completed: ${currentQuest.title} - Awarded ${WEAPONS[currentQuest.reward.weapon]?.name || currentQuest.reward.weapon}`);
                }

                // Legacy support for old reward format
                if (currentQuest.reward.type === 'weapon') {
                    acquireWeapon(currentQuest.reward.weaponKey);
                    console.log(`Quest completed: ${currentQuest.title} - Awarded ${currentQuest.reward.name}`);
                } else if (currentQuest.reward.amount) {
                    updateMoneyDisplay(currentQuest.reward.amount);
                    console.log(`Quest completed: ${currentQuest.title} - Awarded $${currentQuest.reward.amount}`);
                }
            } else {
                // Default reward if not specified
                updateMoneyDisplay(500);
                console.log(`Quest completed: ${currentQuest.title} - Awarded $500`);
            }

            // Track quest completion in chain progress
            if (currentQuest.id) {
                questChainProgress.completedQuests.push(currentQuest.id);
                questChainProgress.currentIndex++;

                // Check if there's a next quest in the chain
                const nextQuest = getCurrentChainQuest();
                const shouldAutoStart = currentQuest.autostart_next;

                if (nextQuest && shouldAutoStart) {
                    // Skip quest complete toast and go straight to next quest
                    if (nextQuest.intro_dialog) {
                        showDialog({
                            lines: nextQuest.intro_dialog,
                            transparentBackground: !nextQuest.dialog_solid_background,
                            onComplete: () => {
                                startQuest(nextQuest);
                                showNotification(`New Quest: ${nextQuest.title}`);
                            }
                        });
                    } else {
                        startQuest(nextQuest);
                        showNotification(`New Quest: ${nextQuest.title}`);
                    }
                } else {
                    // Show quest complete toast when not auto-starting next quest
                    showQuestCompleteToast();

                    // If there's a next quest but not auto-starting, delay showing it
                    if (nextQuest && !shouldAutoStart) {
                        setTimeout(() => {
                            if (nextQuest.intro_dialog) {
                                showDialog({
                                    lines: nextQuest.intro_dialog,
                                    transparentBackground: !nextQuest.dialog_solid_background,
                                    onComplete: () => {
                                        // Quest won't auto-start, player must accept it manually
                                    }
                                });
                            }
                        }, 3300);
                    }
                }
            } else {
                // No quest chain, just show completion toast
                showQuestCompleteToast();
            }

            // Hide quest UI
            const questContainer = document.getElementById('questContainer');
            const questArrow = document.getElementById('questArrow');
            const questDistanceText = document.getElementById('questDistanceText');
            questContainer.style.display = 'none';
            
            // Hide quest arrow
            if (questArrow) {
                questArrow.style.display = 'none';
            }
            
            // Hide quest distance text
            if (questDistanceText) {
                questDistanceText.style.display = 'none';
            }
            
            // Remove target circle
            if (questTargetCircle) {
                document.body.removeChild(questTargetCircle);
                questTargetCircle = null;
            }

            // Remove delivery ring for STEAL_CAR quests
            removeDeliveryRing();

            // Hide world arrow
            const worldArrow = document.getElementById('worldArrow');
            if (worldArrow) {
                worldArrow.style.display = 'none';
            }

            // Clean up quest target icon if it exists and mark NPC for cleanup
            if (currentQuest && currentQuest.id && questChainProgress.objectiveProgress[currentQuest.id]) {
                const progress = questChainProgress.objectiveProgress[currentQuest.id];
                if (progress.targetNPCObject) {
                    const questTargetIcon = document.getElementById(`questTargetIcon_${progress.targetNPCObject.userData.questTargetId}`);
                    if (questTargetIcon) {
                        questTargetIcon.remove();
                    }

                    // Add target NPC to cleanup list (will be removed when player moves >20 units away)
                    completedQuestTargetNPCs.push(progress.targetNPCObject);
                }
            }

            // Clear current quest
            currentQuest = null;

            // Re-enable player input
            playerInputDisabled = false;
        }

        function cleanupCompletedQuestNPCs() {
            // Remove completed quest target NPCs when player moves >20 units away
            completedQuestTargetNPCs = completedQuestTargetNPCs.filter(npc => {
                const distance = Math.sqrt(
                    Math.pow(character.position.x - npc.position.x, 2) +
                    Math.pow(character.position.z - npc.position.z, 2)
                );

                if (distance > 20) {
                    // Remove NPC from scene
                    scene.remove(npc);

                    // Clean up any remaining icon
                    if (npc.userData.questTargetId) {
                        const questTargetIcon = document.getElementById(`questTargetIcon_${npc.userData.questTargetId}`);
                        if (questTargetIcon) {
                            questTargetIcon.remove();
                        }
                    }

                    // Return false to remove from array
                    return false;
                }

                // Return true to keep in array
                return true;
            });
        }

        function showQuestCompleteToast() {
            // Create or get the quest complete toast
            let questToast = document.getElementById('questCompleteToast');
            if (!questToast) {
                questToast = document.createElement('div');
                questToast.id = 'questCompleteToast';
                questToast.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: #FFD700;
                    font-family: 'Denk One', cursive;
                    font-size: 48px;
                    font-weight: bold;
                    padding: 30px 60px;
                    border-radius: 20px;
                    border: 4px solid #FFD700;
                    text-align: center;
                    z-index: 10000;
                    opacity: 0;
                    transition: opacity 0.3s ease-out;
                    pointer-events: none;
                    text-shadow: 
                        -2px -2px 0 black,
                        2px -2px 0 black,
                        -2px 2px 0 black,
                        2px 2px 0 black;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                `;
                questToast.textContent = 'QUEST COMPLETE';
                document.body.appendChild(questToast);
            }
            
            // Show the toast with fade in
            questToast.style.opacity = '1';
            
            // Hide after 3 seconds
            setTimeout(() => {
                questToast.style.opacity = '0';
                // Remove from DOM after fade completes
                setTimeout(() => {
                    if (questToast.parentNode) {
                        questToast.parentNode.removeChild(questToast);
                    }
                }, 300);
            }, 3000);
        }

        function checkForQuestStart() {
            const playerX = character.position.x;
            const playerZ = character.position.z;

            // Check for active quest target NPC and show ! icon
            if (currentQuest && currentQuest.objective) {
                const progress = questChainProgress.objectiveProgress[currentQuest.id];
                const objType = currentQuest.objective.type;

                // Show icon for TALK quests when target is spawned
                if (objType === 'TALK' && progress && progress.targetSpawned && progress.targetNPCObject && !progress.dialogShown) {
                    showQuestTargetIcon(progress.targetNPCObject);
                }

                // Show icon for DELIVER_ITEM quests when carrying item and target is spawned
                if (objType === 'DELIVER_ITEM' && hasItemInInventory(currentQuest.objective.item) && progress && progress.deliveryTargetSpawned && progress.targetNPCObject && !progress.dialogShown) {
                    showQuestTargetIcon(progress.targetNPCObject);
                }

                // Show icon for BUY quests when vendor is spawned
                if (objType === 'BUY' && progress && progress.vendorSpawned && progress.targetNPCObject && !progress.itemBought) {
                    showQuestTargetIcon(progress.targetNPCObject);
                }
            }

            // Don't show quest giver icons if a quest is already active
            if (currentQuest) return;

            // Check all quest giver NPCs and always show icons when on screen
            questGivers.forEach(questGiver => {
                if (!questGiver.userData.hasQuest || questGiver.userData.questOffered) return;

                // Always show quest giver icon when on screen (regardless of distance)
                showQuestGiverIcon(questGiver);
            });
        }

        function damagePlayer(damage) {
            playerHealth -= damage;
            playerHealth = Math.max(0, playerHealth); // Don't go below 0
            updateHealthBar();

            // Handle player death when health reaches 0
            if (playerHealth <= 0) {
                // If player is flying, defer death until they land
                if (character.userData.isFlying) {
                    character.userData.shouldDieOnLanding = true;
                } else {
                    console.log('Player died! Game over.');
                    handlePlayerDeath();
                }
            }
        }
        
        function handlePlayerDeath() {
            // Disable player input
            playerInputDisabled = true;

            // Start death rotation animation (rotate to horizontal over 0.5 seconds)
            character.userData.deathRotationProgress = 0;
            character.userData.deathRotationDuration = 0.5;
            character.userData.initialRotationX = character.rotation.x;
            character.userData.targetRotationX = -Math.PI / 2; // 90 degrees forward (horizontal)

            // Reset all NPCs to non-aggressive state
            [...npcCharacters, ...vendorNPCs, ...questGivers].forEach(npc => {
                if (npc.userData.isAggressive) {
                    npc.userData.isAggressive = false;
                    npc.userData.isShooting = false;
                    npc.userData.isScared = false;
                    npc.userData.scaredAnimationTime = 0;
                    npc.userData.lastShotTime = 0;
                    npc.userData.shotCount = 0;
                }
            });

            // Show game over screen
            showGameOverScreen();

            // Stop all game sounds
            stopAmbientAudio();
        }
        
        function showGameOverScreen() {
            // Create game over overlay
            let gameOverOverlay = document.getElementById('gameOverOverlay');
            if (!gameOverOverlay) {
                gameOverOverlay = document.createElement('div');
                gameOverOverlay.id = 'gameOverOverlay';
                gameOverOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.9);
                    z-index: 10001;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    opacity: 0;
                    transition: opacity 1s ease-out;
                `;
                
                // Game Over text
                const gameOverText = document.createElement('div');
                gameOverText.style.cssText = `
                    font-family: 'Denk One', cursive;
                    font-size: 72px;
                    color: #FF0000;
                    text-align: center;
                    margin-bottom: 30px;
                    text-shadow: 
                        -3px -3px 0 black,
                        3px -3px 0 black,
                        -3px 3px 0 black,
                        3px 3px 0 black;
                `;
                gameOverText.textContent = 'YOU DIED';
                gameOverOverlay.appendChild(gameOverText);
                
                // Restart button
                const restartButton = document.createElement('button');
                restartButton.style.cssText = `
                    font-family: 'Denk One', cursive;
                    font-size: 32px;
                    color: white;
                    background: rgba(255, 0, 0, 0.8);
                    border: 3px solid white;
                    border-radius: 15px;
                    padding: 15px 30px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-shadow: 
                        -2px -2px 0 black,
                        2px -2px 0 black,
                        -2px 2px 0 black,
                        2px 2px 0 black;
                `;
                restartButton.textContent = 'RESPAWN';
                
                restartButton.addEventListener('click', () => {
                    restartGame();
                });
                
                restartButton.addEventListener('mouseenter', () => {
                    restartButton.style.background = 'rgba(255, 255, 255, 0.2)';
                    restartButton.style.transform = 'scale(1.1)';
                });
                
                restartButton.addEventListener('mouseleave', () => {
                    restartButton.style.background = 'rgba(255, 0, 0, 0.8)';
                    restartButton.style.transform = 'scale(1)';
                });
                
                gameOverOverlay.appendChild(restartButton);
                document.body.appendChild(gameOverOverlay);
            }
            
            // Show the overlay with fade in
            setTimeout(() => {
                gameOverOverlay.style.opacity = '1';
            }, 100);
        }
        
        function restartGame() {
            // Reset player health
            playerHealth = 100;
            updateHealthBar();

            // Reset player position
            character.position.x = CHARACTER_SPAWN_X;
            character.position.z = CHARACTER_SPAWN_Z;
            const collision = checkCollisions(character.position.x, character.position.z, character.position.y);
            character.position.y = collision.stepUpHeight;
            character.userData.groundHeight = collision.groundHeight;

            // Reset player physics state (flying, velocity, etc.)
            character.userData.isFlying = false;
            character.userData.onGround = true;
            character.userData.bounceCount = 0;
            character.userData.hasKickbackVelocity = false;
            character.userData.shouldDieOnLanding = false;
            if (character.userData.velocity) {
                character.userData.velocity.x = 0;
                character.userData.velocity.y = 0;
                character.userData.velocity.z = 0;
            }

            // Reset player rotation to upright position
            character.rotation.x = 0;
            character.rotation.z = 0;
            // Keep rotation.y (facing direction) as is

            // Ensure player is visible
            character.visible = true;
            if (shadowPlane) {
                shadowPlane.visible = true;
            }

            // Reset game state
            gameState = 'walking';
            currentCar = null;
            
            // Reset scared NPC count and stars
            wantedLevel = 0;
            updateStarSystem();

            // Reset all NPCs to non-aggressive state
            [...npcCharacters, ...vendorNPCs, ...questGivers].forEach(npc => {
                if (npc.userData.isAggressive) {
                    npc.userData.isAggressive = false;
                    npc.userData.isShooting = false;
                    npc.userData.isScared = false;
                    npc.userData.scaredAnimationTime = 0;
                    npc.userData.lastShotTime = 0;
                    npc.userData.shotCount = 0;
                }
            });

            // Re-enable player input
            playerInputDisabled = false;
            
            // Restart background music
            startAmbientAudio();
            
            // Remove game over overlay
            const gameOverOverlay = document.getElementById('gameOverOverlay');
            if (gameOverOverlay) {
                gameOverOverlay.style.opacity = '0';
                setTimeout(() => {
                    if (gameOverOverlay.parentNode) {
                        gameOverOverlay.parentNode.removeChild(gameOverOverlay);
                    }
                }, 1000);
            }
            
            console.log('Player respawned - health restored and position reset');
        }

        function handleIntersection(car) {
            const nav = car.userData.navigation;
            const currentSeg = window.roadNetwork.segments[nav.segment];
            const currentNode = window.roadNetwork.nodes[nav.targetNode];

            const exitSegIds = currentNode.segments.filter(segId => segId !== nav.segment);

            if (exitSegIds.length === 0) {
                nav.targetNode = getOtherNode(currentSeg, nav.targetNode);
                nav.direction *= -1;
                nav.progress = Math.max(0, Math.min(1, nav.progress));
                return;
            }

            const entryAngle = getExitAngle(currentSeg, currentNode.id);
            const nextSeg = chooseNextSegment(exitSegIds, entryAngle, currentNode, car);

            nav.segment = nextSeg.id;
            nav.targetNode = getOtherNode(nextSeg, currentNode.id);
            nav.direction = getSegmentDirection(nextSeg, nav.targetNode);
        }

        function chooseNextSegment(exitSegIds, entryAngle, currentNode, car) {
            const exitSegs = exitSegIds.map(id => window.roadNetwork.segments[id]);

            // Police chase behavior at 4-5 stars: navigate toward player
            const isPoliceChasing = car.userData.isPolice && wantedLevel >= 4 && character;

            if (isPoliceChasing) {
                // Calculate angle from current position to player
                const toPlayerX = character.position.x - car.position.x;
                const toPlayerZ = character.position.z - car.position.z;
                const angleToPlayer = Math.atan2(toPlayerX, toPlayerZ);

                // Find exit segment that best points toward player
                let bestSeg = null;
                let minAngleDiff = Infinity;

                for (let seg of exitSegs) {
                    const exitAngle = getExitAngle(seg, currentNode.id);
                    const angleDiff = Math.abs(normalizeAngle(exitAngle - angleToPlayer));

                    if (angleDiff < minAngleDiff) {
                        bestSeg = seg;
                        minAngleDiff = angleDiff;
                    }
                }

                if (bestSeg) return bestSeg;
            }

            // Civilian behavior (or police at low wanted levels): mostly go straight with occasional turns
            const TURN_PROBABILITY = 0.40; // 40% chance to turn

            const targetAngle = entryAngle + Math.PI;

            let straight = null;
            let minAngleDiff = Infinity;

            for (let seg of exitSegs) {
                const exitAngle = getExitAngle(seg, currentNode.id);
                const angleDiff = Math.abs(normalizeAngle(exitAngle - targetAngle));

                if (angleDiff < 0.5 && angleDiff < minAngleDiff) {
                    straight = seg;
                    minAngleDiff = angleDiff;
                }
            }

            if (Math.random() >= TURN_PROBABILITY && straight) {
                return straight;
            }

            return exitSegs[Math.floor(Math.random() * exitSegs.length)];
        }

        function updateCarNavigation(car, deltaTime) {
            const nav = car.userData.navigation;
            if (!nav) return;

            // Check if player is aiming/firing gun nearby
            let shouldStop = false;
            if (character && (gunState === 'firing' || gunState === 'holding' || gunAnimationProgress >= 0.95)) {
                const playerDistance = Math.sqrt(
                    Math.pow(character.position.x - car.position.x, 2) +
                    Math.pow(character.position.z - car.position.z, 2)
                );
                shouldStop = playerDistance <= 12;
            }

            // Check if player is in front of the car (only when not in a car)
            let playerInFront = false;
            if (character && gameState !== 'driving' && car.userData.state !== 'stopped') {
                // Calculate car's forward direction based on rotation
                const forwardX = Math.sin(car.rotation.y);
                const forwardZ = Math.cos(car.rotation.y);

                // Calculate perpendicular direction (right side of car)
                const perpX = -forwardZ;
                const perpZ = forwardX;

                // Calculate front bumper position (car length is ~13 units)
                const carLength = 13;
                const bumperX = car.position.x + forwardX * (carLength / 2);
                const bumperZ = car.position.z + forwardZ * (carLength / 2);

                // Calculate vector from front bumper to player
                const toPlayerX = character.position.x - bumperX;
                const toPlayerZ = character.position.z - bumperZ;

                // Project player position onto car's forward axis (forward distance)
                const forwardDistance = forwardX * toPlayerX + forwardZ * toPlayerZ;

                // Project player position onto car's perpendicular axis (lateral distance)
                const lateralDistance = Math.abs(perpX * toPlayerX + perpZ * toPlayerZ);

                // Car width is ~5 units, detect within half width on each side
                const carHalfWidth = 2.5;
                const maxForwardDistance = 15;

                // Player is in front if:
                // 1. In front of bumper (forwardDistance > 0)
                // 2. Within forward detection range (forwardDistance <= 15)
                // 3. Within car width laterally (lateralDistance <= carHalfWidth)
                if (forwardDistance > 0 && forwardDistance <= maxForwardDistance && lateralDistance <= carHalfWidth) {
                    playerInFront = true;
                }
            }

            // Handle gun-related stop (spawns carjack NPC, permanent stop)
            if (shouldStop && car.userData.state === 'normal') {
                car.userData.state = 'stopped';
                car.userData.stopAnimationProgress = 0;
                car.userData.originalSpeed = car.userData.speed || car.userData.moveSpeed || 24;
                spawnCarjackNPC(car);

                // Raise wanted level based on car type
                // Police car: min 3 stars, civilian car: min 1 star
                if (car.userData.isPolice) {
                    setWantedLevelForInfraction(2); // 2, but it will always be near a police, so 3
                } else {
                    setWantedLevelForInfraction(1);
                }
            }

            if (car.userData.state === 'stopped') {
                car.userData.stopAnimationProgress = Math.min(1, car.userData.stopAnimationProgress + deltaTime * 3);
            }

            // Handle player-in-front stop (temporary, resumes when clear)
            if (playerInFront) {
                if (!car.userData.stoppedForPlayer) {
                    car.userData.stoppedForPlayer = true;
                    car.userData.playerStopProgress = 0;
                }
                car.userData.playerStopProgress = Math.min(1, car.userData.playerStopProgress + deltaTime * 5);
            } else if (car.userData.stoppedForPlayer) {
                // Player moved out of the way, resume
                car.userData.playerStopProgress = Math.max(0, car.userData.playerStopProgress - deltaTime * 3);
                if (car.userData.playerStopProgress <= 0) {
                    car.userData.stoppedForPlayer = false;
                }
            }

            let speed;
            if (car.userData.state === 'stopped') {
                // Permanent stop (gun-related)
                const easedProgress = 1 - Math.pow(1 - car.userData.stopAnimationProgress, 3);
                speed = (car.userData.originalSpeed || 24) * (1 - easedProgress);
            } else if (car.userData.stoppedForPlayer) {
                // Temporary stop (player in front)
                const baseSpeed = car.userData.speed || car.userData.moveSpeed || 24;
                const easedProgress = 1 - Math.pow(1 - car.userData.playerStopProgress, 3);
                speed = baseSpeed * (1 - easedProgress * 0.95); // Reduce to 5% of normal speed
            } else {
                speed = car.userData.speed || car.userData.moveSpeed || 24;
            }

            const oldX = car.position.x;
            const oldZ = car.position.z;

            if (nav.inIntersection) {
                const dx = nav.intersectionExit.x - nav.intersectionEntry.x;
                const dz = nav.intersectionExit.z - nav.intersectionEntry.z;
                const intersectionDistance = Math.sqrt(dx * dx + dz * dz);

                const progressDelta = (speed * deltaTime) / intersectionDistance;
                nav.intersectionProgress += progressDelta;

                if (nav.intersectionProgress >= 1.0) {
                    nav.inIntersection = false;
                    nav.intersectionProgress = 0;
                    nav.progress = nav.direction > 0 ? 0 : 1;

                    car.position.x = nav.intersectionExit.x;
                    car.position.z = nav.intersectionExit.z;

                    const seg = window.roadNetwork.segments[nav.segment];
                    const targetRotation = nav.direction > 0
                        ? seg.angle
                        : (seg.angle + Math.PI);
                    car.rotation.y = targetRotation;

                } else {
                    nav.intersectionProgress = Math.max(0, Math.min(1, nav.intersectionProgress));

                    const pos = evaluateCubicBezier(
                        nav.bezierP0,
                        nav.bezierP1,
                        nav.bezierP2,
                        nav.bezierP3,
                        nav.intersectionProgress
                    );
                    car.position.x = pos.x;
                    car.position.z = pos.z;

                    const tangent = evaluateCubicBezierTangent(
                        nav.bezierP0,
                        nav.bezierP1,
                        nav.bezierP2,
                        nav.bezierP3,
                        nav.intersectionProgress
                    );
                    car.rotation.y = Math.atan2(tangent.x, tangent.z);
                }

            } else {
                const seg = window.roadNetwork.segments[nav.segment];
                const progressDelta = (speed * deltaTime / seg.roadLength) * nav.direction;
                nav.progress += progressDelta;

                if (nav.progress >= 1.0 || nav.progress <= 0.0) {
                    const laneShift = nav.direction * nav.laneOffset;
                    nav.intersectionEntry = {
                        x: seg.roadEnd.x + seg.perpendicular.x * laneShift,
                        z: seg.roadEnd.z + seg.perpendicular.z * laneShift
                    };

                    if (nav.progress < 0.0) {
                        nav.intersectionEntry = {
                            x: seg.roadStart.x + seg.perpendicular.x * laneShift,
                            z: seg.roadStart.z + seg.perpendicular.z * laneShift
                        };
                    }

                    nav.entryRotation = car.rotation.y;

                    const entryDirX = Math.sin(car.rotation.y);
                    const entryDirZ = Math.cos(car.rotation.y);

                    handleIntersection(car);

                    const nextSeg = window.roadNetwork.segments[nav.segment];
                    const nextLaneShift = nav.direction * nav.laneOffset;

                    if (nav.direction > 0) {
                        nav.intersectionExit = {
                            x: nextSeg.roadStart.x + nextSeg.perpendicular.x * nextLaneShift,
                            z: nextSeg.roadStart.z + nextSeg.perpendicular.z * nextLaneShift
                        };
                    } else {
                        nav.intersectionExit = {
                            x: nextSeg.roadEnd.x + nextSeg.perpendicular.x * nextLaneShift,
                            z: nextSeg.roadEnd.z + nextSeg.perpendicular.z * nextLaneShift
                        };
                    }

                    const exitDirX = nav.direction * nextSeg.direction.x;
                    const exitDirZ = nav.direction * nextSeg.direction.z;

                    const dx = nav.intersectionExit.x - nav.intersectionEntry.x;
                    const dz = nav.intersectionExit.z - nav.intersectionEntry.z;
                    const straightDistance = Math.sqrt(dx * dx + dz * dz);
                    const controlDistance = straightDistance / 3;

                    nav.bezierP0 = nav.intersectionEntry;
                    nav.bezierP1 = {
                        x: nav.intersectionEntry.x + entryDirX * controlDistance,
                        z: nav.intersectionEntry.z + entryDirZ * controlDistance
                    };
                    nav.bezierP2 = {
                        x: nav.intersectionExit.x - exitDirX * controlDistance,
                        z: nav.intersectionExit.z - exitDirZ * controlDistance
                    };
                    nav.bezierP3 = nav.intersectionExit;

                    nav.inIntersection = true;
                    nav.intersectionProgress = 0;
                    nav.progress = 0;

                    car.position.x = nav.intersectionEntry.x;
                    car.position.z = nav.intersectionEntry.z;
                    car.rotation.y = nav.entryRotation;

                } else {
                    nav.progress = Math.max(0, Math.min(1, nav.progress));

                    const centerX = seg.roadStart.x + seg.direction.x * seg.roadLength * nav.progress;
                    const centerZ = seg.roadStart.z + seg.direction.z * seg.roadLength * nav.progress;

                    const laneShift = nav.direction * nav.laneOffset;
                    car.position.x = centerX + seg.perpendicular.x * laneShift;
                    car.position.z = centerZ + seg.perpendicular.z * laneShift;

                    const baseRotation = seg.angle;
                    car.rotation.y = nav.direction > 0 ? baseRotation : baseRotation + Math.PI;

                    car.rotation.y = normalizeAngle(car.rotation.y);
                }
            }

            car.userData.angularVelocity = 0;

            car.userData.velocity = {
                x: (car.position.x - oldX) / deltaTime,
                z: (car.position.z - oldZ) / deltaTime
            };
        }

        function updatePoliceCarLights(car) {
            // Animate police light bar if this is a police car
            if (car.userData.isPolice && car.userData.lightBar) {
                const time = (performance.now() + car.userData.lightBar.animationOffset) / 1000; // Convert to seconds with offset
                const phase = Math.floor(time * 2) % 2; // Toggle every 0.5 seconds

                if (phase === 0) {
                    // Red bright, blue dark
                    car.userData.lightBar.redMaterial.color.set(0xFF2222);
                    car.userData.lightBar.blueMaterial.color.set(0x000022);

                    // Animate glow planes
                    if (car.userData.lightBar.redGlowPlane) {
                        car.userData.lightBar.redGlowPlane.material.opacity = 1.0;
//                        car.userData.lightBar.redGlowPlane.scale.set(1.2, 1.2, 1);
                    }
                    if (car.userData.lightBar.blueGlowPlane) {
                        car.userData.lightBar.blueGlowPlane.material.opacity = 0.2;
//                        car.userData.lightBar.blueGlowPlane.scale.set(0.8, 0.8, 1);
                    }
                } else {
                    // Red dark, blue bright
                    car.userData.lightBar.redMaterial.color.set(0x220000);
                    car.userData.lightBar.blueMaterial.color.set(0x2222FF);

                    // Animate glow planes
                    if (car.userData.lightBar.redGlowPlane) {
                        car.userData.lightBar.redGlowPlane.material.opacity = 0.2;
//                        car.userData.lightBar.redGlowPlane.scale.set(0.8, 0.8, 1);
                    }
                    if (car.userData.lightBar.blueGlowPlane) {
                        car.userData.lightBar.blueGlowPlane.material.opacity = 1.0;
//                        car.userData.lightBar.blueGlowPlane.scale.set(1.2, 1.2, 1);
                    }
                }
            }
        }

        function updateCarMovement(car, deltaTime) {
            if (!car.userData.isCar) return;

            // Handle physics for destroyed cars (flying parts)
            if (car.userData.isDestroyed) {
                // Keep car parts forever - no cleanup

                // Update flying car body
                if (car.userData.upperBody && car.userData.upperBody.userData.isFlying) {
                    const body = car.userData.upperBody;
                    if (body.userData.velocity) {
                        // Apply gravity
                        body.userData.velocity.y -= 15 * deltaTime;

                        // Update position
                        body.position.x += body.userData.velocity.x * deltaTime;
                        body.position.y += body.userData.velocity.y * deltaTime;
                        body.position.z += body.userData.velocity.z * deltaTime;

                        // Rotate while flying
                        body.rotation.x += deltaTime * 2;
                        body.rotation.z += deltaTime * 3;

                        // Stop when hits ground
                        if (body.position.y <= 2.0) {
                            body.position.y = 2.0;
                            body.userData.isFlying = false;
                            body.userData.velocity = null;
                        }
                    }
                }

                // Update flying tires
                if (car.userData.tires) {
                    car.userData.tires.forEach(tire => {
                        if (tire.userData.isFlying && tire.userData.velocity) {
                            // Apply gravity
                            tire.userData.velocity.y -= 20 * deltaTime;

                            // Update position
                            tire.position.x += tire.userData.velocity.x * deltaTime;
                            tire.position.y += tire.userData.velocity.y * deltaTime;
                            tire.position.z += tire.userData.velocity.z * deltaTime;

                            // Spin tire
                            if (tire.userData.angularVelocity) {
                                tire.rotation.x += tire.userData.angularVelocity * deltaTime;
                            }

                            // Stop when hits ground
                            if (tire.position.y <= 0.5) {
                                tire.position.y = 0.5;
                                tire.userData.isFlying = false;
                                tire.userData.velocity = null;
                                tire.userData.angularVelocity = 0;
                            }
                        }
                    });
                }

                return; // Skip normal car movement for destroyed cars
            }
            
            // Skip AI movement if player is controlling this car, but still apply jittering and physics
            if (car.userData.isPlayerControlled) {
                // Handle physics mode for player-controlled car (must happen even when player is controlling)
                if (car.userData.inPhysicsMode) {
                    updateCarPhysics(car, deltaTime);
                }

                // Apply jittering animation to upper and lower cubes (in unison) - cars always jitter even when carjacked
                // 1.25x bigger jitter: was ±0.1 units, now ±0.125 units
                car.userData.bounceTime += deltaTime * 6; // Jitter frequency
                const bounceOffset = (Math.random() - 0.5) * 0.125; // 1.25x bigger jitter (±0.125 units)

                // Apply jitter ON TOP of the raised positions (2.0 and 5.0) - cars always jitter
                car.userData.lowerBody.position.y = 2.0 + bounceOffset; // Base raised position + jitter
                car.userData.upperBody.position.y = 5.0 + bounceOffset; // Base raised position + jitter

                // Tires do NOT jitter - they stay at their original ground-level positions
                car.userData.tires.forEach(tire => {
                    tire.position.y = 0.5; // Keep tires at ground level (unchanged)
                });

                // Car shadows removed - no shadow positioning needed

                // Animate police light bar
                updatePoliceCarLights(car);

                return; // Skip AI movement logic but jittering and physics are applied
            }
            
            // Initialize car state if not present
            if (car.userData.state === undefined) {
                car.userData.state = 'normal'; // normal, stopped, carjacked
                car.userData.originalSpeed = car.userData.moveSpeed;
                car.userData.stopAnimationProgress = 0;
            }
            
            if (car.userData.navigation) {
                updateCarNavigation(car, deltaTime);
            }

            // Police deployment check: at 3+ stars, police cars within 50m stop and deploy officer
            if (car.userData.isPolice && !car.userData.hasSpawnedOfficer && !car.userData.isStoppedForDeploy &&
                wantedLevel >= 3 && character && car.userData.navigation) {
                const distanceToPlayer = Math.sqrt(
                    Math.pow(character.position.x - car.position.x, 2) +
                    Math.pow(character.position.z - car.position.z, 2)
                );

                if (distanceToPlayer <= 50) {
                    // Stop the car
                    car.userData.isStoppedForDeploy = true;
                    car.userData.hasSpawnedOfficer = true;
                    car.userData.state = 'stopped'; // Mark as stopped so player can enter
                    car.userData.navigation = null; // Stop navigation

                    // Spawn aggressive police officer
                    const offsetX = 3; // Spawn to the side of car
                    const officerX = car.position.x + offsetX;
                    const officerZ = car.position.z;

                    const officer = createCharacter(officerX, officerZ, false, null, true);
                    officer.userData.isPoliceOfficer = true;
                    officer.userData.whenScared = "aggressive";
                    officer.userData.whenApproached = "none";
                    officer.userData.isAggressive = true;
                    officer.userData.isShooting = true;
                    officer.userData.shootingStartTime = Date.now();
                    officer.userData.lastShotTime = 0;
                    officer.userData.whenIdle = "stationary";

                    officer.position.y = 0.6; // Ground level
                    scene.add(officer);
                    npcCharacters.push(officer);
                }
            }

            // Cleanup stopped police cars when player is far away (>200m)
            if (car.userData.isStoppedForDeploy) {
                const distanceToPlayer = Math.sqrt(
                    Math.pow(character.position.x - car.position.x, 2) +
                    Math.pow(character.position.z - car.position.z, 2)
                );

                if (distanceToPlayer > 200) {
                    // Remove car from scene
                    scene.remove(car);
                    if (car.userData.shadowPlane) {
                        scene.remove(car.userData.shadowPlane);
                    }
                    // Mark for removal from array (will be handled by filter below)
                    car.userData.shouldRemove = true;
                }

                // Skip all other car updates for stopped deploy cars (just jitter and lights below)
                // Continue to jittering section
            }

            // Skip movement and collision logic for stopped police cars
            if (car.userData.isStoppedForDeploy) {
                // Check if player can enter this stopped car
                if (character && currentMode === 'play' && !character.userData.isInCar) {
                    const distToPlayer = Math.sqrt(
                        Math.pow(character.position.x - car.position.x, 2) +
                        Math.pow(character.position.z - car.position.z, 2)
                    );

                    if (distToPlayer <= 3.95 && gameState === 'walking') {
                        // Car is stopped - player enters the car
                        handleCarEntry(car, character);
                    }
                }

                // Apply jittering animation (cars still jitter when stopped)
                car.userData.bounceTime += deltaTime * 6;
                const bounceOffset = (Math.random() - 0.5) * 0.125;
                car.userData.lowerBody.position.y = 2.0 + bounceOffset;
                car.userData.upperBody.position.y = 5.0 + bounceOffset;
                car.userData.tires.forEach(tire => {
                    tire.position.y = 0.5;
                });
                if (car.userData.shadowPlane) {
                    car.userData.shadowPlane.position.y = 0.01;
                }
                // Animate police lights
                updatePoliceCarLights(car);
                return; // Skip all other car logic
            }

            // Check for collision with player (only if player is not in a car)
            if (character && currentMode === 'play' && !character.userData.isInCar) {
                const distanceToPlayer = Math.sqrt(
                    Math.pow(character.position.x - car.position.x, 2) + 
                    Math.pow(character.position.z - car.position.z, 2)
                );
                
                // Car collision radius: 7 units wide, so 3.5 unit radius
                // Player collision radius: 0.9 units wide, so 0.45 unit radius
                // Total collision distance: 3.5 + 0.45 = 3.95 units
                if (distanceToPlayer <= 3.95 && gameState === 'walking') {
                    if (car.userData.state === 'stopped') {
                        // Car is stopped - player enters the car
                        handleCarEntry(car, character);
                    } else if (car.userData.state === 'normal') {
                        // Car is moving - collision damage
                        handleCarPlayerCollision(car, character);
                    }
                }
            }
            
            // Handle physics mode for cars affected by collisions
            if (car.userData.inPhysicsMode) {
                updateCarPhysics(car, deltaTime);
            }

            // Check building collisions for ALL cars (not just player car)
            // Only check for moving cars (with navigation and speed) or cars in physics mode
            if (car.userData.inPhysicsMode || (car.userData.navigation && car.userData.speed && car.userData.speed > 2)) {
                checkCarBuildingCollisionsForAllCars(car);
            }

            // Check car-to-car collisions for ALL cars (not just player car)
            if (car.userData.inPhysicsMode || (car.userData.navigation && car.userData.speed && car.userData.speed > 2)) {
                checkCarToCarCollisionsForAllCars(car);
            }

            // Add jittering animation to upper and lower cubes (in unison) - cars always jitter even when stopped
            // 1.25x bigger jitter: was ±0.1 units, now ±0.125 units
            car.userData.bounceTime += deltaTime * 6; // Jitter frequency
            const bounceOffset = (Math.random() - 0.5) * 0.125; // 1.25x bigger jitter (±0.125 units)
            
            // Apply jitter ON TOP of the raised positions (2.0 and 5.0) - cars always jitter
            car.userData.lowerBody.position.y = 2.0 + bounceOffset; // Base raised position + jitter
            car.userData.upperBody.position.y = 5.0 + bounceOffset; // Base raised position + jitter
            
            // Tires do NOT jitter - they stay at their original ground-level positions
            car.userData.tires.forEach(tire => {
                tire.position.y = 0.5; // Keep tires at ground level (unchanged)
            });

            // Update car shadow position (shadow stays at ground level, doesn't jitter)
            if (car.userData.shadowPlane) {
                car.userData.shadowPlane.position.y = 0.01; // Keep shadow at specified Y position
            }

            // Animate police light bar
            updatePoliceCarLights(car);
        }
        
        function handleCarPlayerCollision(car, player) {
            // Check if car is stopped or stopping for player
            const isCarStopped = car.userData.state === 'stopped' || car.userData.stoppedForPlayer;

            // If car is stopped or stopping, just push player gently to the side
            if (isCarStopped) {
                // Calculate direction to push player (perpendicular to car's forward direction)
                const carForwardX = Math.sin(car.rotation.y);
                const carForwardZ = Math.cos(car.rotation.y);

                // Calculate which side of the car the player is on
                const toPlayerX = player.position.x - car.position.x;
                const toPlayerZ = player.position.z - car.position.z;

                // Cross product to determine side (positive = right, negative = left)
                const crossProduct = carForwardX * toPlayerZ - carForwardZ * toPlayerX;
                const pushDirection = crossProduct > 0 ? 1 : -1;

                // Push player to the side perpendicular to car's direction
                const pushForceX = -carForwardZ * pushDirection * 2; // Perpendicular to forward
                const pushForceZ = carForwardX * pushDirection * 2;

                // Apply gentle push (no flying, no damage)
                player.position.x += pushForceX * 0.1;
                player.position.z += pushForceZ * 0.1;

                return; // Don't throw or damage player
            }

            // Car is moving fast - throw player and cause damage
            // Calculate car's actual movement direction based on rotation and speed
            let carSpeed = 0;

            // Get car speed from either physics mode or normal movement
            if (car.userData.inPhysicsMode && car.userData.velocity) {
                // Car in physics mode - use velocity magnitude
                carSpeed = Math.sqrt(
                    car.userData.velocity.x * car.userData.velocity.x +
                    car.userData.velocity.z * car.userData.velocity.z
                );
            } else {
                // Normal car - use speed property
                carSpeed = car.userData.speed || car.userData.moveSpeed || 0;
            }

            // Calculate movement direction based on car's rotation
            const carForwardX = Math.sin(car.rotation.y);
            const carForwardZ = Math.cos(car.rotation.y);

            // Apply 2x force to player in same direction as car is facing
            const throwForceX = carForwardX * carSpeed * 2;
            const throwForceZ = carForwardZ * carSpeed * 2;
            const throwForceY = 15; // High upward force

            // Initialize player physics if not present
            if (!player.userData.velocity) {
                player.userData.velocity = { x: 0, y: 0, z: 0 };
            }

            // Apply throwing forces
            player.userData.velocity.x = throwForceX;
            player.userData.velocity.y = throwForceY;
            player.userData.velocity.z = throwForceZ;
            player.userData.onGround = false;
            player.userData.isFlying = true;
            player.userData.bounceCount = 0; // Reset bounce count for new collision

            // Damage player by 30%
            damagePlayer(30);

            // Trigger red screen flash
            triggerRedScreenFlash();

            // Spawn dense red and maroon particle burst at collision point
            spawnRedParticleBurst(player.position.x, player.position.y, player.position.z);
        }
        
                function handleCarEntry(car, player) {
            // Player enters the car

            // Set game state to car mode (use global variables consistently)
            gameState = 'driving';
            currentCar = car;

            // Hide player character with fade effect
            fadeOutPlayer(player);
            
            // Transfer control to car
            car.userData.isPlayerControlled = true;
            car.userData.state = 'carjacked';

            // Clear any existing interpolation state from before entering
            car.userData.needsInterpolation = false;
            car.userData.originalPosition = undefined;
            car.userData.originalRotation = undefined;
            car.userData.shouldResumeNormalPath = false;
            car.userData.inPhysicsMode = false;

            // Initialize car driving physics
            if (!car.userData.velocity) {
                car.userData.velocity = { x: 0, z: 0 };
            }
            if (!car.userData.speed) {
                car.userData.speed = 0;
            }
            
            // Immediately update camera to follow car
            cameraHorizontalAngle = car.rotation.y + Math.PI; // Initialize camera angle behind car
            
            // Check if this completes a steal car quest
            if (currentQuest && currentQuest.type === 'steal_car' && currentQuest.target.car === car) {
                completeQuest();
            }
        }
        
                function fadeOutPlayer(player) {
            // Start fade out animation
            player.userData.fadeOutProgress = 0;
            player.userData.isFadingOut = true;
            
            // Make sure player is visible to start the fade
            player.visible = true;
            
            // CRITICAL: Ensure player is COMPLETELY INVISIBLE while in car
            // This is to fix the issue where player character remains visible during carjacking
            player.userData.mustBeInvisibleInCar = true;
        }
        
        function updateCameraForCar(car) {
            // Camera will be updated in the main camera update function
            // based on the current car position and orientation
        }
        
        function triggerRedScreenFlash() {
            // Create or get the red screen flash overlay
            let flashOverlay = document.getElementById('redScreenFlash');
            if (!flashOverlay) {
                flashOverlay = document.createElement('div');
                flashOverlay.id = 'redScreenFlash';
                flashOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(255, 0, 0, 0.8);
                    pointer-events: none;
                    z-index: 9999;
                    opacity: 0;
                    transition: opacity 0.2s ease-out;
                `;
                document.body.appendChild(flashOverlay);
            }
            
            // Trigger the flash animation
            flashOverlay.style.opacity = '1';
            setTimeout(() => {
                flashOverlay.style.opacity = '0';
            }, 200); // Flash for 200ms then fade out
        }
        
        function spawnRedParticleBurst(x, y, z) {
            const particleCount = 60; // Dense burst (1.5x more than green particles)
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Create small red/maroon cube particle
                const particleGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15); // Slightly bigger than green particles
                
                // Random red/maroon color
                const redIntensity = 0.7 + Math.random() * 0.3; // 0.7 to 1.0
                const maroonComponent = Math.random() * 0.3; // 0 to 0.3 for maroon tint
                const particleColor = new THREE.Color(redIntensity, maroonComponent, maroonComponent);
                
                const particleMaterial = new THREE.MeshLambertMaterial({ color: particleColor });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position at collision location
                particle.position.set(x, y, z);
                
                // Random velocity in all directions (faster than green particles)
                const speed = 4 + Math.random() * 3; // 4-7 units/sec (faster)
                const angle = Math.random() * Math.PI * 2;
                const elevation = Math.random() * Math.PI - Math.PI/2; // -90 to +90 degrees
                
                particle.userData = {
                    isParticle: true,
                    velocity: {
                        x: Math.cos(angle) * Math.cos(elevation) * speed,
                        y: Math.sin(elevation) * speed,
                        z: Math.sin(angle) * Math.cos(elevation) * speed
                    },
                    life: 1.2, // Slightly longer lifetime than green particles
                    maxLife: 1.2,
                    baseScale: 1.0,
                    scaleTime: Math.random() * Math.PI * 2,
                    flickerTime: Math.random() * Math.PI * 2
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Store particles for cleanup
            if (!window.gameParticles) window.gameParticles = [];
            window.gameParticles.push(...particles);
        }
        
        function spawnProjectile(startX, startY, startZ, directionX, directionZ) {
            const weapon = WEAPONS[currentWeapon];

            // Apply weapon spread
            let finalDirX = directionX;
            let finalDirZ = directionZ;
            if (weapon.spread > 0) {
                const spreadAngle = (Math.random() - 0.5) * weapon.spread;
                const cos = Math.cos(spreadAngle);
                const sin = Math.sin(spreadAngle);
                finalDirX = directionX * cos - directionZ * sin;
                finalDirZ = directionX * sin + directionZ * cos;
            }

            // Create projectile with weapon-specific properties
            const projectileSize = weapon.projectileSize;
            const projectileGeometry = weapon.explosive
                ? new THREE.SphereGeometry(projectileSize, 8, 8)  // Rocket is a sphere
                : new THREE.BoxGeometry(projectileSize, projectileSize, projectileSize);

            // Use MeshBasicMaterial for 100% self-illumination
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: weapon.projectileColor,
                transparent: false,
                opacity: 1.0
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

            // Position at gun tip
            projectile.position.set(startX, startY, startZ);

            // Store projectile data
            projectile.userData = {
                isProjectile: true,
                weaponType: currentWeapon,
                damage: weapon.damage,
                explosive: weapon.explosive || false,
                explosionRadius: weapon.explosionRadius || 0,
                velocity: {
                    x: finalDirX * weapon.projectileSpeed,
                    y: 0,
                    z: finalDirZ * weapon.projectileSpeed
                },
                distanceTraveled: 0,
                maxDistance: weapon.explosive ? 500 : 300,  // Rockets travel further
                smokeTimer: 0  // For rocket smoke trail
            };
            
            scene.add(projectile);
            projectiles.push(projectile);
        }

        function spawnPoliceProjectile(startX, startY, startZ, directionX, directionZ) {
            // Create police projectile - same as player but red color
            const projectileSize = 0.2;
            const projectileGeometry = new THREE.BoxGeometry(projectileSize, projectileSize, projectileSize);
            
            // Use red color for police projectiles
            const projectileMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000, // Bright red
                transparent: false,
                opacity: 1.0
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            
            // Position at police officer's gun position
            projectile.position.set(startX, startY, startZ);
            
            // Store projectile data - mark as police projectile
            projectile.userData = {
                isProjectile: true,
                isPoliceProjectile: true, // Mark as police projectile
                velocity: {
                    x: directionX * 80, // Slightly slower than player (80 vs 100)
                    y: 0,
                    z: directionZ * 80
                },
                distanceTraveled: 0,
                maxDistance: 200 // Shorter range than player (200 vs 300)
            };
            
            scene.add(projectile);
            projectiles.push(projectile);
        }

                // Gun action state machine functions
        function startGunAction(canFire = true) {
            if (gunState === 'idle') {
                gunState = 'raising';
                gunRaised = true;
                buttonPressed = true;
                actionStarted = true;
                gunBounceTriggered = false;
                gunCanFire = canFire; // Track if this action can fire
            }
        }
        
                function endGunAction() {
            buttonPressed = false;
            
            // FOR FIRE BUTTON: If this is a firing action (gunCanFire = true), 
            // the action must complete atomically - do NOT allow interruption
            if (gunCanFire && (gunState === 'raising' || gunState === 'firing')) {
                // Fire button action must complete - do not lower arm yet
                return;
            }
            
            // FOR HOLD UP BUTTON: Always allow immediate lowering when button is released
            if (gunState === 'firing' || gunState === 'holding') {
                gunState = 'lowering';
                gunRaised = false;
            } else if (gunState === 'raising' && !gunCanFire) {
                // Only allow interruption for hold up button (gunCanFire = false)
                gunState = 'lowering';
                gunRaised = false;
            } else if (gunState === 'idle') {
                // Button released but no action was in progress
                gunRaised = false;
            }
        }
        
                function updateGunStateMachine() {
            switch (gunState) {
                case 'idle':
                    // Do nothing, waiting for button press
                    break;
                    
                case 'raising':
                    // Arm is raising, check if fully raised
                    if (gunAnimationProgress >= 0.95) {
                        if (gunCanFire) {
                            gunState = 'firing';
                        } else {
                            gunState = 'holding';
                        }
                    }
                    break;
                    
                case 'firing':
                    // Arm is raised, fire continuously while in this state
                    fireGun();
                    
                    // FOR FIRE BUTTON: Only start lowering when button is released AND we've fired at least once
                    if (!buttonPressed && gunCanFire) {
                        // Fire button was released - complete the atomic action by lowering
                        gunState = 'lowering';
                        gunRaised = false;
                    } else if (!buttonPressed && !gunCanFire) {
                        // Hold up button was released
                        gunState = 'lowering';
                        gunRaised = false;
                    }
                    break;
                    
                case 'holding':
                    // Arm is raised but not firing, just holding up
                    // IMPORTANT: Arm should REMAIN RAISED as long as button is held down
                    // Check if button was released, if so start lowering
                    if (!buttonPressed) {
                        gunState = 'lowering';
                        gunRaised = false;
                    }
                    break;
                    
                case 'lowering':
                    // Arm is lowering, check if fully lowered
                    if (gunAnimationProgress <= 0.05) {
                        gunState = 'idle';
                        actionStarted = false;
                        gunCanFire = true; // Reset for next action
                    }
                    break;
            }
        }

                function fireGun() {
            if (!character) return;

            // Get current weapon data
            const weapon = WEAPONS[currentWeapon];
            if (!weapon) {
                return;
            }

            // Check ammo count for current weapon
            if (weapon.currentAmmo <= 0) {
                return;
            }

            // Check firing rate limit based on current weapon
            const currentTime = Date.now();
            if (currentTime - lastFireTime < weapon.fireRate) {
                return;
            }
            
            // NEW LOGIC: Only fire if arm is FULLY raised (90 degrees)
            if (gunAnimationProgress < 0.95) { // 95% threshold for "fully raised"
                return;
            }
            
            // Update last fire time
            lastFireTime = currentTime;
            
            // Decrement ammo for current weapon
            weapon.currentAmmo--;
            updateWeaponUI();
            
            // Start arm bounce animation (10 degrees up for 0.1s)
            isArmBouncing = true;
            armBounceStartTime = currentTime;
            
            // Apply STRONGER kickback to player (2.5x stronger: was 0.1, now 0.25)
            const kickbackForce = 0.25;
            const kickbackX = -Math.sin(character.userData.facingAngle) * kickbackForce;
            const kickbackZ = -Math.cos(character.userData.facingAngle) * kickbackForce;
            
            // Initialize player physics for kickback if not present
            if (!character.userData.velocity) {
                character.userData.velocity = { x: 0, y: 0, z: 0 };
            }
            
            // Apply kickback as TRUE PHYSICAL FORCE with instant attack and gradual slowdown
            character.userData.velocity.x = kickbackX * 10; // Instant attack: 10x multiplier for immediate force
            character.userData.velocity.z = kickbackZ * 10;
            character.userData.hasKickbackVelocity = true; // Flag to enable gradual slowdown
            
            // Calculate gun tip position at the END OF THE GUN object
            // Gun is held in right hand, extends forward from hand position
            const rightArmPivot = character.userData.rightArmPivot;
            const rightLowerArmPivot = character.userData.rightLowerArmPivot;
            
            // Get world position of the gun tip (end of the dark grey cube in right hand)
            // The gun cube is positioned at (0, -0.975, 0.2125) relative to right lower arm pivot
            // and extends 0.225/2 units further forward, so gun tip is at (0, -0.975, 0.2125 + 0.225/2)
            const gunTipLocalX = 0;
            const gunTipLocalY = -0.975;
            const gunTipLocalZ = 0.2125 + 0.225/2; // End of gun cube
            
            // Transform to world coordinates through the arm hierarchy
            const characterWorldMatrix = character.matrixWorld;
            const rightArmWorldMatrix = rightArmPivot.matrixWorld;
            const rightLowerArmWorldMatrix = rightLowerArmPivot.matrixWorld;
            
            // Create gun tip position vector and transform to world space
            const gunTipWorld = new THREE.Vector3(gunTipLocalX, gunTipLocalY, gunTipLocalZ);
            rightLowerArmPivot.localToWorld(gunTipWorld);
            
            const gunTipX = gunTipWorld.x;
            const gunTipY = gunTipWorld.y;
            const gunTipZ = gunTipWorld.z;
            
            // Calculate gun direction based on character facing and arm orientation
            const projectileDirectionX = Math.sin(character.userData.facingAngle);
            const projectileDirectionZ = Math.cos(character.userData.facingAngle);
            
            // Spawn muzzle flash particles with weapon-specific size
            spawnYellowWhiteParticleBurst(gunTipX, gunTipY, gunTipZ, weapon.muzzleFlashSize);
            
            // Launch bright yellow projectile from gun tip (100% opacity)
            spawnProjectile(gunTipX, gunTipY, gunTipZ, projectileDirectionX, projectileDirectionZ);
        }

        function spawnYellowWhiteParticleBurst(x, y, z, particleCount = 30) {
            const particles = [];
            
            // Transfer player's velocity to particles if player is walking
            let playerVelocityX = 0;
            let playerVelocityZ = 0;
            
            if (character && isMoving) {
                // Calculate player's current velocity based on movement direction and speed
                const moveSpeed = PLAYER_MOVE_SPEED;

                // Get player's facing direction
                const facingAngle = character.userData.facingAngle || 0;

                // Calculate velocity components (same as in updateMovement function)
                playerVelocityX = Math.sin(facingAngle) * moveSpeed;
                playerVelocityZ = Math.cos(facingAngle) * moveSpeed;
            }
            
            for (let i = 0; i < particleCount; i++) {
                // Create small yellow/white cube particle
                const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                
                // Full brightness yellow and white colors with 100% self-illumination
                const yellowIntensity = 1.0; // Full brightness yellow
                const whiteComponent = 1.0; // Full brightness white
                const particleColor = new THREE.Color(yellowIntensity, yellowIntensity, whiteComponent); // Bright yellow with bright white
                
                // Use MeshBasicMaterial for 100% self-illumination (no lighting applied)
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: particleColor,
                    transparent: false, // 100% opacity - no transparency
                    opacity: 1.0 // Full opacity
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position at specified location
                particle.position.set(x, y, z);
                
                // Random velocity in all directions (moderate speed)
                const speed = 3 + Math.random() * 2; // 3-5 units/sec
                const angle = Math.random() * Math.PI * 2;
                const elevation = Math.random() * Math.PI - Math.PI/2; // -90 to +90 degrees
                
                // Base particle velocity
                const baseVelX = Math.cos(angle) * Math.cos(elevation) * speed;
                const baseVelY = Math.sin(elevation) * speed;
                const baseVelZ = Math.sin(angle) * Math.cos(elevation) * speed;
                
                particle.userData = {
                    isParticle: true,
                    velocity: {
                        x: baseVelX + playerVelocityX, // Add player's velocity
                        y: baseVelY,
                        z: baseVelZ + playerVelocityZ  // Add player's velocity
                    },
                    life: 0.5, // 2x lifespan (was 0.25, now 0.5)
                    maxLife: 0.5, // 2x lifespan (was 0.25, now 0.5)
                    baseScale: 1.0,
                    scaleTime: Math.random() * Math.PI * 2,
                    flickerTime: Math.random() * Math.PI * 2,
                    isYellowWhite: true // Mark as yellow/white particle for special handling
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Store particles for cleanup
            if (!window.gameParticles) window.gameParticles = [];
            window.gameParticles.push(...particles);
        }

        function spawnCarSparkParticleBurst(x, y, z, particleCount = 30) {
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Create 2x bigger yellow/white cube particle (2x bigger than original 0.1, now 0.4)
                const particleGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4); // 2x bigger than before (was 0.2, now 0.4)
                
                // Full brightness yellow and white colors with 100% self-illumination
                const yellowIntensity = 1.0; // Full brightness yellow
                const whiteComponent = 1.0; // Full brightness white
                const particleColor = new THREE.Color(yellowIntensity, yellowIntensity, whiteComponent); // Bright yellow with bright white
                
                // Use MeshBasicMaterial for 100% self-illumination (no lighting applied)
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: particleColor,
                    transparent: false, // 100% opacity - no transparency
                    opacity: 1.0 // Full opacity
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position at specified location
                particle.position.set(x, y, z);
                
                // Random velocity in all directions (moderate speed)
                const speed = 3 + Math.random() * 2; // 3-5 units/sec
                const angle = Math.random() * Math.PI * 2;
                const elevation = Math.random() * Math.PI - Math.PI/2; // -90 to +90 degrees
                
                particle.userData = {
                    isParticle: true,
                    velocity: {
                        x: Math.cos(angle) * Math.cos(elevation) * speed,
                        y: Math.sin(elevation) * speed,
                        z: Math.sin(angle) * Math.cos(elevation) * speed
                    },
                    life: 8.0, // 4x longer lifespan than before (was 2.0, now 8.0)
                    maxLife: 8.0, // 4x longer lifespan than before (was 2.0, now 8.0)
                    baseScale: 1.0,
                    scaleTime: Math.random() * Math.PI * 2,
                    flickerTime: Math.random() * Math.PI * 2,
                    isYellowWhite: true // Mark as yellow/white particle for special handling
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Store particles for cleanup
            if (!window.gameParticles) window.gameParticles = [];
            window.gameParticles.push(...particles);
        }

        function animateWalkForCharacter(characterObj) {
            if (!characterObj.userData) return;
            
            const walkTime = characterObj.userData.walkTime;
            const swingAmount = 0.5;
            const elbowKneeAmount = 0.3;
            
            // Check if this is the player character and handle gun animation
            if (characterObj.userData.isPlayer) {
                // Update gun animation progress based on state machine
                let targetProgress = 0;

                // Determine target based on gun state
                if (gunState === 'raising' || gunState === 'firing' || gunState === 'holding') {
                    targetProgress = 1; // Raise arm (including 'holding' state)
                } else if (gunState === 'lowering' || gunState === 'idle') {
                    targetProgress = 0; // Lower arm
                }

                // Use animation speed
                let currentAnimationSpeed = gunAnimationSpeed;

                gunAnimationProgress += (targetProgress - gunAnimationProgress) * currentAnimationSpeed * globalDeltaTime;
                
                // Clamp progress between 0 and 1
                gunAnimationProgress = Math.max(0, Math.min(1, gunAnimationProgress));
                
                // Calculate right arm rotation (90 degrees = Math.PI/2)
                const gunArmRotation = gunAnimationProgress * (-Math.PI / 2);
                // Left arm - normal walking animation when moving, neutral when not moving
                if (isMoving) {
                    characterObj.userData.leftArmPivot.rotation.x = Math.sin(walkTime) * swingAmount;
                    characterObj.userData.leftLowerArmPivot.rotation.x = Math.abs(Math.sin(walkTime)) * elbowKneeAmount;
                } else {
                    // Return to neutral position when not moving
                    characterObj.userData.leftArmPivot.rotation.x = 0;
                    characterObj.userData.leftLowerArmPivot.rotation.x = 0;
                }
                
                // Right arm - gun animation overrides walking animation
                if (gunAnimationProgress > 0) {
                    // Check for arm bounce animation (10 degrees up for 0.1s)
                    let armRotation = gunArmRotation;
                    if (isArmBouncing) {
                        const currentTime = Date.now();
                        const bounceElapsed = currentTime - armBounceStartTime;
                        
                        if (bounceElapsed < 100) { // 0.1 seconds = 100ms
                            // Add 10 degrees (π/18 radians) to the current arm rotation
                            armRotation += -Math.PI / 18; // Additional 10 degrees up
                        } else {
                            // Bounce finished, return to normal position
                            isArmBouncing = false;
                        }
                    }
                    
                    // When gun is raised, right arm is at raised position (with possible bounce)
                    characterObj.userData.rightArmPivot.rotation.x = armRotation;
                    characterObj.userData.rightLowerArmPivot.rotation.x = 0; // Keep elbow straight when gun is raised
                } else {
                    // Reset bounce trigger when gun is lowered
                    gunBounceTriggered = false;
                    isArmBouncing = false;
                    
                    if (isMoving) {
                        // Normal walking animation for right arm when moving
                        characterObj.userData.rightArmPivot.rotation.x = -Math.sin(walkTime) * swingAmount;
                        characterObj.userData.rightLowerArmPivot.rotation.x = Math.abs(Math.sin(walkTime)) * elbowKneeAmount;
                    } else {
                        // Return to neutral position when not moving
                        characterObj.userData.rightArmPivot.rotation.x = 0;
                        characterObj.userData.rightLowerArmPivot.rotation.x = 0;
                    }
                }
            } else {
                // NPC - normal walking animation or scared state animation
                
                // Initialize NPC arm animation progress if not present
                if (characterObj.userData.armAnimationProgress === undefined) {
                    characterObj.userData.armAnimationProgress = 0;
                }
                
                if (characterObj.userData.isScared) {
                    // SCARED STATE: Smoothly raise both arms to 180 degrees

                    const armAnimationSpeed = 8; // Same speed as player gun animation

                    // Update arm animation progress towards 1 (arms raised)
                    const targetProgress = 1;
                    characterObj.userData.armAnimationProgress += (targetProgress - characterObj.userData.armAnimationProgress) * armAnimationSpeed * globalDeltaTime;
                    characterObj.userData.armAnimationProgress = Math.max(0, Math.min(1, characterObj.userData.armAnimationProgress));

                    // Calculate smooth arm rotation (180 degrees = -Math.PI)
                    const scaredArmRotation = characterObj.userData.armAnimationProgress * (-Math.PI);

                    // Both arms smoothly rotate to raised position
                    characterObj.userData.leftArmPivot.rotation.x = scaredArmRotation;
                    characterObj.userData.rightArmPivot.rotation.x = scaredArmRotation;

                    // Initialize scared hand animation time if not present
                    if (characterObj.userData.scaredHandAnimationTime === undefined) {
                        characterObj.userData.scaredHandAnimationTime = 0;
                    }

                    // Update hand animation time
                    characterObj.userData.scaredHandAnimationTime += globalDeltaTime * 4; // Smooth rotation speed
                    
                    // Calculate smooth up/down rotation for hands (similar to player's gun animation)
                    const handRotation = Math.sin(characterObj.userData.scaredHandAnimationTime) * 0.3; // ±0.3 radians (~17 degrees)
                    
                    // Lower arms with smooth hand rotation
                    characterObj.userData.leftLowerArmPivot.rotation.x = handRotation;
                    characterObj.userData.rightLowerArmPivot.rotation.x = handRotation;
                } else {
                    // NORMAL STATE: Smoothly lower arms back to walking animation

                    const armAnimationSpeed = 8; // Same speed as player gun animation

                    // Update arm animation progress towards 0 (arms lowered)
                    const targetProgress = 0;
                    characterObj.userData.armAnimationProgress += (targetProgress - characterObj.userData.armAnimationProgress) * armAnimationSpeed * globalDeltaTime;
                    characterObj.userData.armAnimationProgress = Math.max(0, Math.min(1, characterObj.userData.armAnimationProgress));
                    
                    if (characterObj.userData.armAnimationProgress > 0) {
                        // Still transitioning from scared state - blend between scared and normal
                        const scaredArmRotation = characterObj.userData.armAnimationProgress * (-Math.PI);
                        const normalLeftArmRotation = Math.sin(walkTime) * swingAmount;
                        const normalRightArmRotation = -Math.sin(walkTime) * swingAmount;
                        
                        // Blend between scared and normal arm positions
                        characterObj.userData.leftArmPivot.rotation.x = scaredArmRotation + (1 - characterObj.userData.armAnimationProgress) * normalLeftArmRotation;
                        characterObj.userData.rightArmPivot.rotation.x = scaredArmRotation + (1 - characterObj.userData.armAnimationProgress) * normalRightArmRotation;
                        
                        // Lower arms stay neutral during transition
                        characterObj.userData.leftLowerArmPivot.rotation.x = 0;
                        characterObj.userData.rightLowerArmPivot.rotation.x = 0;
                    } else {
                        // Fully normal walking animation
                        characterObj.userData.leftArmPivot.rotation.x = Math.sin(walkTime) * swingAmount;
                        characterObj.userData.rightArmPivot.rotation.x = -Math.sin(walkTime) * swingAmount;
                        characterObj.userData.leftLowerArmPivot.rotation.x = Math.abs(Math.sin(walkTime)) * elbowKneeAmount;
                        characterObj.userData.rightLowerArmPivot.rotation.x = Math.abs(Math.sin(walkTime)) * elbowKneeAmount;
                    }
                }
            }
            
            // Upper leg swinging (same for all characters)
            characterObj.userData.leftLegPivot.rotation.x = -Math.sin(walkTime) * swingAmount;
            characterObj.userData.rightLegPivot.rotation.x = Math.sin(walkTime) * swingAmount;
            
            // Lower leg (knee) bending - adds natural walking motion (same for all characters)
            characterObj.userData.leftLowerLegPivot.rotation.x = Math.max(0, Math.sin(walkTime)) * elbowKneeAmount;
            characterObj.userData.rightLowerLegPivot.rotation.x = Math.max(0, -Math.sin(walkTime)) * elbowKneeAmount;
        }

        function createStreetGrates(curbX, curbZ, curbHalfSize) {
            // Create 2.53125x4.5 grate planes on each side of the curb (0.5x smaller than before)
            // Positioned to extend outward from the curb into the road, 0.01 units above road level

            const grateWidth = 2.53125; // 5.0625 * 0.5
            const grateLength = 4.5; // 9 * 0.5
            const grateHeight = 0.01; // Slightly above road level (unchanged)

            // Calculate world boundary to prevent grates from being created outside bounds
            const worldSize = getWorldSize();
            const worldBoundary = worldSize / 2;

            // Get the street grate texture
            const grateAsset = lib.getAsset('street_grate_texture');
            let grateMaterial;

            if (grateAsset) {
                const grateTexture = new THREE.TextureLoader().load(grateAsset.url);
                grateTexture.magFilter = THREE.NearestFilter;
                grateTexture.minFilter = THREE.NearestFilter;
                grateTexture.wrapS = THREE.RepeatWrapping;
                grateTexture.wrapT = THREE.RepeatWrapping;
                grateMaterial = new THREE.MeshLambertMaterial({
                    map: grateTexture,
                    transparent: false,
                    side: THREE.DoubleSide
                });
            } else {
                // Fallback to dark gray if texture not available
                grateMaterial = new THREE.MeshLambertMaterial({
                    color: 0x404040,
                    side: THREE.DoubleSide
                });
            }

            // Create four grate planes, one on each side of the curb
            const sides = [
                { // North side
                    x: curbX,
                    z: curbZ - curbHalfSize - grateWidth/2, // Extend outward from north edge
                    rotY: 0, // No rotation needed
                    width: grateLength, // 9 units along X axis
                    height: grateWidth  // 5.0625 units along Z axis
                },
                { // South side
                    x: curbX,
                    z: curbZ + curbHalfSize + grateWidth/2, // Extend outward from south edge
                    rotY: 0, // No rotation needed
                    width: grateLength, // 9 units along X axis
                    height: grateWidth  // 5.0625 units along Z axis
                },
                { // East side
                    x: curbX + curbHalfSize + grateWidth/2, // Extend outward from east edge
                    z: curbZ,
                    rotY: Math.PI/2, // Rotate 90 degrees
                    width: grateLength, // 9 units along Z axis (after rotation)
                    height: grateWidth  // 5.0625 units along X axis (after rotation)
                },
                { // West side
                    x: curbX - curbHalfSize - grateWidth/2, // Extend outward from west edge
                    z: curbZ,
                    rotY: Math.PI/2, // Rotate 90 degrees
                    width: grateLength, // 9 units along Z axis (after rotation)
                    height: grateWidth  // 5.0625 units along X axis (after rotation)
                }
            ];

            sides.forEach(side => {
                // Calculate the bounds of this grate based on its orientation
                let minX, maxX, minZ, maxZ;
                if (side.rotY === 0) {
                    // North/South grates (not rotated)
                    minX = side.x - side.width / 2;
                    maxX = side.x + side.width / 2;
                    minZ = side.z - side.height / 2;
                    maxZ = side.z + side.height / 2;
                } else {
                    // East/West grates (rotated 90 degrees)
                    minX = side.x - side.height / 2;
                    maxX = side.x + side.height / 2;
                    minZ = side.z - side.width / 2;
                    maxZ = side.z + side.width / 2;
                }

                // Only create grate if it's fully within world bounds
                if (minX >= -worldBoundary && maxX <= worldBoundary &&
                    minZ >= -worldBoundary && maxZ <= worldBoundary) {
                    const grateGeometry = new THREE.PlaneGeometry(side.width, side.height);
                    const gratePlane = new THREE.Mesh(grateGeometry, grateMaterial);

                    // Position the grate
                    gratePlane.position.set(side.x, grateHeight, side.z);
                    gratePlane.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
                    gratePlane.rotation.z = side.rotY; // Apply side-specific rotation

                    gratePlane.receiveShadow = true;

                    scene.add(gratePlane);
                }
            });
        }

        function createStreetlight(x, z) {
            const streetlightGroup = new THREE.Group();
            
            // Collect geometries for later merging instead of creating individual meshes
            const baseGeometry = new THREE.BoxGeometry(1.5, 0.25, 1.5);
            baseGeometry.translate(x, 1 + 0.125, z); // Position base (on curb + base height)
            streetlightComponents.bases.push(baseGeometry);
            
            const poleGeometry = new THREE.BoxGeometry(0.375, 15, 0.375);
            poleGeometry.translate(x, 1 + 0.25 + 7.5, z); // Position pole
            streetlightComponents.poles.push(poleGeometry);
            
            const topBoxGeometry = new THREE.BoxGeometry(1, 0.5, 1);
            topBoxGeometry.translate(x, 1 + 0.25 + 15 + 0.25, z); // Position top box
            streetlightComponents.topBoxes.push(topBoxGeometry);
            
            // Every streetlight gets TWO signs (100% chance)
            const hasSign = true;
            
            if (hasSign) {
                // Create 2.25x4 unit plane for street signs
                const signGeometry = new THREE.PlaneGeometry(2.25, 4);
                
                // Randomly select textures for both signs
                const signTextures = [
                    'street_sign_main_st',
                    'street_sign_oak_ave', 
                    'street_sign_elm_rd',
                    'street_sign_park_blvd'
                ];
                
                // Randomly pick one of the four pole faces for the first sign (0=front, 1=right, 2=back, 3=left)
                const firstSignFace = Math.floor(Math.random() * 4);
                
                // Second sign is ALWAYS 90 degrees away (1 face clockwise)
                const secondSignFace = (firstSignFace + 1) % 4;
                
                // Create first sign - collect geometry for merging
                const firstSignIndex = Math.floor(Math.random() * signTextures.length);
                const firstSignTexture = signTextures[firstSignIndex];
                
                // Calculate first sign position and rotation
                let firstSignX = x, firstSignZ = z, firstSignRotY = 0;
                const firstSignY = 1 + 0.25 + 11; // 11 units off the ground plus base height
                
                // Position and rotate first sign based on selected pole face
                switch (firstSignFace) {
                    case 0: // Front face (+Z)
                        firstSignZ += 0.375 / 2 + 0.01; // Just in front of pole face
                        firstSignRotY = 0; // Face forward
                        break;
                    case 1: // Right face (+X)
                        firstSignX += 0.375 / 2 + 0.01; // Just to the right of pole face
                        firstSignRotY = -Math.PI / 2; // Face right
                        break;
                    case 2: // Back face (-Z)
                        firstSignZ -= 0.375 / 2 + 0.01; // Just behind pole face
                        firstSignRotY = Math.PI; // Face backward
                        break;
                    case 3: // Left face (-X)
                        firstSignX -= 0.375 / 2 + 0.01; // Just to the left of pole face
                        firstSignRotY = Math.PI / 2; // Face left
                        break;
                }
                
                // Collect geometry for merging instead of creating individual mesh
                collectStreetSignGeometry(firstSignX, firstSignY, firstSignZ, firstSignRotY, firstSignTexture);
                
                // Create second sign - collect geometry for merging
                const secondSignIndex = Math.floor(Math.random() * signTextures.length);
                const secondSignTexture = signTextures[secondSignIndex];
                
                // Calculate second sign position and rotation
                let secondSignX = x, secondSignZ = z, secondSignRotY = 0;
                const secondSignY = 1 + 0.25 + 11 - 4.5; // 4.5 units LOWER than first sign
                
                // Position and rotate second sign based on face that's 90 degrees away
                switch (secondSignFace) {
                    case 0: // Front face (+Z)
                        secondSignZ += 0.375 / 2 + 0.01; // Just in front of pole face
                        secondSignRotY = 0; // Face forward
                        break;
                    case 1: // Right face (+X)
                        secondSignX += 0.375 / 2 + 0.01; // Just to the right of pole face
                        secondSignRotY = -Math.PI / 2; // Face right
                        break;
                    case 2: // Back face (-Z)
                        secondSignZ -= 0.375 / 2 + 0.01; // Just behind pole face
                        secondSignRotY = Math.PI; // Face backward
                        break;
                    case 3: // Left face (-X)
                        secondSignX -= 0.375 / 2 + 0.01; // Just to the left of pole face
                        secondSignRotY = Math.PI / 2; // Face left
                        break;
                }
                
                // Collect geometry for merging instead of creating individual mesh
                collectStreetSignGeometry(secondSignX, secondSignY, secondSignZ, secondSignRotY, secondSignTexture);
            }
            
            // Position the entire streetlight group ON TOP of the curb (curb height is 1 unit)
            streetlightGroup.position.set(x, 1, z);
            
            // Create 4.95x4.95 unit drop shadow for streetlight (1.65x bigger than original 3x3)
            const streetlightShadowGeometry = new THREE.PlaneGeometry(4.95, 4.95);
            
            // Create canvas for streetlight shadow gradient
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient: 60% alpha black center to 0% alpha black edge
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)'); // 60% alpha black center
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // 0% alpha black edge
            
            // Fill canvas with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            // Create texture from canvas
            const streetlightShadowTexture = new THREE.CanvasTexture(canvas);
            streetlightShadowTexture.needsUpdate = true;
            
            // Create material with transparency
            const streetlightShadowMaterial = new THREE.MeshBasicMaterial({
                map: streetlightShadowTexture,
                transparent: true,
                opacity: 1,
                depthWrite: false // Prevent z-fighting with ground
            });
            
            // Create streetlight shadow plane mesh
            const streetlightShadow = new THREE.Mesh(streetlightShadowGeometry, streetlightShadowMaterial);
            streetlightShadow.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
            streetlightShadow.position.set(x, 1.01, z); // Slightly above curb surface to prevent z-fighting
            
            // Add both streetlight and its shadow to the scene
            scene.add(streetlightGroup);
            scene.add(streetlightShadow);
            
            return { streetlight: streetlightGroup, shadow: streetlightShadow };
        }

        function mergeStreetlightComponents() {
            const darkGreyMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
            let totalMerged = 0;
            
            // Merge all streetlight bases
            if (streetlightComponents.bases.length > 0) {
                const mergedBases = THREE.BufferGeometryUtils.mergeBufferGeometries(streetlightComponents.bases);
                const basesMesh = new THREE.Mesh(mergedBases, darkGreyMaterial);
                basesMesh.castShadow = true;
                basesMesh.receiveShadow = true;
                scene.add(basesMesh);
                
                totalMerged += streetlightComponents.bases.length;
                // Clean up individual geometries
                streetlightComponents.bases.forEach(geo => geo.dispose());
                streetlightComponents.bases = [];
            }
            
            // Merge all streetlight poles
            if (streetlightComponents.poles.length > 0) {
                const mergedPoles = THREE.BufferGeometryUtils.mergeBufferGeometries(streetlightComponents.poles);
                const polesMesh = new THREE.Mesh(mergedPoles, darkGreyMaterial);
                polesMesh.castShadow = true;
                polesMesh.receiveShadow = true;
                scene.add(polesMesh);
                
                totalMerged += streetlightComponents.poles.length;
                // Clean up individual geometries
                streetlightComponents.poles.forEach(geo => geo.dispose());
                streetlightComponents.poles = [];
            }
            
            // Merge all streetlight top boxes
            if (streetlightComponents.topBoxes.length > 0) {
                const mergedTopBoxes = THREE.BufferGeometryUtils.mergeBufferGeometries(streetlightComponents.topBoxes);
                const topBoxesMesh = new THREE.Mesh(mergedTopBoxes, darkGreyMaterial);
                topBoxesMesh.castShadow = true;
                topBoxesMesh.receiveShadow = true;
                scene.add(topBoxesMesh);
                
                totalMerged += streetlightComponents.topBoxes.length;
                // Clean up individual geometries
                streetlightComponents.topBoxes.forEach(geo => geo.dispose());
                streetlightComponents.topBoxes = [];
            }
            
            if (totalMerged > 0) {
                console.log(`Merged ${totalMerged} streetlight components into 3 optimized meshes`);
            }
        }

        function collectStreetSignGeometry(x, y, z, rotationY, textureType) {
            // Create geometry for merging instead of individual mesh
            const signGeometry = new THREE.PlaneGeometry(2.25, 4);
            
            // Apply transformations
            signGeometry.rotateY(rotationY);
            signGeometry.translate(x, y, z);
            
            // Group by texture type
            if (textureType === 'street_sign_main_st') {
                streetSignComponents.mainSt.push(signGeometry);
            } else if (textureType === 'street_sign_oak_ave') {
                streetSignComponents.oakAve.push(signGeometry);
            } else if (textureType === 'street_sign_elm_rd') {
                streetSignComponents.elmRd.push(signGeometry);
            } else if (textureType === 'street_sign_park_blvd') {
                streetSignComponents.parkBlvd.push(signGeometry);
            }
        }

        function mergeStreetSignComponents() {
            let totalMerged = 0;
            
            // Helper function to merge signs with same texture
            function mergeSignGroup(geometries, textureAssetId, fallbackColor) {
                if (geometries.length === 0) return 0;
                
                let signMaterial;
                const signAsset = lib.getAsset(textureAssetId);
                if (signAsset) {
                    const signTexture = new THREE.TextureLoader().load(signAsset.url);
                    signTexture.magFilter = THREE.NearestFilter;
                    signTexture.minFilter = THREE.NearestFilter;
                    signMaterial = new THREE.MeshLambertMaterial({ 
                        map: signTexture,
                        transparent: false,
                        side: THREE.DoubleSide
                    });
                } else {
                    signMaterial = new THREE.MeshLambertMaterial({ 
                        color: fallbackColor,
                        side: THREE.DoubleSide
                    });
                }
                
                const mergedSigns = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
                const signsMesh = new THREE.Mesh(mergedSigns, signMaterial);
                signsMesh.castShadow = true;
                signsMesh.receiveShadow = true;
                scene.add(signsMesh);
                
                // Clean up individual geometries
                geometries.forEach(geo => geo.dispose());
                
                return geometries.length;
            }
            
            // Merge each sign type
            totalMerged += mergeSignGroup(streetSignComponents.mainSt, 'street_sign_main_st', 0x228B22);
            totalMerged += mergeSignGroup(streetSignComponents.oakAve, 'street_sign_oak_ave', 0x4169E1);
            totalMerged += mergeSignGroup(streetSignComponents.elmRd, 'street_sign_elm_rd', 0xB22222);
            totalMerged += mergeSignGroup(streetSignComponents.parkBlvd, 'street_sign_park_blvd', 0x8B4513);
            
            // Clear arrays
            streetSignComponents = { mainSt: [], oakAve: [], elmRd: [], parkBlvd: [] };
            
            if (totalMerged > 0) {
                console.log(`Merged ${totalMerged} street sign components into 4 optimized meshes by texture`);
            }
        }

        function mergeTreeComponents() {
            let totalMerged = 0;
            
            // Merge all tree trunks
            if (treeComponents.trunks.length > 0) {
                // Create trunk material
                let trunkMaterial;
                const woodAsset = lib.getAsset('wood_texture');
                if (woodAsset) {
                    const woodTexture = new THREE.TextureLoader().load(woodAsset.url);
                    woodTexture.magFilter = THREE.NearestFilter;
                    woodTexture.minFilter = THREE.NearestFilter;
                    woodTexture.wrapS = THREE.RepeatWrapping;
                    woodTexture.wrapT = THREE.RepeatWrapping;
                    woodTexture.repeat.set(1, 8);
                    trunkMaterial = new THREE.MeshLambertMaterial({ 
                        map: woodTexture
                    });
                } else {
                    trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                }
                
                const mergedTrunks = THREE.BufferGeometryUtils.mergeBufferGeometries(treeComponents.trunks);
                const trunksMesh = new THREE.Mesh(mergedTrunks, trunkMaterial);
                trunksMesh.castShadow = true;
                trunksMesh.receiveShadow = true;
                scene.add(trunksMesh);
                
                totalMerged += treeComponents.trunks.length;
                // Clean up individual geometries
                treeComponents.trunks.forEach(geo => geo.dispose());
                treeComponents.trunks = [];
            }
            
            // Merge all tree leaves
            if (treeComponents.leaves.length > 0) {
                // Create leaf material
                let leafMaterial;
                const leafAsset = lib.getAsset('minecraft_leaf_texture_alpha');
                if (leafAsset) {
                    const leafTexture = new THREE.TextureLoader().load(leafAsset.url);
                    leafTexture.magFilter = THREE.NearestFilter;
                    leafTexture.minFilter = THREE.NearestFilter;
                    leafTexture.wrapS = THREE.RepeatWrapping;
                    leafTexture.wrapT = THREE.RepeatWrapping;
                    leafMaterial = new THREE.MeshLambertMaterial({ 
                        map: leafTexture,
                        transparent: true,
                        alphaTest: 0.5
                    });
                } else {
                    leafMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x228B22,
                        transparent: true,
                        opacity: 0.8
                    });
                }
                
                const mergedLeaves = THREE.BufferGeometryUtils.mergeBufferGeometries(treeComponents.leaves);
                const leavesMesh = new THREE.Mesh(mergedLeaves, leafMaterial);
                leavesMesh.castShadow = true;
                leavesMesh.receiveShadow = true;
                scene.add(leavesMesh);
                
                totalMerged += treeComponents.leaves.length;
                // Clean up individual geometries
                treeComponents.leaves.forEach(geo => geo.dispose());
                treeComponents.leaves = [];
            }
            
            if (totalMerged > 0) {
                console.log(`Merged ${totalMerged} tree components into 2 optimized meshes`);
            }
        }

        function createPixelatedPlant() {
            // Create a 4x4 unit square plane for the plant (2x bigger than before)
            const plantGeometry = new THREE.PlaneGeometry(4, 4);
            
            // Get the pixelated plant texture
            const plantAsset = lib.getAsset('pixelated_plant_texture');
            let plantMaterial;
            
            if (plantAsset) {
                const plantTexture = new THREE.TextureLoader().load(plantAsset.url);
                plantTexture.magFilter = THREE.NearestFilter;
                plantTexture.minFilter = THREE.NearestFilter;
                plantMaterial = new THREE.MeshLambertMaterial({ 
                    map: plantTexture,
                    transparent: true,
                    alphaTest: 0.5, // Enable alpha channel for transparency
                    side: THREE.DoubleSide // Visible from both sides
                });
            } else {
                // Fallback to green color with transparency
                plantMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4CAF50,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
            }
            
            const plant = new THREE.Mesh(plantGeometry, plantMaterial);
            
            // Rotate to be perpendicular to the ground (standing upright)
            plant.rotation.x = 0; // Keep it vertical
            
            plant.castShadow = true;
            plant.receiveShadow = true;
            
            return plant;
        }

        function collectPlantGeometry(x, y, z, rotationY) {
            // Create geometry for merging instead of individual mesh
            const plantGeometry = new THREE.PlaneGeometry(4, 4);
            
            // Apply transformations
            plantGeometry.rotateY(rotationY);
            plantGeometry.translate(x, y, z);
            
            plantComponents.push(plantGeometry);
        }

        function mergePlantComponents() {
            if (plantComponents.length === 0) return;
            
            // Create plant material
            let plantMaterial;
            const plantAsset = lib.getAsset('pixelated_plant_texture');
            if (plantAsset) {
                const plantTexture = new THREE.TextureLoader().load(plantAsset.url);
                plantTexture.magFilter = THREE.NearestFilter;
                plantTexture.minFilter = THREE.NearestFilter;
                plantMaterial = new THREE.MeshLambertMaterial({ 
                    map: plantTexture,
                    transparent: true,
                    alphaTest: 0.5,
                    side: THREE.DoubleSide
                });
            } else {
                plantMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4CAF50,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
            }
            
            const mergedPlants = THREE.BufferGeometryUtils.mergeBufferGeometries(plantComponents);
            const plantsMesh = new THREE.Mesh(mergedPlants, plantMaterial);
            plantsMesh.castShadow = true;
            plantsMesh.receiveShadow = true;
            scene.add(plantsMesh);
            
            console.log(`Merged ${plantComponents.length} plant geometries into 1 optimized mesh`);
            
            // Clean up individual geometries
            plantComponents.forEach(geo => geo.dispose());
            plantComponents = [];
        }

        function generateTree(x, z, yOffset = 0) {
            const treeGroup = new THREE.Group();
            
            // Collect trunk geometry for global merging
            // FIXED: Position trunk so bottom face is ON TOP of grass (yOffset + trunk_height/2)
            const trunkGeometry = new THREE.BoxGeometry(2, 16, 2);
            trunkGeometry.translate(x, yOffset + 8, z); // Position trunk center at yOffset + half height (8)
            treeComponents.trunks.push(trunkGeometry);
            
            // Collect all leaf geometries for global merging
            const firstFourPositions = [];
            
            // Generate first 4 leaf cubes
            for (let i = 0; i < 4; i++) {
                const leafSize = 6 + Math.random() * 8.0;
                const leafGeometry = new THREE.BoxGeometry(leafSize, leafSize, leafSize);
                
                // Position randomly around the top of the trunk
                const angle = (i / 4) * Math.PI * 2 + (Math.random() - 0.5) * 0.8;
                const distance = 2.0 + Math.random() * 3.0;
                const leafX = x + Math.cos(angle) * distance; // World space
                const leafZ = z + Math.sin(angle) * distance; // World space
                const leafY = yOffset + 16 + leafSize/2 + (Math.random() - 0.5) * 2;
                
                leafGeometry.translate(leafX, leafY, leafZ);
                treeComponents.leaves.push(leafGeometry);
                
                firstFourPositions.push({ x: leafX, z: leafZ, y: leafY, size: leafSize });
            }
            
            // Find the highest of the first four cubes
            let highestY = Math.max(...firstFourPositions.map(pos => pos.y + pos.size/2));
            
            // Generate 2 additional leaf cubes above
            for (let i = 0; i < 2; i++) {
                const leafSize = 6 + Math.random() * 8.0;
                const leafGeometry = new THREE.BoxGeometry(leafSize, leafSize, leafSize);
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 1.0 + Math.random() * 2.0;
                const leafX = x + Math.cos(angle) * distance; // World space
                const leafZ = z + Math.sin(angle) * distance; // World space
                const leafY = highestY + leafSize/2 + Math.random() * 2;
                
                leafGeometry.translate(leafX, leafY, leafZ);
                treeComponents.leaves.push(leafGeometry);
            }
            
            // Create 8x8 unit drop shadow for the tree (2x bigger)
            const treeShadowGeometry = new THREE.PlaneGeometry(8, 8);
            
            // Create canvas for tree shadow gradient
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient: 70% alpha black center to 0% alpha black edge
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.7)'); // 70% alpha black center
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // 0% alpha black edge
            
            // Fill canvas with gradient
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            // Create texture from canvas
            const treeShadowTexture = new THREE.CanvasTexture(canvas);
            treeShadowTexture.needsUpdate = true;
            
            // Create material with transparency
            const treeShadowMaterial = new THREE.MeshBasicMaterial({
                map: treeShadowTexture,
                transparent: true,
                opacity: 1,
                depthWrite: false // Prevent z-fighting with ground
            });
            
            // Create tree shadow plane mesh
            const treeShadow = new THREE.Mesh(treeShadowGeometry, treeShadowMaterial);
            treeShadow.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
            treeShadow.position.set(0, 10.47, 0); // ABSOLUTE Y-axis position of 2.47
            
            // Add shadow to tree group
            treeGroup.add(treeShadow);
            
            // Position the entire tree group
            treeGroup.position.set(x, 0, z);
            
            return treeGroup;
        }

        function getEdgeRoadPositions() {
            // Roads exist between blocks
            // For 11 blocks, there are 10 roads (BLOCKS_PER_SIDE - 1)
            const numRoads = BLOCKS_PER_SIDE - 1; // 10
            const roadPositions = [];
            const gridStart = -Math.floor(BLOCKS_PER_SIDE / 2) * BLOCK_SPACING; // -450

            // Calculate positions of roads (centers of 30-unit gaps between blocks)
            for (let i = 0; i < numRoads; i++) {
                const blockPos1 = gridStart + (i * BLOCK_SPACING);
                const blockPos2 = gridStart + ((i + 1) * BLOCK_SPACING);
                const roadCenter = (blockPos1 + blockPos2) / 2;
                roadPositions.push(roadCenter);
            }

            // Returns: [-405, -315, -225, -135, -45, 45, 135, 225, 315, 405]
            return roadPositions;
        }

        function selectDockGroups() {
            const roadPositions = getEdgeRoadPositions(); // 10 positions per side
            const numRoads = roadPositions.length; // 10
            const sides = ['north', 'south', 'east', 'west'];
            const dockGroups = [];

            sides.forEach(side => {
                // Random group size: 2-4 roads
                const groupSize = 2 + Math.floor(Math.random() * 3);

                // Random starting position (ensure group fits)
                const maxStartIdx = numRoads - groupSize;
                const startIdx = Math.floor(Math.random() * (maxStartIdx + 1));

                dockGroups.push({
                    side: side,
                    startIdx: startIdx,
                    count: groupSize,
                    roadPositions: roadPositions.slice(startIdx, startIdx + groupSize)
                });
            });

            return dockGroups;
        }

        function createDock(roadPos, side, worldBoundary, woodAsset) {
            const DOCK_LENGTH = 70;
            const DOCK_WIDTH = ROAD_WIDTH; // 30
            const DOCK_THICKNESS = 0.2;
            const DOCK_POST_SIZE = 2;
            const DOCK_POST_HEIGHT = 7; // Extends 1m below water and 3m above dock surface

            let platformGeometry, position, collisionRect, woodMaterial;

            // Visual dock starts at world boundary
            const visualDockOffset = DOCK_LENGTH / 2;

            // Collision extends inward for smooth transition and covers full dock length
            const characterRadius = 0.5625;
            const overlap = 2;
            const inwardExtension = characterRadius + overlap;
            const collisionDockLength = DOCK_LENGTH + inwardExtension;
            const collisionDockOffset = DOCK_LENGTH / 2 - inwardExtension / 2;

            // Create plank material for dock surface with texture repeat matching road density (1 repeat per 8 units)
            // Texture orientation depends on dock direction
            const plankAsset = lib.getAsset('plank_texture');
            let plankMaterial;
            if (plankAsset) {
                const plankTexture = new THREE.TextureLoader().load(plankAsset.url);
                plankTexture.wrapS = THREE.RepeatWrapping;
                plankTexture.wrapT = THREE.RepeatWrapping;

                // Set repeat based on dock orientation
                if (side === 'north' || side === 'south') {
                    // BoxGeometry(width=30, thickness, length=70) - X=30, Z=70
                    plankTexture.repeat.set(DOCK_WIDTH / 8, DOCK_LENGTH / 8); // (3.75, 8.75)
                } else {
                    // BoxGeometry(length=70, thickness, width=30) - X=70, Z=30
                    plankTexture.repeat.set(DOCK_LENGTH / 8, DOCK_WIDTH / 8); // (8.75, 3.75)
                }

                plankTexture.magFilter = THREE.NearestFilter;
                plankTexture.minFilter = THREE.NearestFilter;

                plankMaterial = new THREE.MeshLambertMaterial({ map: plankTexture });
            } else {
                plankMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            }

            switch(side) {
                case 'north': // Extends in +Z direction
                    platformGeometry = new THREE.BoxGeometry(DOCK_WIDTH, DOCK_THICKNESS, DOCK_LENGTH);
                    position = { x: roadPos, y: 0, z: worldBoundary + visualDockOffset };
                    collisionRect = {
                        x: roadPos,
                        z: worldBoundary + collisionDockOffset,
                        width: DOCK_WIDTH,
                        length: collisionDockLength,
                        rotation: 0
                    };
                    break;
                case 'south': // Extends in -Z direction
                    platformGeometry = new THREE.BoxGeometry(DOCK_WIDTH, DOCK_THICKNESS, DOCK_LENGTH);
                    position = { x: roadPos, y: 0, z: -worldBoundary - visualDockOffset };
                    collisionRect = {
                        x: roadPos,
                        z: -worldBoundary - collisionDockOffset,
                        width: DOCK_WIDTH,
                        length: collisionDockLength,
                        rotation: 0
                    };
                    break;
                case 'east': // Extends in +X direction
                    platformGeometry = new THREE.BoxGeometry(DOCK_LENGTH, DOCK_THICKNESS, DOCK_WIDTH);
                    position = { x: worldBoundary + visualDockOffset, y: 0, z: roadPos };
                    collisionRect = {
                        x: worldBoundary + collisionDockOffset,
                        z: roadPos,
                        width: DOCK_WIDTH,
                        length: collisionDockLength,
                        rotation: Math.PI / 2
                    };
                    break;
                case 'west': // Extends in -X direction
                    platformGeometry = new THREE.BoxGeometry(DOCK_LENGTH, DOCK_THICKNESS, DOCK_WIDTH);
                    position = { x: -worldBoundary - visualDockOffset, y: 0, z: roadPos };
                    collisionRect = {
                        x: -worldBoundary - collisionDockOffset,
                        z: roadPos,
                        width: DOCK_WIDTH,
                        length: collisionDockLength,
                        rotation: Math.PI / 2
                    };
                    break;
            }

            // Create platform
            const platform = new THREE.Mesh(platformGeometry, plankMaterial);
            platform.position.set(position.x, position.y, position.z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);

            // Create 10 posts (2 columns × 5 rows)
            const postGeometry = new THREE.BoxGeometry(DOCK_POST_SIZE, DOCK_POST_HEIGHT, DOCK_POST_SIZE);
            const postBottomY = WATER_LEVEL - 1; // Start 1m below water surface
            const postYPosition = postBottomY + (DOCK_POST_HEIGHT / 2); // Center post from bottom

            // Create post material with correct texture density (1 repeat per 8 units)
            let postMaterial;
            if (woodAsset) {
                const postTexture = new THREE.TextureLoader().load(woodAsset.url);
                postTexture.magFilter = THREE.NearestFilter;
                postTexture.minFilter = THREE.NearestFilter;
                postTexture.wrapS = THREE.RepeatWrapping;
                postTexture.wrapT = THREE.RepeatWrapping;
                // Post is 2×6×2 units (width × height × depth)
                postTexture.repeat.set(DOCK_POST_SIZE / 8, DOCK_POST_HEIGHT / 8);
                postMaterial = new THREE.MeshLambertMaterial({ map: postTexture });
            } else {
                postMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            }

            // Posts straddle the edges of the dock (at ±15 units from centerline for 30-unit wide dock)
            // Posts are evenly spaced along the dock, relative to visual dock start edge
            const dockStartOffset = visualDockOffset - DOCK_LENGTH / 2;
            const postOffsets = [0, 17.5, 35, 52.5, 70];
            const postLateralOffset = DOCK_WIDTH / 2; // 15 units - posts at the edge

            postOffsets.forEach(alongDockOffset => {
                // Create left and right posts
                [-postLateralOffset, postLateralOffset].forEach(lateralOffset => {
                    const post = new THREE.Mesh(postGeometry, postMaterial);

                    // Position depends on dock orientation
                    if (side === 'north') {
                        post.position.set(
                            roadPos + lateralOffset,
                            postYPosition,
                            worldBoundary + dockStartOffset + alongDockOffset
                        );
                    } else if (side === 'south') {
                        post.position.set(
                            roadPos + lateralOffset,
                            postYPosition,
                            -worldBoundary - dockStartOffset - alongDockOffset
                        );
                    } else if (side === 'east') {
                        post.position.set(
                            worldBoundary + dockStartOffset + alongDockOffset,
                            postYPosition,
                            roadPos + lateralOffset
                        );
                    } else if (side === 'west') {
                        post.position.set(
                            -worldBoundary - dockStartOffset - alongDockOffset,
                            postYPosition,
                            roadPos + lateralOffset
                        );
                    }

                    post.castShadow = true;
                    post.receiveShadow = true;
                    scene.add(post);
                });
            });

            return collisionRect;
        }

        function createDockGroup(group, worldBoundary, woodAsset) {
            const dockRectangles = [];

            group.roadPositions.forEach(roadPos => {
                const dockRect = createDock(roadPos, group.side, worldBoundary, woodAsset);
                dockRectangles.push(dockRect);
            });

            return dockRectangles;
        }

        function createSeawalls(dockGroups, worldBoundary, waterLevel, seawallHeight) {
            const seawallThickness = 2;
            const DOCK_GAP_WIDTH = ROAD_WIDTH; // 30 units - width of gap for each dock
            const concreteAsset = lib.getAsset('concrete_texture');

            // Build perimeter wall on each side with gaps for docks
            const sides = ['north', 'south', 'east', 'west'];

            sides.forEach(sideName => {
                // Get docks on this side
                const dockGroup = dockGroups.find(g => g.side === sideName);
                const dockPositions = dockGroup.roadPositions; // Positions along the perimeter where docks are

                // Sort dock positions (by x for N/S sides, by z for E/W sides)
                const sortedDockPositions = [...dockPositions].sort((a, b) => a - b);

                // Define perimeter bounds for this side
                // For N/S: runs along X from -worldBoundary to +worldBoundary
                // For E/W: runs along Z from -worldBoundary to +worldBoundary
                const perimeterStart = -worldBoundary;
                const perimeterEnd = worldBoundary;

                // Build wall segments
                let currentPos = perimeterStart;

                sortedDockPositions.forEach(dockPos => {
                    // Calculate gap boundaries (dock centered at dockPos, width = DOCK_GAP_WIDTH)
                    const gapStart = dockPos - DOCK_GAP_WIDTH / 2;
                    const gapEnd = dockPos + DOCK_GAP_WIDTH / 2;

                    // Create segment from currentPos to gapStart
                    if (gapStart > currentPos) {
                        const segmentLength = gapStart - currentPos;
                        const segmentCenter = (currentPos + gapStart) / 2;

                        createSeawallSegment(
                            sideName,
                            segmentCenter,
                            segmentLength,
                            worldBoundary,
                            waterLevel,
                            seawallHeight,
                            seawallThickness,
                            concreteAsset
                        );
                    }

                    // Move current position to end of gap
                    currentPos = gapEnd;
                });

                // Create final segment from last gap to perimeter end
                if (currentPos < perimeterEnd) {
                    const segmentLength = perimeterEnd - currentPos;
                    const segmentCenter = (currentPos + perimeterEnd) / 2;

                    createSeawallSegment(
                        sideName,
                        segmentCenter,
                        segmentLength,
                        worldBoundary,
                        waterLevel,
                        seawallHeight,
                        seawallThickness,
                        concreteAsset
                    );
                }
            });
        }

        function createSeawallSegment(sideName, centerPos, segmentLength, worldBoundary, waterLevel, seawallHeight, seawallThickness, concreteAsset) {
            // Create material with texture repeat for consistent density (1 repeat per 8 units like roads)
            let wallMaterial;
            if (concreteAsset) {
                const texture = new THREE.TextureLoader().load(concreteAsset.url);
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;

                // Set texture repeat for top face (prioritized)
                // BoxGeometry top face UV: U maps to first param (X), V maps to third param (Z)
                if (sideName === 'north' || sideName === 'south') {
                    // BoxGeometry(segmentLength, height, thickness)
                    // Top face: segmentLength × thickness
                    texture.repeat.set(segmentLength / 8, seawallThickness / 8);
                } else {
                    // BoxGeometry(thickness, height, segmentLength)
                    // Top face: thickness × segmentLength
                    texture.repeat.set(seawallThickness / 8, segmentLength / 8);
                }

                wallMaterial = new THREE.MeshLambertMaterial({ map: texture });
            } else {
                wallMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            }

            // Create geometry and position based on side
            // Inner edge of wall is at world boundary, extends outward into water
            let wallGeometry, wallPosition;

            if (sideName === 'north' || sideName === 'south') {
                // Wall extends along X axis, positioned with inner edge at z = ±worldBoundary
                wallGeometry = new THREE.BoxGeometry(segmentLength, seawallHeight, seawallThickness);
                const zOffset = seawallThickness / 2; // Offset outward by half thickness
                const zPos = sideName === 'north' ? worldBoundary + zOffset : -worldBoundary - zOffset;
                wallPosition = { x: centerPos, y: waterLevel + seawallHeight / 2, z: zPos };
            } else {
                // Wall extends along Z axis, positioned with inner edge at x = ±worldBoundary
                wallGeometry = new THREE.BoxGeometry(seawallThickness, seawallHeight, segmentLength);
                const xOffset = seawallThickness / 2; // Offset outward by half thickness
                const xPos = sideName === 'east' ? worldBoundary + xOffset : -worldBoundary - xOffset;
                wallPosition = { x: xPos, y: waterLevel + seawallHeight / 2, z: centerPos };
            }

            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(wallPosition.x, wallPosition.y, wallPosition.z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
        }

        function isInDockRectangle(x, z, dock) {
            // Check if point (x, z) is within rotated rectangle
            // Dock has: {x, z, width, length, rotation}
            const dx = x - dock.x;
            const dz = z - dock.z;

            // Rotate point to dock's local space
            const cos = Math.cos(-dock.rotation);
            const sin = Math.sin(-dock.rotation);
            const localX = dx * cos - dz * sin;
            const localZ = dx * sin + dz * cos;

            return Math.abs(localX) <= dock.width / 2 &&
                   Math.abs(localZ) <= dock.length / 2;
        }

        function isOnDock(x, z) {
            if (!worldDocks) return false;

            for (let dock of worldDocks) {
                if (isInDockRectangle(x, z, dock)) {
                    return true;
                }
            }
            return false;
        }

        function isOnWater(x, z) {
            const worldBoundary = getWorldSize() / 2; // Derived from BLOCKS_PER_SIDE

            // If inside city bounds, not on water
            if (Math.abs(x) < worldBoundary && Math.abs(z) < worldBoundary) {
                return false;
            }

            // Outside city bounds - check if on a dock
            return !isOnDock(x, z);
        }

        function createIslandFeatures() {
            const worldSize = getWorldSize();
            const worldBoundary = worldSize / 2;
            const waterExtent = worldSize * 3;

            console.log('Creating island features...');

            // 1. Create water plane
            const waterGeometry = new THREE.PlaneGeometry(waterExtent, waterExtent);
            const waterAsset = lib.getAsset('water_texture');
            let waterMaterial;
            if (waterAsset) {
                const waterTexture = new THREE.TextureLoader().load(waterAsset.url);
                waterTexture.wrapS = THREE.RepeatWrapping;
                waterTexture.wrapT = THREE.RepeatWrapping;
                waterTexture.repeat.set(worldSize / 8, worldSize / 8);
                waterTexture.magFilter = THREE.NearestFilter;
                waterTexture.minFilter = THREE.NearestFilter;
                waterMaterial = new THREE.MeshLambertMaterial({ map: waterTexture });
            } else {
                waterMaterial = new THREE.MeshLambertMaterial({ color: 0x4A90E2 });
            }
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = WATER_LEVEL;
            water.receiveShadow = true;
            scene.add(water);

            console.log('Water plane created');

            // 2. Select dock groups (one per side, 2-4 roads each, random positions)
            dockGroups = selectDockGroups();

            console.log('Dock groups selected:', dockGroups);

            // 3. Get wood asset for docks
            const woodAsset = lib.getAsset('wood_texture');

            // 4. Create seawalls with gaps for docks
            createSeawalls(dockGroups, worldBoundary, WATER_LEVEL, SEAWALL_HEIGHT);

            console.log('Seawalls created');

            // 5. Create docks
            const dockRectangles = [];
            dockGroups.forEach(group => {
                const docks = createDockGroup(group, worldBoundary, woodAsset);
                dockRectangles.push(...docks);
            });

            console.log('Docks created:', dockRectangles.length);

            // 6. Store dock collision data in gameConfig
            worldDocks = dockRectangles;
        }

        function createWorld() {
            const worldSize = getWorldSize();

            // Floor with road asphalt texture
            const floorGeometry = new THREE.PlaneGeometry(worldSize, worldSize);
            let floorMaterial;
            
            const asphaltAsset = lib.getAsset('road_asphalt_texture');
            if (asphaltAsset) {
                const asphaltTexture = new THREE.TextureLoader().load(asphaltAsset.url);
                asphaltTexture.wrapS = THREE.RepeatWrapping;
                asphaltTexture.wrapT = THREE.RepeatWrapping;
                asphaltTexture.repeat.set(worldSize / 8, worldSize / 8);
                asphaltTexture.magFilter = THREE.NearestFilter;
                asphaltTexture.minFilter = THREE.NearestFilter;
                floorMaterial = new THREE.MeshLambertMaterial({ 
                    map: asphaltTexture
                });
            } else {
                floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: '#2F2F2F' // Dark gray asphalt color fallback
                });
            }
            
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // No walls - removed entirely
            
            return { 
                plane: floor, 
                size: worldSize, 
                walls: [], // Empty array since no walls
                ceiling: null, // No ceiling
                wallHeight: 0 // No wall height
            };
        }

        function createGreyPlanesBetweenCurbs(allSquares, spacing) {
            // Create crosswalk stripes based on road network segments
            // Ensure road network exists
            if (!window.roadNetwork) {
                window.roadNetwork = generateRoadNetwork();
            }

            if (!window.roadNetwork.segments) {
                console.warn('Road network segments not available for crosswalk creation');
                return;
            }

            const segmentCount = Object.keys(window.roadNetwork.segments).length;
            console.log(`Creating crosswalks for ${segmentCount} road segments`);

            const greyPlaneMaterial = new THREE.MeshLambertMaterial({
                color: 0x808080, // Grey color
                side: THREE.DoubleSide
            });

            // Each stripe is 1.5 units thick (along road), 30 units wide (across road)
            const planeGeometry = new THREE.PlaneGeometry(1.5, 30);

            let crosswalkCount = 0;
            for (let segId in window.roadNetwork.segments) {
                const seg = window.roadNetwork.segments[segId];

                // Calculate rotation directly from segment angle
                // After rotation.x = -π/2, the plane's 30-unit dimension is along Z axis
                // We want it perpendicular to the road
                const rotationZ = seg.angle - Math.PI / 2;

                // Position crosswalks near each end of the road segment
                // Start crosswalk: 10 units from roadStart into the segment
                const startCrosswalkX = seg.roadStart.x + seg.direction.x * 10;
                const startCrosswalkZ = seg.roadStart.z + seg.direction.z * 10;

                // End crosswalk: 10 units before roadEnd
                const endCrosswalkX = seg.roadEnd.x - seg.direction.x * 10;
                const endCrosswalkZ = seg.roadEnd.z - seg.direction.z * 10;

                // Stripe spacing: 2 stripes per crosswalk, spaced 10 units apart (5 on each side)
                const stripeSpacing = 5;
                const stripeOffsets = [-stripeSpacing, stripeSpacing];

                // Create 2 stripes for start crosswalk
                stripeOffsets.forEach(offset => {
                    const greyPlane = new THREE.Mesh(planeGeometry, greyPlaneMaterial);

                    greyPlane.position.set(
                        startCrosswalkX + seg.direction.x * offset,
                        0.05, // Just above ground, same as sewer grates
                        startCrosswalkZ + seg.direction.z * offset
                    );
                    greyPlane.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
                    greyPlane.rotation.z = rotationZ;
                    greyPlane.receiveShadow = true;

                    scene.add(greyPlane);
                    crosswalkCount++;
                });

                // Create 2 stripes for end crosswalk
                stripeOffsets.forEach(offset => {
                    const greyPlane = new THREE.Mesh(planeGeometry, greyPlaneMaterial);

                    greyPlane.position.set(
                        endCrosswalkX + seg.direction.x * offset,
                        0.05, // Just above ground, same as sewer grates
                        endCrosswalkZ + seg.direction.z * offset
                    );
                    greyPlane.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
                    greyPlane.rotation.z = rotationZ;
                    greyPlane.receiveShadow = true;

                    scene.add(greyPlane);
                    crosswalkCount++;
                });
            }

            console.log(`Created ${crosswalkCount} crosswalk stripes (${crosswalkCount / 4} crosswalks)`);
        }

        function createCubes() {
            try {
                console.log('createCubes() called');
                // Clear existing cubes
                cubeObjects.forEach(cube => scene.remove(cube.mesh));
                cubeObjects = [];
                
                // Clear existing streetlights
                streetlightObjects.forEach(streetlightObj => {
                    scene.remove(streetlightObj.streetlight);
                    scene.remove(streetlightObj.shadow);
                });
                streetlightObjects = [];
                
                // Clear existing trees
                treeObjects.forEach(tree => scene.remove(tree));
                treeObjects = [];
                
                // Clear existing cars
                carObjects.forEach(car => scene.remove(car));
                carObjects = [];
                
                // Clear existing cash bundles and their shadows
                cashBundles.forEach(bundle => {
                    scene.remove(bundle);
                    if (bundle.userData && bundle.userData.shadowPlane) {
                        scene.remove(bundle.userData.shadowPlane);
                    }
                });
                cashBundles = [];
                
                // Clear existing health packs and their shadows
                healthPacks.forEach(pack => {
                    scene.remove(pack);
                    if (pack.userData && pack.userData.shadowPlane) {
                        scene.remove(pack.userData.shadowPlane);
                    }
                });
                healthPacks = [];
                
                // Clear existing projectiles
                projectiles.forEach(projectile => scene.remove(projectile));
                projectiles = [];
                
                // Clear geometry merging arrays
                streetlightComponents = { bases: [], poles: [], topBoxes: [] };
                treeComponents = { trunks: [], leaves: [] };
                plantComponents = []; // Clear plant geometries
                streetSignComponents = { mainSt: [], oakAve: [], elmRd: [], parkBlvd: [] }; // Clear street sign geometries
                
                // Force regeneration of trees with new specifications by clearing cubes
                worldCubes = [];
                
                // Generate grid of concrete squares if cubes array is empty
                if (!worldCubes || worldCubes.length === 0) {
                    const worldSize = getWorldSize();
                    const squareSize = BLOCK_SIZE;
                    const spacing = BLOCK_SPACING;

                    // Calculate grid bounds to cover the ground plane
                    const gridStart = -Math.floor(worldSize / spacing) * spacing / 2;
                    const gridEnd = Math.floor(worldSize / spacing) * spacing / 2;

                    let cubeId = 0;
                    const allSquares = [];

                    // First, create all concrete squares
                    for (let x = gridStart; x <= gridEnd; x += spacing) {
                        for (let z = gridStart; z <= gridEnd; z += spacing) {
                            const squareData = {
                                id: `concrete_square_${cubeId++}`,
                                x: x,
                                y: 0, // On ground level
                                z: z,
                                size: squareSize,
                                height: 1, // Thin concrete square
                                color: '#808080', // Grey concrete color
                                asset: 'concrete_texture'
                            };
                            worldCubes.push(squareData);
                            allSquares.push({ x, z, squareData });
                        }
                    }
                    
                    // Then, add tall cuboids to 80% of the squares (chosen randomly)
                    const numCuboids = Math.floor(allSquares.length * 0.8);
                    const shuffledSquares = [...allSquares].sort(() => Math.random() - 0.5);
                    
                    for (let i = 0; i < numCuboids; i++) {
                        const square = shuffledSquares[i];
                        const cuboidData = {
                            id: `concrete_cuboid_${cubeId++}`,
                            x: square.x,
                            y: 1.55, // Lift buildings to sit on top of curb interiors (curb height 1 + curb interior height 0.1 + half building base 15 = 1.55)
                            z: square.z,
                            size: 30, // 30x30 units
                            height: 90, // 90 units tall
                            color: '#404040', // Dark grey color (no texture yet)
                            asset: null // No texture, just dark grey color
                        };
                        worldCubes.push(cuboidData);
                    }
                    
                    // Add curb interiors (40x40x0.1 cuboids centered within each curb)
                    // Track which squares have buildings for park identification
                    const squaresWithBuildings = new Set();
                    for (let i = 0; i < numCuboids; i++) {
                        const square = shuffledSquares[i];
                        squaresWithBuildings.add(`${square.x}_${square.z}`);
                    }
                    
                    allSquares.forEach(square => {
                        const hasBuilding = squaresWithBuildings.has(`${square.x}_${square.z}`);
                        const curbInteriorData = {
                            id: `curb_interior_${cubeId++}`,
                            x: square.x, // Same X position as curb (centered)
                            y: 1.05, // Height 0.1 / 2 = 0.05, plus curb height 1 = 1.05
                            z: square.z, // Same Z position as curb (centered)
                            size: 40, // 40x40 units
                            height: 0.1, // 0.1 units tall
                            color: hasBuilding ? '#2F2F2F' : '#4CAF50', // Dark grey for building areas, green for parks
                            asset: hasBuilding ? null : 'new_grass_texture' // Grass texture for parks
                        };
                        worldCubes.push(curbInteriorData);
                        
                        // If this is a park (no building), place 4 trees in the corners
                        if (!hasBuilding) {
                            const parkHalfSize = 40 / 2; // 20 units (half of 40x40 park)
                            const treeMargin = 6; // 6 units from the edge of the grass
                            
                            // Calculate the four corner positions for trees, pulled in 6 units from grass edges
                            const treePositions = [
                                { x: square.x - parkHalfSize + treeMargin, z: square.z - parkHalfSize + treeMargin }, // Bottom-left
                                { x: square.x + parkHalfSize - treeMargin, z: square.z - parkHalfSize + treeMargin }, // Bottom-right
                                { x: square.x - parkHalfSize + treeMargin, z: square.z + parkHalfSize - treeMargin }, // Top-left
                                { x: square.x + parkHalfSize - treeMargin, z: square.z + parkHalfSize - treeMargin }  // Top-right
                            ];
                            
                            // Generate and place trees at each corner position
                            treePositions.forEach(pos => {
                                // Trees are now handled by geometry merging - just call generateTree to collect geometries
                                // Trees should sit ON TOP of grass: curb height (1) + grass height (0.1) = 1.1
                                generateTree(pos.x, pos.z, 1.1); // Pass park height as third parameter
                            });
                            
                            // Add health pack with 50% probability in center of park
                            if (Math.random() < 0.5) {
                                spawnHealthPack(square.x, 1.1 + 0.5, square.z); // Center of park, sitting on grass
                            }
                            
                            // Generate 10 pixelated plant planes within the grassy curb interior
                            for (let i = 0; i < 10; i++) {
                                // Random position within the park bounds (avoiding trees)
                                const plantX = square.x + (Math.random() - 0.5) * (40 - 4); // Within park bounds with 2 unit margin
                                const plantZ = square.z + (Math.random() - 0.5) * (40 - 4);
                                
                                // Position plant with bottom edge aligned with TOP of grass (grass top is at 1.1, plant is 4 units tall, so center at 1.1 + 2 = 3.1)
                                const plantY = 3.1;
                                
                                // Random Y rotation
                                const plantRotation = Math.random() * Math.PI * 2;
                                
                                // Collect geometry for merging instead of creating individual meshes
                                collectPlantGeometry(plantX, plantY, plantZ, plantRotation);
                                
                                // Create duplicate plant with same scaling and texture, rotated 90 degrees around Y-axis
                                collectPlantGeometry(plantX, plantY, plantZ, plantRotation + Math.PI / 2);
                                
                                // Create 1x1 unit drop shadow for this plant (one per plant, not per duplicate)
                                const plantShadowGeometry = new THREE.PlaneGeometry(1, 1);
                                
                                // Create canvas for plant shadow gradient (same as tree shadow but smaller)
                                const plantCanvas = document.createElement('canvas');
                                plantCanvas.width = 64;
                                plantCanvas.height = 64;
                                const plantCtx = plantCanvas.getContext('2d');
                                
                                // Create radial gradient: 70% alpha black center to 0% alpha black edge (same as trees)
                                const plantGradient = plantCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
                                plantGradient.addColorStop(0, 'rgba(0, 0, 0, 0.7)'); // 70% alpha black center
                                plantGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');   // 0% alpha black edge
                                
                                // Fill canvas with gradient
                                plantCtx.fillStyle = plantGradient;
                                plantCtx.fillRect(0, 0, 64, 64);
                                
                                // Create texture from canvas
                                const plantShadowTexture = new THREE.CanvasTexture(plantCanvas);
                                plantShadowTexture.needsUpdate = true;
                                
                                // Create material with transparency
                                const plantShadowMaterial = new THREE.MeshBasicMaterial({
                                    map: plantShadowTexture,
                                    transparent: true,
                                    opacity: 1,
                                    depthWrite: false // Prevent z-fighting with ground
                                });
                                
                                // Create plant shadow plane mesh
                                const plantShadow = new THREE.Mesh(plantShadowGeometry, plantShadowMaterial);
                                plantShadow.rotation.x = -Math.PI / 2; // Rotate to lie flat on ground
                                plantShadow.position.set(plantX, 0.11, plantZ); // ABSOLUTE Y-axis position of 0.11 (same as tree shadows)
                                
                                scene.add(plantShadow);
                                treeObjects.push(plantShadow); // Add to treeObjects for cleanup
                            }
                        }
                    });
                    
                    // Add streetlights at the corners of each curb cuboid with 4 units margin
                    allSquares.forEach(square => {
                        const curbHalfSize = squareSize / 2; // 30 units (half of 60)
                        const margin = 4; // 4 units margin from curb edges
                        
                        // Calculate the four corner positions of the curb, pushed inward by margin
                        const corners = [
                            { x: square.x - curbHalfSize + margin, z: square.z - curbHalfSize + margin }, // Bottom-left corner (pushed inward)
                            { x: square.x + curbHalfSize - margin, z: square.z - curbHalfSize + margin }, // Bottom-right corner (pushed inward)
                            { x: square.x - curbHalfSize + margin, z: square.z + curbHalfSize - margin }, // Top-left corner (pushed inward)
                            { x: square.x + curbHalfSize - margin, z: square.z + curbHalfSize - margin }  // Top-right corner (pushed inward)
                        ];
                        
                        // Check if this curb has a building (is in the squaresWithBuildings set)
                        const hasBuilding = squaresWithBuildings.has(`${square.x}_${square.z}`);
                        
                        if (hasBuilding) {
                            // BUILDING CURBS: 3 streetlights + 1 random tree
                            // Choose one random corner (0-3) to be a tree instead of streetlight
                            const treeCornerIndex = Math.floor(Math.random() * 4);
                            
                            corners.forEach((corner, index) => {
                                if (index === treeCornerIndex) {
                                    // This corner gets a tree instead of a streetlight
                                    generateTree(corner.x, corner.z, 1.1); // Pass curb interior height as Y offset (1 + 0.1 = 1.1)
                                } else {
                                    // This corner gets a streetlight as normal
                                    const streetlightObj = createStreetlight(corner.x, corner.z);
                                    streetlightObjects.push(streetlightObj);
                                }
                            });
                        } else {
                            // PARK CURBS: 4 streetlights (one in each corner)
                            corners.forEach((corner, index) => {
                                // All corners get streetlights for parks
                                const streetlightObj = createStreetlight(corner.x, corner.z);
                                streetlightObjects.push(streetlightObj);
                            });
                        }
                        
                        // Add street grates on each side of the curb
                        createStreetGrates(square.x, square.z, curbHalfSize);
                    });
                    
                    // Create grey planes between adjacent curbs along Z-axis
                    createGreyPlanesBetweenCurbs(allSquares, spacing);
                    
                    // Merge streetlight static components for better GPU utilization
                    mergeStreetlightComponents();
                    
                    // Merge tree components for better GPU utilization
                    mergeTreeComponents();
                    
                    // Merge plant components for better GPU utilization
                    mergePlantComponents();

                    // Merge street sign components for better GPU utilization
                    mergeStreetSignComponents();
                    
                    console.log('Geometry merging optimization complete - improved GPU utilization');
                }
                
                // Create visual cubes from config data with geometry merging optimization
                const geometryGroups = {
                    // Curb elements (concrete texture)
                    curbs: [],
                    // Curb interiors by color
                    curbInteriorsDark: [], // Dark grey (#2F2F2F)
                    curbInteriorsGrass: [], // Green grass texture
                    // Buildings by texture
                    buildingTexture1: [], // office_building_texture
                    buildingTexture2: [], // office_building_texture_2
                    buildingTexture3: [], // office_building_texture_3
                    buildingTexture4: [], // office_building_texture_4
                    buildingsNoTexture: [] // Buildings with just color
                };
                
                // Group cubes by their texture/material type
                worldCubes.forEach(cubeData => {
                    const width = cubeData.size;
                    const height = cubeData.height || cubeData.size;
                    const depth = cubeData.sizeZ || cubeData.size;
                    
                    // Categorize cubes for merging
                    if (height <= 1 && cubeData.asset === 'concrete_texture') {
                        // Curb elements
                        geometryGroups.curbs.push(cubeData);
                    } else if (height <= 1 && cubeData.asset === 'new_grass_texture') {
                        // Grass curb interiors
                        geometryGroups.curbInteriorsGrass.push(cubeData);
                    } else if (height <= 1 && cubeData.color === '#2F2F2F') {
                        // Dark grey curb interiors
                        geometryGroups.curbInteriorsDark.push(cubeData);
                    } else if (height > 50) {
                        // Buildings - determine texture
                        const hashInput = cubeData.id + cubeData.x + cubeData.z;
                        let hash = 0;
                        for (let i = 0; i < hashInput.length; i++) {
                            const char = hashInput.charCodeAt(i);
                            hash = ((hash << 5) - hash) + char;
                            hash = hash & hash;
                        }
                        const textureIndex = Math.abs(hash) % 4;
                        
                        switch (textureIndex) {
                            case 0: geometryGroups.buildingTexture1.push(cubeData); break;
                            case 1: geometryGroups.buildingTexture2.push(cubeData); break;
                            case 2: geometryGroups.buildingTexture3.push(cubeData); break;
                            case 3: geometryGroups.buildingTexture4.push(cubeData); break;
                        }
                    } else {
                        // Other buildings without texture
                        geometryGroups.buildingsNoTexture.push(cubeData);
                    }
                });
                
                // Helper function to create merged geometry for a group
                function createMergedGeometry(cubeGroup, materialConfig) {
                    if (cubeGroup.length === 0) return null;
                    
                    const geometries = [];
                    
                    cubeGroup.forEach(cubeData => {
                        const width = cubeData.size;
                        const height = cubeData.height || cubeData.size;
                        const depth = cubeData.sizeZ || cubeData.size;

                        const geometry = new THREE.BoxGeometry(width, height, depth);
                        
                        // Position the geometry
                        const yPosition = cubeData.y !== undefined ? cubeData.y + height / 2 : height / 2;
                        geometry.translate(cubeData.x, yPosition, cubeData.z);
                        
                        geometries.push(geometry);
                    });
                    
                    // Merge all geometries in this group
                    const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
                    
                    // Clean up individual geometries
                    geometries.forEach(geo => geo.dispose());
                    
                    console.log(`Merged ${cubeGroup.length} cubes into single optimized mesh`);
                    return mergedGeometry;
                }
                
                // Helper function to create material
                function createMaterial(config) {
                    if (config.texture) {
                        const assetInfo = lib.getAsset(config.texture);
                        if (assetInfo) {
                            const texture = new THREE.TextureLoader().load(assetInfo.url);
                            texture.magFilter = THREE.NearestFilter;
                            texture.minFilter = THREE.NearestFilter;
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            if (config.repeat) {
                                texture.repeat.set(config.repeat.x, config.repeat.y);
                            }
                            return new THREE.MeshLambertMaterial({ map: texture, color: config.color });
                        }
                    }
                    // Fallback to color
                    return new THREE.MeshLambertMaterial({ color: config.color });
                }
                
                // Create merged meshes for each group
                
                // 1. Curb elements (concrete texture)
                const curbGeometry = createMergedGeometry(geometryGroups.curbs, {});
                if (curbGeometry) {
                    const curbMaterial = createMaterial({ 
                        texture: 'concrete_texture', 
                        repeat: { x: 6, y: 6 },
                        color: 0xffffff
                    });
                    const curbMesh = new THREE.Mesh(curbGeometry, curbMaterial);
                    curbMesh.castShadow = true;
                    curbMesh.receiveShadow = true;
                    scene.add(curbMesh);
                    cubeObjects.push({ mesh: curbMesh, data: { id: 'merged_curbs', merged: true } });
                }
                
                // 2. Dark grey curb interiors
                const curbInteriorDarkGeometry = createMergedGeometry(geometryGroups.curbInteriorsDark, {});
                if (curbInteriorDarkGeometry) {
                    const curbInteriorDarkMaterial = createMaterial({ color: 0x2F2F2F });
                    const curbInteriorDarkMesh = new THREE.Mesh(curbInteriorDarkGeometry, curbInteriorDarkMaterial);
                    curbInteriorDarkMesh.castShadow = true;
                    curbInteriorDarkMesh.receiveShadow = true;
                    scene.add(curbInteriorDarkMesh);
                    cubeObjects.push({ mesh: curbInteriorDarkMesh, data: { id: 'merged_curb_interiors_dark', merged: true } });
                }
                
                // 3. Grass curb interiors
                const curbInteriorGrassGeometry = createMergedGeometry(geometryGroups.curbInteriorsGrass, {});
                if (curbInteriorGrassGeometry) {
                    // Parks are 40x40 units, use 1 repeat per 8 units (same density as roads)
                    const curbInteriorGrassMaterial = createMaterial({
                        texture: 'new_grass_texture',
                        repeat: { x: 5, y: 5 },
                        color: 0x888888
                    });
                    const curbInteriorGrassMesh = new THREE.Mesh(curbInteriorGrassGeometry, curbInteriorGrassMaterial);
                    curbInteriorGrassMesh.castShadow = true;
                    curbInteriorGrassMesh.receiveShadow = true;
                    scene.add(curbInteriorGrassMesh);
                    cubeObjects.push({ mesh: curbInteriorGrassMesh, data: { id: 'merged_curb_interiors_grass', merged: true } });
                }
                
                // 4. Buildings by texture
                const buildingConfigs = [
                    { group: geometryGroups.buildingTexture1, texture: 'office_building_texture', id: 'merged_buildings_1' },
                    { group: geometryGroups.buildingTexture2, texture: 'office_building_texture_2', id: 'merged_buildings_2' },
                    { group: geometryGroups.buildingTexture3, texture: 'office_building_texture_3', id: 'merged_buildings_3' },
                    { group: geometryGroups.buildingTexture4, texture: 'office_building_texture_4', id: 'merged_buildings_4' }
                ];
                
                buildingConfigs.forEach(config => {
                    const buildingGeometry = createMergedGeometry(config.group, {});
                    if (buildingGeometry) {
                        const buildingMaterial = createMaterial({ 
                            texture: config.texture,
                            repeat: { x: 1, y: 3 },
                            color: 0xffffff
                        });
                        const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        buildingMesh.castShadow = true;
                        buildingMesh.receiveShadow = true;
                        scene.add(buildingMesh);
                        cubeObjects.push({ mesh: buildingMesh, data: { id: config.id, merged: true } });
                    }
                });
                
                // 5. Buildings without texture
                const buildingNoTextureGeometry = createMergedGeometry(geometryGroups.buildingsNoTexture, {});
                if (buildingNoTextureGeometry) {
                    const buildingNoTextureMaterial = createMaterial({ color: 0x404040 });
                    const buildingNoTextureMesh = new THREE.Mesh(buildingNoTextureGeometry, buildingNoTextureMaterial);
                    buildingNoTextureMesh.castShadow = true;
                    buildingNoTextureMesh.receiveShadow = true;
                    scene.add(buildingNoTextureMesh);
                    cubeObjects.push({ mesh: buildingNoTextureMesh, data: { id: 'merged_buildings_no_texture', merged: true } });
                }
            } catch (error) {
                console.log('Error in createCubes: ' + error.message);
                // Reset cubes to empty array on error
                worldCubes = [];
            }
            
            // Position the key light 20 units above the tallest building at a ground plane corner
            positionKeyLight();
        }

        function positionKeyLight() {
            // Directional light positioning is now handled by updateDirectionalLight()
            // This function is no longer needed but kept for compatibility
            if (window.worldLight) {
                console.log('Directional light will follow player - initial positioning handled by updateDirectionalLight()');
            }
        }

        function updateCamera() {
            // Handle car camera
            if (gameState === 'driving' && currentCar) {
                updateCarCamera();
                updateDirectionalLight(); // Update light for car mode too
                return;
            }
            
            if (!character) return;
            
            // Variable camera distance with zoom controls
            const baseHeight = 40; // Base distance (current distance)
            const zoomMultiplier = cameraZoomLevel; // Use the global zoom level variable
            const height = baseHeight * zoomMultiplier;
            const angle = Math.PI / 12; // 15 degrees in radians (π/12)
            
            // Position camera above and slightly behind player - NO BOUNCING
            const offsetDistance = height * Math.sin(angle); // Fixed: Math.sin instead of Math.Sin
            const actualHeight = height * Math.cos(angle); // Actual vertical height
            
            // Camera looks down the Z-axis (towards positive Z) - use base character position without bouncing
            const x = character.position.x;
            const z = character.position.z - offsetDistance; // Offset towards negative Z
            // Use character's ground height instead of current bouncing position
            const baseY = character.userData.groundHeight + 0.675; // Character base height above ground
            const y = baseY + actualHeight;
            
            // Apply camera shake if active
            let shakeX = 0, shakeY = 0, shakeZ = 0;
            if (cameraShakeIntensity > 0) {
                shakeX = (Math.random() - 0.5) * cameraShakeIntensity * 2;
                shakeY = (Math.random() - 0.5) * cameraShakeIntensity * 2;
                shakeZ = (Math.random() - 0.5) * cameraShakeIntensity * 2;
            }

            camera.position.set(x + shakeX, y + shakeY, z + shakeZ);

            // Look at point slightly ahead of character along Z-axis - also use base position
            const lookAtX = character.position.x + shakeX * 0.5;
            const lookAtY = baseY + shakeY * 0.5; // Use base position instead of bouncing position
            const lookAtZ = character.position.z + 5 + shakeZ * 0.5; // Look ahead along Z-axis

            camera.lookAt(lookAtX, lookAtY, lookAtZ);
            
            // Update directional light to follow player
            updateDirectionalLight();
        }
        
        function updateCarCamera() {
            if (!currentCar) return;
            
            // Variable camera distance with zoom controls - DOUBLE the distance when driving
            const baseHeight = 40 * 2; // Double the base distance (was 40, now 80)
            const zoomMultiplier = cameraZoomLevel; // Use the global zoom level variable
            const height = baseHeight * zoomMultiplier;
            const angle = Math.PI / 12; // 15 degrees in radians (π/12)
            
            // Position camera above and slightly behind car - NO BOUNCING
            const offsetDistance = height * Math.sin(angle); // Horizontal offset from tilt
            const actualHeight = height * Math.cos(angle); // Actual vertical height
            
            // Camera looks down the Z-axis (towards positive Z) - use base car position without jittering
            const x = currentCar.position.x;
            const z = currentCar.position.z - offsetDistance; // Offset towards negative Z
            // Use a fixed height above the car's base position instead of following jittering
            const baseCarY = 0; // Cars sit on ground level
            const y = baseCarY + actualHeight;
            
            camera.position.set(x, y, z);
            
            // Look at point slightly ahead of car along Z-axis - also use base position
            const lookAtX = currentCar.position.x;
            const lookAtY = baseCarY; // Use base position instead of jittering position
            const lookAtZ = currentCar.position.z + 5; // Look ahead along Z-axis
            
            camera.lookAt(lookAtX, lookAtY, lookAtZ);
        }
        
        function updateDirectionalLight() {
            if (!window.worldLight || !character) return;
            
            // Get player position
            const playerX = gameState === 'driving' && currentCar ? currentCar.position.x : character.position.x;
            const playerZ = gameState === 'driving' && currentCar ? currentCar.position.z : character.position.z;
            
            // Position light 100 units above and 50 units away diagonally from player
            const lightX = playerX + 50; // 50 units away diagonally (X direction)
            const lightZ = playerZ + 50; // 50 units away diagonally (Z direction)  
            const lightY = 100; // 100 units above player
            
            window.worldLight.position.set(lightX, lightY, lightZ);
            
            // Make light look at the player position
            window.worldLight.target.position.set(playerX, 0, playerZ);
            window.worldLight.target.updateMatrixWorld();
        }

        // Enhanced 3-layer grid-based collision detection
        function checkCollisions(newX, newZ, newY) {
            const characterRadius = 0.5625; // 0.5 * 1.125 = 0.5625
            let groundHeight = 0;
            let canMove = true;
            let stepUp = false;
            let stepUpHeight = 0;
            
            // Check world boundary collision - prevent walking past ground plane edges
            // Allow positions beyond boundary if on a dock
            const worldBoundary = getWorldBoundary();
            if ((Math.abs(newX) > worldBoundary - characterRadius || Math.abs(newZ) > worldBoundary - characterRadius) && !isOnDock(newX, newZ)) {
                canMove = false;
                return { canMove, groundHeight: 0, stepUp: false, stepUpHeight: 0.675 };
            }
            
            // Grid-based collision detection for 3 layers
            const gridSpacing = 90; // 90 units between curb centers
            const curbSize = 60; // 60x60 unit curbs
            const curbHalfSize = curbSize / 2; // 30 units
            const curbInteriorSize = 40; // 40x40 unit curb interiors
            const curbInteriorHalfSize = curbInteriorSize / 2; // 20 units
            
            // Calculate which grid cell the player is in
            const gridX = Math.round(newX / gridSpacing) * gridSpacing;
            const gridZ = Math.round(newZ / gridSpacing) * gridSpacing;
            
            // Check distances from grid center
            const distFromCurbCenterX = Math.abs(newX - gridX);
            const distFromCurbCenterZ = Math.abs(newZ - gridZ);
            
            let playerLocation = 0; // 0 = road, 1 = curb, 2 = curb interior
            
            // Check curb interior first (innermost layer)
            if (distFromCurbCenterX <= curbInteriorHalfSize && distFromCurbCenterZ <= curbInteriorHalfSize) {
                // Player is within curb interior square (40x40)
                playerLocation = 2;
                groundHeight = 1.1; // Curb interior height (curb 1 + interior 0.1)
                stepUpHeight = 1.1 + 0.675; // FIXED: Curb interior height + character base height = 1.775
            } else if (distFromCurbCenterX <= curbHalfSize && distFromCurbCenterZ <= curbHalfSize) {
                // Player is within curb square but outside curb interior (60x60 but not 40x40)
                playerLocation = 1;
                groundHeight = 1; // Curb height
                stepUpHeight = 1 + 0.675; // FIXED: Curb height + character base height = 1.675
            } else {
                // Player is on the road (outside curb square)
                playerLocation = 0;
                groundHeight = 0; // Road level
                stepUpHeight = 0.675; // Character base height above road
            }
            
            // Store the location state for external access
            if (character && character.userData) {
                character.userData.isOnCurb = playerLocation; // 0=road, 1=curb, 2=curb interior
            }
            
            // Check collision with tall buildings (height > 50) - blocks movement but doesn't affect Y-axis
            // Use the config data directly instead of mesh objects since meshes are merged
            for (const cube of worldCubes) {
                const cubeHeight = cube.height || cube.size;
                
                // Only check collision with tall buildings
                if (cubeHeight > 50) {
                    const cubeHalfSizeX = cube.size / 2;
                    const cubeHalfSizeZ = (cube.sizeZ || cube.size) / 2;

                    // Check if character is within building's horizontal bounds
                    const distX = Math.abs(newX - cube.x);
                    const distZ = Math.abs(newZ - cube.z);

                    if (distX < cubeHalfSizeX + characterRadius && distZ < cubeHalfSizeZ + characterRadius) {
                        // Character is colliding with a tall building - block movement
                        canMove = false;
                        break;
                    }
                }
            }
            
            return { 
                canMove, 
                groundHeight, 
                stepUp, 
                stepUpHeight: stepUpHeight
            };
        }

        function animateWalk() {
            animateWalkForCharacter(character);
        }

        // Utility function to remap joystick input magnitude to speed multiplier
        // This gives players full speed with less stick deflection
        function remapJoystickSpeed(inputMagnitude) {
            // 30% distance (0.3) → 30% speed (0.3)
            // 60% distance (0.6) → 100% speed (1.0)
            // 60%+ distance → 100% speed (1.0)
            if (inputMagnitude <= 0.6) {
                // Linear remap from 0.3-0.6 input to 0.3-1.0 output
                return 0.3 + ((inputMagnitude - 0.3) / 0.3) * 0.7;
            } else {
                // Cap at 100% speed
                return 1.0;
            }
        }







        function updateMovement(deltaTime) {
            if (!character || playerInputDisabled) return;
            if (playerInputDisabled) return;
            
            // Handle player physics if flying from car collision
            if (character.userData.isFlying) {
                updatePlayerPhysics(deltaTime);
                return; // Skip normal movement while flying
            }
            
            // Handle car driving mode
            if (gameState === 'driving' && currentCar) {
                // CRITICAL: Ensure player character is COMPLETELY INVISIBLE while driving
                if (character.visible) {
                    character.visible = false;
                    console.log('EMERGENCY: Player was visible while driving - forcing invisible');
                }
                if (shadowPlane && shadowPlane.visible) {
                    shadowPlane.visible = false;
                    console.log('EMERGENCY: Player shadow was visible while driving - forcing invisible');
                }
                
                updateCarDriving(deltaTime);
                updateUIForGameState(); // Update UI when driving
                return; // Skip normal movement while driving
            }
            
            // Handle player fade out when entering car
            if (character.userData.isFadingOut) {
                updatePlayerFadeOut(deltaTime);
                return; // Skip normal movement while fading out
            }
            
            // Handle player fade in when exiting car
            if (character.userData.isFadingIn) {
                updatePlayerFadeIn(deltaTime);
                // Don't return - allow normal movement while fading in
            }

            // Update UI for walking state
            updateUIForGameState();

            // Handle kickback physics with gradual slowdown
            if (character.userData.hasKickbackVelocity && character.userData.velocity) {
                const decelerationRate = 8; // Gradual slowdown rate
                
                // Apply kickback movement
                const kickbackMoveX = character.userData.velocity.x * deltaTime;
                const kickbackMoveZ = character.userData.velocity.z * deltaTime;
                
                const newKickbackX = character.position.x + kickbackMoveX;
                const newKickbackZ = character.position.z + kickbackMoveZ;
                
                // Check collision for kickback movement
                const kickbackCollision = checkCollisions(newKickbackX, newKickbackZ, character.position.y);
                const kickbackOnWater = isOnWater(newKickbackX, newKickbackZ);

                if (kickbackCollision.canMove && !kickbackOnWater) {
                    character.position.x = newKickbackX;
                    character.position.z = newKickbackZ;
                    character.position.y = kickbackCollision.stepUpHeight;
                    character.userData.groundHeight = kickbackCollision.groundHeight;
                }
                
                // Gradually reduce kickback velocity
                character.userData.velocity.x *= (1 - decelerationRate * deltaTime);
                character.userData.velocity.z *= (1 - decelerationRate * deltaTime);
                
                // Stop kickback when velocity is very small
                if (Math.abs(character.userData.velocity.x) < 0.01 && Math.abs(character.userData.velocity.z) < 0.01) {
                    character.userData.velocity.x = 0;
                    character.userData.velocity.z = 0;
                    character.userData.hasKickbackVelocity = false;
                }
            }

            let moveSpeed = PLAYER_MOVE_SPEED;

            if (DEBUG_FAST_MOVEMENT && (keys['ShiftLeft'] || keys['ShiftRight'])) {
                moveSpeed *= 4;
            }

            let moveX = 0;
            let moveZ = 0;

            // Block all movement during dialog
            if (isDialogActive()) {
                // Clear any active movement state
                isMoving = false;
                return;
            }

            // Mobile joystick input - direct movement in joystick direction
            let joystickMovementAngle = null;
            if (joystickActive) {
                // Calculate target direction from joystick input
                const inputMagnitude = Math.sqrt(joystickVector.x * joystickVector.x + joystickVector.y * joystickVector.y);

                if (inputMagnitude > 0.3) { // Only respond to significant input
                    // Calculate movement angle from joystick direction
                    // Note: joystickVector.y is negative for up, positive for down
                    // FIXED: Reverse left/right by negating joystickVector.x
                    joystickMovementAngle = Math.atan2(-joystickVector.x, -joystickVector.y);

                    // Only update facing direction if NOT using aiming joystick
                    if (!aimingJoystickDragging) {
                        character.userData.facingAngle = joystickMovementAngle;
                        character.rotation.y = character.userData.facingAngle;
                        characterFacingAngle = character.userData.facingAngle;
                    }

                    // Move in joystick direction (independent of facing when aiming)
                    moveZ = remapJoystickSpeed(inputMagnitude);
                }

                // No separate left/right movement - character moves in joystick direction
                moveX = 0;
            }
            
            // Desktop keyboard input - WASD for direct movement in cardinal directions
            let keyboardMoveX = 0;
            let keyboardMoveZ = 0;
            let keyboardMovementAngle = null;

            // Collect keyboard input for all directions - LEFT/RIGHT REVERSED
            if (keys['KeyW'] || keys['ArrowUp']) keyboardMoveZ += 1;    // North
            if (keys['KeyS'] || keys['ArrowDown']) keyboardMoveZ -= 1;  // South
            if (keys['KeyA'] || keys['ArrowLeft']) keyboardMoveX += 1;  // East (REVERSED)
            if (keys['KeyD'] || keys['ArrowRight']) keyboardMoveX -= 1; // West (REVERSED)

            // If there's keyboard input, set character direction and movement
            if (keyboardMoveX !== 0 || keyboardMoveZ !== 0) {
                // Calculate movement angle from keyboard input
                keyboardMovementAngle = Math.atan2(keyboardMoveX, keyboardMoveZ);

                // Only update facing direction if NOT using aiming joystick
                if (!aimingJoystickDragging) {
                    character.userData.facingAngle = keyboardMovementAngle;
                    character.rotation.y = character.userData.facingAngle;
                    characterFacingAngle = character.userData.facingAngle;
                }

                // Move in keyboard direction (independent of facing when aiming)
                const inputMagnitude = Math.sqrt(keyboardMoveX * keyboardMoveX + keyboardMoveZ * keyboardMoveZ);
                moveZ = Math.min(inputMagnitude, 1); // Normalize diagonal movement
            }

            // Aiming joystick - controls facing direction independently
            if (aimingJoystickActive && aimingJoystickDragging) {
                const aimMagnitude = Math.sqrt(
                    aimingJoystickVector.x * aimingJoystickVector.x +
                    aimingJoystickVector.y * aimingJoystickVector.y
                );

                if (aimMagnitude > 0.3) { // Only respond to significant aiming input
                    const facingAngle = Math.atan2(-aimingJoystickVector.x, -aimingJoystickVector.y);

                    character.userData.facingAngle = facingAngle;
                    character.rotation.y = facingAngle;
                    characterFacingAngle = facingAngle;
                }
            }

            // Character movement - relative to character's facing vector
            if (moveX !== 0 || moveZ !== 0) {
                // When aiming joystick is active, use movement angle from input source
                // Otherwise use facing angle (normal coupled movement)
                let movementAngle = character.userData.facingAngle;
                if (aimingJoystickDragging) {
                    if (joystickMovementAngle !== null) {
                        movementAngle = joystickMovementAngle;
                    } else if (keyboardMovementAngle !== null) {
                        movementAngle = keyboardMovementAngle;
                    }
                }

                // Transform movement input relative to movement direction
                // Forward/backward (moveZ) is along movement direction
                // Left/right (moveX) is perpendicular to movement direction (90 degrees rotated)
                const worldMoveX = moveX * Math.cos(movementAngle + Math.PI/2) + moveZ * Math.sin(movementAngle);
                const worldMoveZ = moveX * Math.sin(movementAngle + Math.PI/2) + moveZ * Math.cos(movementAngle);
                
                // Character rotation is now handled consistently for both keyboard and joystick above
                // No need for separate joystick rotation logic since joystick now inherits keyboard functionality
                
                // Sync global facing angle with character
                characterFacingAngle = character.userData.facingAngle;
                
                const worldVelX = worldMoveX * moveSpeed;
                const worldVelZ = worldMoveZ * moveSpeed;
                
                const newX = character.position.x + worldVelX * deltaTime;
                const newZ = character.position.z + worldVelZ * deltaTime;

                // Try full movement, with sliding if blocked by water
                let finalX, finalZ;

                if (!isOnWater(newX, newZ)) {
                    // Full movement is valid
                    finalX = newX;
                    finalZ = newZ;
                } else {
                    // Would hit water - try sliding along edges
                    const currentX = character.position.x;
                    const currentZ = character.position.z;

                    // Try X-only movement (slide along Z edge)
                    if (!isOnWater(newX, currentZ)) {
                        finalX = newX;
                        finalZ = currentZ;
                    } else if (!isOnWater(currentX, newZ)) {
                        // Try Z-only movement (slide along X edge)
                        finalX = currentX;
                        finalZ = newZ;
                    } else {
                        // Both axes blocked - don't move
                        finalX = currentX;
                        finalZ = currentZ;
                    }
                }

                // Apply world boundary clamping if not on dock
                const worldBoundary = getWorldBoundary();
                const characterRadius = 0.5625;

                if (!isOnDock(finalX, finalZ)) {
                    finalX = Math.abs(finalX) > worldBoundary - characterRadius
                        ? Math.sign(finalX) * (worldBoundary - characterRadius)
                        : finalX;
                    finalZ = Math.abs(finalZ) > worldBoundary - characterRadius
                        ? Math.sign(finalZ) * (worldBoundary - characterRadius)
                        : finalZ;
                }

                const collision = checkCollisions(finalX, finalZ, character.position.y);
                const finalOnWater = isOnWater(finalX, finalZ);

                // If blocked by building, try sliding along walls
                if (!collision.canMove || finalOnWater) {
                    const currentX = character.position.x;
                    const currentZ = character.position.z;

                    // Try X-only movement (slide along Z wall)
                    const collisionX = checkCollisions(finalX, currentZ, character.position.y);
                    const onWaterX = isOnWater(finalX, currentZ);

                    if (collisionX.canMove && !onWaterX) {
                        finalX = finalX;
                        finalZ = currentZ;
                    } else {
                        // Try Z-only movement (slide along X wall)
                        const collisionZ = checkCollisions(currentX, finalZ, character.position.y);
                        const onWaterZ = isOnWater(currentX, finalZ);

                        if (collisionZ.canMove && !onWaterZ) {
                            finalX = currentX;
                            finalZ = finalZ;
                        } else {
                            // Both axes blocked - don't move
                            finalX = currentX;
                            finalZ = currentZ;
                        }
                    }
                }

                // Apply final position (either original if no collision, or slid position)
                character.position.x = finalX;
                character.position.z = finalZ;

                // Update character height based on ground/curb collision at final position
                const finalCollision = checkCollisions(finalX, finalZ, character.position.y);
                character.position.y = finalCollision.stepUpHeight;
                character.userData.groundHeight = finalCollision.groundHeight;

                // Play footstep sound
                const now = Date.now();
                if (now - lastFootstepTime > 400 && character.userData.onGround) {
                    playSound("footstep_grass");
                    lastFootstepTime = now;
                }

                isMoving = true;

                // Update walk animation
                character.userData.walkTime += deltaTime * 8;
                animateWalk();

                // Add smooth wave-like bouncing while moving (0.2 units)
                const bounceAmount = Math.sin(character.userData.walkTime * 2) * 0.2;
                character.position.y += bounceAmount;
            } else {
                isMoving = false;
                // Reset limbs to neutral position when not moving, but use the walk animation function for consistency
                if (character.userData) {
                    // Use the walk animation function to handle gun animation consistently
                    animateWalk();
                    
                    // Reset legs to neutral when not moving
                    character.userData.leftLegPivot.rotation.x = 0;
                    character.userData.rightLegPivot.rotation.x = 0;
                    character.userData.leftLowerLegPivot.rotation.x = 0;
                    character.userData.rightLowerLegPivot.rotation.x = 0;
                }
                
                // Even when not moving, check ground height and adjust position
                const collision = checkCollisions(character.position.x, character.position.z, character.position.y);
                character.position.y = collision.stepUpHeight;
                character.userData.groundHeight = collision.groundHeight;
            }
            
            // Update gun state machine
            if (gameState === 'walking') {
                updateGunStateMachine();
            }

            // Update death rotation if player is dead (on ground)
            if (playerHealth <= 0 && !character.userData.isFlying) {
                updateDeathRotation(character, deltaTime);
            }

            // Keep character grounded (unless flying)
            character.userData.onGround = true;
            if (!character.userData.isFlying) {
                // Don't reset velocity if we have kickback velocity
                if (!character.userData.hasKickbackVelocity) {
                    character.userData.velocity = { x: 0, y: 0, z: 0 };
                }
            }
        }
        
        function updatePlayerPhysics(deltaTime) {
            if (!character.userData.velocity || !character.userData.isFlying) return;

            const gravity = -26; // 1.3x stronger gravity (was -20, now -26)

            // Update velocity with gravity
            character.userData.velocity.y += gravity * deltaTime;

            // Update position based on velocity
            character.position.x += character.userData.velocity.x * deltaTime;
            character.position.y += character.userData.velocity.y * deltaTime;
            character.position.z += character.userData.velocity.z * deltaTime;

            // Update death rotation animation if active
            updateDeathRotation(character, deltaTime);

            // Add Y-axis rotation while flying (only if not dead)
            if (playerHealth > 0) {
                if (!character.userData.rotationSpeed) {
                    character.userData.rotationSpeed = 2 + Math.random() * 2; // 2-4 radians/sec
                }
                character.rotation.y += character.userData.rotationSpeed * deltaTime;
            }
            
            // Spawn continuous particle stream in opposite direction of movement
            if (!character.userData.lastParticleTime) {
                character.userData.lastParticleTime = 0;
            }
            character.userData.lastParticleTime += deltaTime;
            
            // Spawn particles every 0.05 seconds (20 particles per second)
            if (character.userData.lastParticleTime >= 0.05) {
                character.userData.lastParticleTime = 0;
                spawnTrailParticle();
            }
            
            // Check for ground collision
            const collision = checkCollisions(character.position.x, character.position.z, character.position.y);
            const groundHeight = collision.stepUpHeight;
            
            if (character.position.y <= groundHeight && character.userData.velocity.y <= 0) {
                // Player has landed
                character.position.y = groundHeight;
                
                // Initialize bounce count if not present
                if (character.userData.bounceCount === undefined) {
                    character.userData.bounceCount = 0;
                }
                
                // Only allow one bounce after landing
                if (character.userData.bounceCount === 0) {
                    // First bounce - calculate bounce velocity (30% of impact velocity, minimum 5 units/sec)
                    const impactVelocity = Math.abs(character.userData.velocity.y);
                    const bounceVelocity = Math.max(impactVelocity * 0.3, 5);
                    character.userData.velocity.y = bounceVelocity;
                    
                    // Reduce horizontal velocity by 20% on bounce
                    character.userData.velocity.x *= 0.8;
                    character.userData.velocity.z *= 0.8;
                    
                    character.userData.bounceCount = 1; // Mark that we've bounced once
                } else {
                    // Second landing - stop bouncing and regain control
                    character.userData.isFlying = false;
                    character.userData.onGround = true;
                    character.userData.velocity = { x: 0, y: 0, z: 0 };
                    character.userData.groundHeight = collision.groundHeight;
                    character.userData.rotationSpeed = 0; // Stop rotation
                    character.userData.bounceCount = 0; // Reset bounce count for next time

                    // Check if player should die after landing
                    if (character.userData.shouldDieOnLanding) {
                        character.userData.shouldDieOnLanding = false;
                        console.log('Player landed after fatal damage - triggering death');
                        handlePlayerDeath();
                    }
                }
            }
            
            // Prevent player from going through world boundaries while flying
            const worldBoundary = getWorldBoundary();
            const characterRadius = 0.5625;

            if (Math.abs(character.position.x) > worldBoundary - characterRadius) {
                character.position.x = Math.sign(character.position.x) * (worldBoundary - characterRadius);
                character.userData.velocity.x = 0; // Stop horizontal movement at boundary
            }
            if (Math.abs(character.position.z) > worldBoundary - characterRadius) {
                character.position.z = Math.sign(character.position.z) * (worldBoundary - characterRadius);
                character.userData.velocity.z = 0; // Stop horizontal movement at boundary
            }
        }
        
        function spawnTrailParticle() {
            if (!character || !character.userData.isFlying) return;
            
            // Create small red/maroon cube particle
            const particleGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            
            // Random red/maroon color
            const redIntensity = 0.7 + Math.random() * 0.3; // 0.7 to 1.0
            const maroonComponent = Math.random() * 0.3; // 0 to 0.3 for maroon tint
            const particleColor = new THREE.Color(redIntensity, maroonComponent, maroonComponent);
            
            const particleMaterial = new THREE.MeshLambertMaterial({ color: particleColor });
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            // Position at player's center
            particle.position.set(character.position.x, character.position.y, character.position.z);
            
            // Velocity in opposite direction of player movement
            const oppositeVelX = -character.userData.velocity.x * 0.5; // Half the player's velocity
            const oppositeVelZ = -character.userData.velocity.z * 0.5;
            const oppositeVelY = -character.userData.velocity.y * 0.3 + Math.random() * 2 - 1; // Slight randomness
            
            // Add some random spread
            const spreadAmount = 2;
            const randomVelX = oppositeVelX + (Math.random() - 0.5) * spreadAmount;
            const randomVelZ = oppositeVelZ + (Math.random() - 0.5) * spreadAmount;
            const randomVelY = oppositeVelY + (Math.random() - 0.5) * spreadAmount;
            
            particle.userData = {
                isParticle: true,
                velocity: {
                    x: randomVelX,
                    y: randomVelY,
                    z: randomVelZ
                },
                life: 1.5, // 1.5 second lifetime
                maxLife: 1.5,
                baseScale: 1.0,
                scaleTime: Math.random() * Math.PI * 2,
                flickerTime: Math.random() * Math.PI * 2
            };
            
            scene.add(particle);
            
            // Store particles for cleanup
            if (!window.gameParticles) window.gameParticles = [];
            window.gameParticles.push(particle);
        }
        
                function updateCarDriving(deltaTime) {
            if (!currentCar) return;

            // Block car input during dialog
            if (isDialogActive()) return;

            // Block car input during physics mode (collision response)
            if (currentCar.userData.inPhysicsMode) return;

            const maxSpeed = 30; // Maximum forward speed
            const maxReverseSpeed = 15; // Maximum reverse speed (half of max forward speed)
            const acceleration = 20; // Acceleration rate
            const deceleration = 15; // Natural deceleration when no input
            const brakeDeceleration = 40; // Aggressive braking deceleration
            const minTurnSpeed = 2; // Minimum speed needed to turn
            
            let accelerateInput = 0;
            let reverseInput = 0;
            let turnInput = 0;
            let dynamicMaxSpeed = maxSpeed; // Will be reduced during sharp turns
            let useAutoSteering = false; // Track if using joystick auto-steering

            // Handle input for car driving - joystick uses always-forward directional control
            let currentTurnInput = 0;
            if (joystickActive) {
                const inputMagnitude = Math.sqrt(joystickVector.x * joystickVector.x + joystickVector.y * joystickVector.y);

                if (inputMagnitude > 0.3) {
                    // Calculate target direction from joystick
                    const targetDirection = Math.atan2(-joystickVector.x, -joystickVector.y);

                    // Calculate angle difference (shortest path)
                    let angleDiff = targetDirection - currentCar.rotation.y;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                    // Auto-steer towards target direction with momentum-based turning
                    const dampingFactor = 3.0; // How aggressive turns are
                    const maxTurnRate = 2.5; // Maximum angular velocity (rad/s)
                    const accelerationRate = 8.0; // How fast to build up turn rate

                    // Calculate target angular velocity based on angle difference (damping)
                    const targetAngularVelocity = angleDiff * dampingFactor;

                    // Clamp target velocity to max turn rate
                    const clampedTarget = Math.max(-maxTurnRate, Math.min(maxTurnRate, targetAngularVelocity));

                    // Smoothly accelerate towards target velocity
                    currentCar.userData.angularVelocity +=
                        (clampedTarget - currentCar.userData.angularVelocity) * accelerationRate * deltaTime;

                    // Apply rotation using angular velocity
                    if (Math.abs(angleDiff) > 0.05) { // Small threshold to prevent jitter
                        currentCar.rotation.y += currentCar.userData.angularVelocity * deltaTime;
                    }

                    // Reduce max speed based on turn angle
                    // 0° = 100% speed, 180° = 50% speed (linear interpolation)
                    const angleRatio = Math.abs(angleDiff) / Math.PI; // 0 (aligned) to 1 (opposite)
                    const turnSpeedMultiplier = 1.0 - (angleRatio * 0.5); // Reduce by up to 50%
                    dynamicMaxSpeed = maxSpeed * turnSpeedMultiplier;

                    // Always move forward based on remapped joystick magnitude
                    accelerateInput = remapJoystickSpeed(inputMagnitude);
                    useAutoSteering = true;
                } else {
                    // Joystick not active - reset angular velocity smoothly
                    currentCar.userData.angularVelocity *= (1 - 5.0 * deltaTime);
                    if (Math.abs(currentCar.userData.angularVelocity) < 0.01) {
                        currentCar.userData.angularVelocity = 0;
                    }
                }
            }

            // Keyboard controls for car (traditional tank controls)
            if (keys['KeyW'] || keys['ArrowUp']) accelerateInput = 1;
            if (keys['KeyS'] || keys['ArrowDown']) reverseInput = 1;
            if (keys['KeyA'] || keys['ArrowLeft']) currentTurnInput = 1; // Left (REVERSED)
            if (keys['KeyD'] || keys['ArrowRight']) currentTurnInput = -1; // Right (REVERSED)

            // Reset angular velocity when using keyboard (keyboard uses turnInputAccumulated instead)
            if ((keys['KeyW'] || keys['ArrowUp'] || keys['KeyS'] || keys['ArrowDown'] ||
                 keys['KeyA'] || keys['ArrowLeft'] || keys['KeyD'] || keys['ArrowRight']) && !joystickActive) {
                currentCar.userData.angularVelocity = 0;
            }

            // Handle linger effect for left/right controls (keyboard only, not joystick auto-steering)
            const currentTime = Date.now();
            
            if (currentTurnInput !== 0) {
                // Input is active
                if (!leftRightInputActive) {
                    // Input just started
                    leftRightInputActive = true;
                    leftRightInputStartTime = currentTime;
                }
                // Use current input directly
                turnInput = currentTurnInput;
                // Store the current input direction for linger
                currentCar.userData.lastTurnDirection = currentTurnInput;
            } else {
                // No input - check if we should apply linger
                if (leftRightInputActive) {
                    // Input just ended - calculate linger based on hold duration
                    leftRightInputActive = false;
                    const holdDuration = currentTime - leftRightInputStartTime;
                    
                    // Linger amount depends on hold duration but is always small
                    // Max hold duration of 2 seconds gives max linger
                    const maxHoldDuration = 2000; // 2 seconds
                    const normalizedHoldDuration = Math.min(holdDuration / maxHoldDuration, 1.0);
                    
                    // Small linger range: 0.1 to 0.3 (always small as requested)
                    const minLinger = 0.1;
                    const maxLinger = 0.3;
                    const lingerAmount = minLinger + (normalizedHoldDuration * (maxLinger - minLinger));
                    
                    // Apply linger in the same direction as the last input (FIXED)
                    leftRightLingerVelocity = (currentCar.userData.lastTurnDirection || 0) * lingerAmount;
                }
                
                // Apply and decay linger velocity
                if (Math.abs(leftRightLingerVelocity) > 0.01) {
                    turnInput = leftRightLingerVelocity;
                    // Decay linger velocity over time - smooth falloff as requested
                    const decayRate = 1.5; // Faster decay for quicker diminishing effect
                    leftRightLingerVelocity *= (1 - decayRate * deltaTime);
                } else {
                    // Linger has decayed to negligible amount
                    leftRightLingerVelocity = 0;
                    turnInput = 0;
                }
            }
            
            // Initialize car physics if not present
            if (!currentCar.userData.speed) currentCar.userData.speed = 0;
            if (!currentCar.userData.isReversing) currentCar.userData.isReversing = false;
            if (!currentCar.userData.turnInputAccumulated) currentCar.userData.turnInputAccumulated = 0;
            if (!currentCar.userData.lastTurnDirection) currentCar.userData.lastTurnDirection = 0;
            if (!currentCar.userData.angularVelocity) currentCar.userData.angularVelocity = 0;
            
            // Update car speed based on input
            if (accelerateInput > 0) {
                // Forward input - gradual acceleration
                if (currentCar.userData.isReversing) {
                    // If reversing, first slow down to stop
                    currentCar.userData.speed -= brakeDeceleration * accelerateInput * deltaTime;
                    if (currentCar.userData.speed <= 0) {
                        currentCar.userData.speed = 0;
                        currentCar.userData.isReversing = false;
                    }
                } else {
                    // Normal forward acceleration
                    currentCar.userData.speed += acceleration * accelerateInput * deltaTime;
                    currentCar.userData.speed = Math.min(currentCar.userData.speed, dynamicMaxSpeed);
                }
            } else if (reverseInput > 0) {
                // Reverse input - gradual slowdown then reverse
                if (!currentCar.userData.isReversing && currentCar.userData.speed > 0) {
                    // First slow down to stop
                    currentCar.userData.speed -= brakeDeceleration * reverseInput * deltaTime;
                    if (currentCar.userData.speed <= 0) {
                        currentCar.userData.speed = 0;
                        currentCar.userData.isReversing = true;
                    }
                } else {
                    // Now in reverse mode - accelerate backwards
                    currentCar.userData.isReversing = true;
                    currentCar.userData.speed += acceleration * reverseInput * deltaTime;
                    currentCar.userData.speed = Math.min(currentCar.userData.speed, maxReverseSpeed);
                }
            } else {
                // No input - natural deceleration
                currentCar.userData.speed -= deceleration * deltaTime;
                if (currentCar.userData.speed <= 0) {
                    currentCar.userData.speed = 0;
                    currentCar.userData.isReversing = false;
                }
            }
            
            // Update car turning with gradual buildup (keyboard only, not joystick auto-steering)
            const turnBuildupRate = 2.0; // Rate at which turn input builds up (1/0.5 = 2.0)

            if (!useAutoSteering && turnInput !== 0 && currentCar.userData.speed > minTurnSpeed) {
                // Gradually build up turn input over time
                const targetTurnInput = turnInput;
                currentCar.userData.turnInputAccumulated += (targetTurnInput - currentCar.userData.turnInputAccumulated) * turnBuildupRate * deltaTime;

                // Turn rate scaled by speed - faster speed = faster turning
                const speedRatio = currentCar.userData.speed / maxSpeed;
                const maxTurnRate = 2.0; // Maximum turn rate at full speed
                const turnRate = maxTurnRate * speedRatio * Math.abs(currentCar.userData.turnInputAccumulated);

                // Invert turn direction when reversing (like real car controls)
                const turnDirectionMultiplier = currentCar.userData.isReversing ? -1 : 1;
                currentCar.rotation.y += currentCar.userData.turnInputAccumulated * turnRate * deltaTime * turnDirectionMultiplier;
            } else if (!useAutoSteering) {
                // No turn input - gradually reduce accumulated turn input (keyboard only)
                currentCar.userData.turnInputAccumulated *= (1 - turnBuildupRate * deltaTime);
                if (Math.abs(currentCar.userData.turnInputAccumulated) < 0.01) {
                    currentCar.userData.turnInputAccumulated = 0;
                }
            }
            
            // Update car position based on speed and direction
            if (currentCar.userData.speed > 0) {
                // Calculate movement direction based on whether we're reversing
                const directionMultiplier = currentCar.userData.isReversing ? -1 : 1;
                const moveX = Math.sin(currentCar.rotation.y) * currentCar.userData.speed * deltaTime * directionMultiplier;
                const moveZ = Math.cos(currentCar.rotation.y) * currentCar.userData.speed * deltaTime * directionMultiplier;
                
                const newX = currentCar.position.x + moveX;
                const newZ = currentCar.position.z + moveZ;
                
                // Check world boundaries and dock status
                const worldBoundary = getWorldBoundary();
                const carRadius = 3.5;
                const carOnDock = isOnDock(newX, newZ);
                const carOnWater = isOnWater(newX, newZ);

                // Allow movement if within boundaries OR on a dock (and not on water)
                const withinBoundaries = Math.abs(newX) <= worldBoundary - carRadius && Math.abs(newZ) <= worldBoundary - carRadius;
                const canMove = (withinBoundaries || carOnDock) && !carOnWater;

                if (canMove) {
                    // Check for curb collision (driving onto elevated surfaces)
                    const oldCollision = checkCollisions(currentCar.position.x, currentCar.position.z, currentCar.position.y);
                    const newCollision = checkCollisions(newX, newZ, currentCar.position.y);

                    // If car is driving onto a curb (height increase), spawn sparks from below front end
                    if (newCollision.groundHeight > oldCollision.groundHeight + 0.1) {
                        // Calculate front end position below the car
                        const frontX = currentCar.position.x + Math.sin(currentCar.rotation.y) * 6.5; // 6.5 units in front of center
                        const frontZ = currentCar.position.z + Math.cos(currentCar.rotation.y) * 6.5;
                        const frontY = oldCollision.groundHeight + 0.2; // Just above old ground level, below car

                        // Spawn yellow/white sparks from below front end of car (3x as dense, 2x bigger, 100% opacity, 4x lifespan)
                        spawnCarSparkParticleBurst(frontX, frontY, frontZ, 60); // Was 20, now 60 (3x)
                    }

                    currentCar.position.x = newX;
                    currentCar.position.z = newZ;

                    // Update car height based on ground collision (cars move up/down with curbs)
                    currentCar.position.y = newCollision.stepUpHeight;

                    // Car shadows removed - no shadow positioning needed
                } else {
                    // Car hit world boundary - spawn big particle burst at collision point
                    const collisionX = Math.sign(newX) * (worldBoundary - carRadius);
                    const collisionZ = Math.sign(newZ) * (worldBoundary - carRadius);
                    const collisionY = currentCar.position.y + 1; // At car center height
                    
                    // Spawn big yellow/white particle burst for boundary collision (3x as dense, 2x bigger, 100% opacity, 4x lifespan)
                    spawnCarSparkParticleBurst(collisionX, collisionY, collisionZ, 180); // Was 60, now 180 (3x)
                }
            }
            
            // Check for collisions with NPCs while driving
            if (currentCar.userData.speed > 5) { // Only check collisions when moving at reasonable speed
                checkCarNPCCollisions();
            }
            
            // Check for collisions with other cars while driving (only when player is controlling)
            if (currentCar.userData.speed > 2) { // Check car collisions at lower speeds too
                checkCarCarCollisions();
            }
            
            // Check for building collisions while driving
            if (currentCar.userData.speed > 2) { // Check building collisions at lower speeds too
                checkCarBuildingCollisions();
            }
        }
        
        function checkCarNPCCollisions() {
            if (!currentCar || gameState !== 'driving') return;
            
            // Check collision with each NPC
            npcCharacters.forEach((npc, index) => {
                if (npc.userData.isCarjackNPC) return; // Skip carjack NPCs
                
                const distanceToNPC = Math.sqrt(
                    Math.pow(currentCar.position.x - npc.position.x, 2) + 
                    Math.pow(currentCar.position.z - npc.position.z, 2)
                );
                
                // Car collision radius: 7 units wide, so 3.5 unit radius
                // NPC collision radius: 0.9 units wide, so 0.45 unit radius
                // Total collision distance: 3.5 + 0.45 = 3.95 units
                if (distanceToNPC <= 3.95) {
                    // Car hit NPC!
                    handleCarNPCCollision(npc, index);
                }
            });
        }
        
        function checkCarCarCollisions() {
            if (!currentCar || gameState !== 'driving') return;

            // Check collision with other cars (only when player is controlling a car in carjacked state)
            if (currentCar.userData.state !== 'carjacked') return;

            carObjects.forEach(otherCar => {
                if (otherCar === currentCar) return; // Skip self

                // Skip if both cars are already in physics mode (already colliding)
                if (currentCar.userData.inPhysicsMode && otherCar.userData.inPhysicsMode) return;

                const distanceToOtherCar = Math.sqrt(
                    Math.pow(currentCar.position.x - otherCar.position.x, 2) +
                    Math.pow(currentCar.position.z - otherCar.position.z, 2)
                );

                // Car collision radius: 7 units wide, so 3.5 unit radius each
                // Total collision distance: 3.5 + 3.5 = 7 units
                if (distanceToOtherCar <= 7) {
                    // Cars collided!
                    handleCarCarCollision(otherCar);
                    return; // Only handle one collision per frame
                }
            });
        }
        
        function handleCarCarCollision(otherCar) {
            // Calculate collision direction vector (from other car to current car)
            const collisionDirX = currentCar.position.x - otherCar.position.x;
            const collisionDirZ = currentCar.position.z - otherCar.position.z;
            const collisionDistance = Math.sqrt(collisionDirX * collisionDirX + collisionDirZ * collisionDirZ);
            
            // Normalize collision direction
            const normalizedDirX = collisionDirX / collisionDistance;
            const normalizedDirZ = collisionDirZ / collisionDistance;
            
            // Calculate collision point between the two cars
            const collisionX = (currentCar.position.x + otherCar.position.x) / 2;
            const collisionY = (currentCar.position.y + otherCar.position.y) / 2 + 1; // At car center height
            const collisionZ = (currentCar.position.z + otherCar.position.z) / 2;
            
            // Spawn MORE spark particles at collision point (more than building collision)
            spawnCarSparkParticleBurst(collisionX, collisionY, collisionZ, 300); // Was 240 for buildings, now 300 for car-car
            
            // Apply force to both cars along opposite directions - DOUBLED FORCES (doubled again)
            const forceStrength = 100; // Doubled again (was 50, now 100)
            const rotationalForce = 4.0; // Doubled again (was 2.0, now 4.0)
            
            // Initialize physics for both cars if not present
            if (!currentCar.userData.velocity) {
                currentCar.userData.velocity = { x: 0, z: 0 };
            }
            if (!otherCar.userData.velocity) {
                otherCar.userData.velocity = { x: 0, z: 0 };
            }
            
            // Store original position and rotation for interpolation back
            if (!otherCar.userData.originalPosition) {
                otherCar.userData.originalPosition = {
                    x: otherCar.position.x,
                    y: otherCar.position.y,
                    z: otherCar.position.z
                };
            }
            if (!otherCar.userData.originalRotation) {
                otherCar.userData.originalRotation = otherCar.rotation.y;
            }
            
            // Apply opposite forces to both cars - CURRENT CAR gets pushed in collision direction
            currentCar.userData.velocity.x = normalizedDirX * forceStrength;
            currentCar.userData.velocity.z = normalizedDirZ * forceStrength;
            
            // OTHER CAR gets pushed in opposite direction
            otherCar.userData.velocity.x = -normalizedDirX * forceStrength;
            otherCar.userData.velocity.z = -normalizedDirZ * forceStrength;
            
            // Apply rotational inertia ONLY when player-controlled car is involved
            // ZERO rotational force until player-controlled car collides
            if (currentCar.userData.isPlayerControlled) {
                currentCar.userData.angularVelocity = (Math.random() - 0.5) * rotationalForce * 2; // Random direction, doubled spin
                otherCar.userData.angularVelocity = (Math.random() - 0.5) * rotationalForce * 2; // Random direction, doubled spin
            } else {
                // No rotational force applied - cars maintain perfectly orthogonal orientations
                currentCar.userData.angularVelocity = 0;
                otherCar.userData.angularVelocity = 0;
            }
            
            // Set both cars to physics mode
            currentCar.userData.inPhysicsMode = true;
            otherCar.userData.inPhysicsMode = true;
            
            // Stop normal car movement for both cars
            currentCar.userData.speed = 0;
            if (otherCar.userData.speed !== undefined) {
                otherCar.userData.speed = 0;
            }
            
            // Also stop any AI movement patterns but DO NOT make cars disappear
            if (otherCar.userData.moveSpeed !== undefined) {
                otherCar.userData.originalSpeed = otherCar.userData.moveSpeed;
                otherCar.userData.moveSpeed = 0;
            }
            
            // Ensure the non-player car will resume its normal path after physics ends
            if (otherCar !== currentCar) {
                otherCar.userData.shouldResumeNormalPath = true;
                otherCar.userData.needsInterpolation = true; // Flag for interpolation back to original position
            }
        }
        
        function checkCarBuildingCollisions() {
            if (!currentCar || gameState !== 'driving') return;
            
            // Check collision with tall buildings (height > 50) - ONLY for player car
            // Use the config data directly instead of mesh objects since meshes are merged
            for (const cube of worldCubes) {
                const cubeHeight = cube.height || cube.size;
                
                // Only check collision with tall buildings
                if (cubeHeight > 50) {
                    const cubeHalfSizeX = cube.size / 2;
                    const cubeHalfSizeZ = (cube.sizeZ || cube.size) / 2;
                    const carRadius = 3.5; // Car collision radius

                    // Check if car is within building's horizontal bounds
                    const distX = Math.abs(currentCar.position.x - cube.x);
                    const distZ = Math.abs(currentCar.position.z - cube.z);

                    if (distX < cubeHalfSizeX + carRadius && distZ < cubeHalfSizeZ + carRadius) {
                        // Car hit building!
                        handleCarBuildingCollision(cube);
                        return; // Only handle one collision per frame
                    }
                }
            }
        }
        
        function checkCarBuildingCollisionsForAllCars(car) {
            if (!car || !car.userData.isCar) return;
            
            // Check collision with tall buildings (height > 50) - for ALL cars
            // Use the config data directly instead of mesh objects since meshes are merged
            for (const cube of worldCubes) {
                const cubeHeight = cube.height || cube.size;
                
                // Only check collision with tall buildings
                if (cubeHeight > 50) {
                    const cubeHalfSizeX = cube.size / 2;
                    const cubeHalfSizeZ = (cube.sizeZ || cube.size) / 2;
                    const carRadius = 3.5; // Car collision radius

                    // Check if car is within building's horizontal bounds
                    const distX = Math.abs(car.position.x - cube.x);
                    const distZ = Math.abs(car.position.z - cube.z);

                    if (distX < cubeHalfSizeX + carRadius && distZ < cubeHalfSizeZ + carRadius) {
                        // Car hit building! Prevent passing through
                        handleCarBuildingCollisionForAllCars(car, cube);
                        return; // Only handle one collision per frame
                    }
                }
            }
        }
        
        function checkCarToCarCollisionsForAllCars(car) {
            if (!car || !car.userData.isCar) return;
            
            // Check collision with all other cars
            carObjects.forEach(otherCar => {
                if (otherCar === car) return; // Skip self
                if (otherCar.userData.inPhysicsMode && car.userData.inPhysicsMode) return; // Skip if both already in physics mode
                
                const distanceToOtherCar = Math.sqrt(
                    Math.pow(car.position.x - otherCar.position.x, 2) + 
                    Math.pow(car.position.z - otherCar.position.z, 2)
                );
                
                // Car collision radius: 7 units wide, so 3.5 unit radius each
                // Total collision distance: 3.5 + 3.5 = 7 units
                if (distanceToOtherCar <= 7) {
                    // Cars collided!
                    handleCarToCarCollisionForAllCars(car, otherCar);
                    return; // Only handle one collision per frame
                }
            });
        }
        
        function handleCarBuildingCollisionForAllCars(car, building) {
            // Calculate which side of the building was hit
            const buildingHalfSizeX = building.size / 2;
            const buildingHalfSizeZ = (building.sizeZ || building.size) / 2;
            const carRadius = 3.5;

            const relativeX = car.position.x - building.x;
            const relativeZ = car.position.z - building.z;

            // Determine which surface is closest (collision normal)
            const overlapX = (buildingHalfSizeX + carRadius) - Math.abs(relativeX);
            const overlapZ = (buildingHalfSizeZ + carRadius) - Math.abs(relativeZ);

            let normalX = 0;
            let normalZ = 0;

            // The axis with smaller overlap is the collision axis
            if (overlapX < overlapZ) {
                // Hit left or right wall
                normalX = relativeX > 0 ? 1 : -1;
                normalZ = 0;
                // Push car out along X axis
                car.position.x = building.x + normalX * (buildingHalfSizeX + carRadius + 0.5);
            } else {
                // Hit front or back wall
                normalX = 0;
                normalZ = relativeZ > 0 ? 1 : -1;
                // Push car out along Z axis
                car.position.z = building.z + normalZ * (buildingHalfSizeZ + carRadius + 0.5);
            }

            // Get car's current velocity
            let velocityX = 0;
            let velocityZ = 0;

            if (car.userData.inPhysicsMode && car.userData.velocity) {
                velocityX = car.userData.velocity.x;
                velocityZ = car.userData.velocity.z;
            } else if (car.userData.speed) {
                // Calculate velocity from rotation and speed
                velocityX = Math.sin(car.rotation.y) * car.userData.speed;
                velocityZ = Math.cos(car.rotation.y) * car.userData.speed;
            }

            // Project velocity onto the wall (remove perpendicular component, keep parallel)
            const dotProduct = velocityX * normalX + velocityZ * normalZ;
            const parallelVelocityX = velocityX - dotProduct * normalX;
            const parallelVelocityZ = velocityZ - dotProduct * normalZ;

            // Apply sliding velocity
            if (car.userData.inPhysicsMode) {
                car.userData.velocity.x = parallelVelocityX * 0.7; // Reduce speed slightly on slide
                car.userData.velocity.z = parallelVelocityZ * 0.7;
            } else if (car.userData.speed) {
                // Calculate new speed and direction for sliding
                const newSpeed = Math.sqrt(parallelVelocityX * parallelVelocityX + parallelVelocityZ * parallelVelocityZ);
                car.userData.speed = newSpeed * 0.7; // Reduce speed slightly on slide

                // Update rotation to match sliding direction if speed is significant
                if (newSpeed > 1) {
                    const newAngle = Math.atan2(parallelVelocityX, parallelVelocityZ);
                    car.rotation.y = newAngle;
                }
            }

            // If this is the player's car, handle special effects
            if (car === currentCar) {
                // Calculate collision point at front of car
                const frontX = car.position.x + Math.sin(car.rotation.y) * 6.5;
                const frontZ = car.position.z + Math.cos(car.rotation.y) * 6.5;
                const frontY = car.position.y + 1;

                // Spawn smaller particle burst at collision point (since we're sliding, not stopping)
                spawnCarSparkParticleBurst(frontX, frontY, frontZ, 120);
            }
        }
        
        function handleCarToCarCollisionForAllCars(car1, car2) {
            // Calculate collision direction vector (from car2 to car1)
            const collisionDirX = car1.position.x - car2.position.x;
            const collisionDirZ = car1.position.z - car2.position.z;
            const collisionDistance = Math.sqrt(collisionDirX * collisionDirX + collisionDirZ * collisionDirZ);

            // Normalize collision direction
            const normalizedDirX = collisionDirX / collisionDistance;
            const normalizedDirZ = collisionDirZ / collisionDistance;

            // Calculate collision point between the two cars
            const collisionX = (car1.position.x + car2.position.x) / 2;
            const collisionY = (car1.position.y + car2.position.y) / 2 + 1; // At car center height
            const collisionZ = (car1.position.z + car2.position.z) / 2;

            // Spawn spark particles at collision point
            spawnCarSparkParticleBurst(collisionX, collisionY, collisionZ, 300);

            // Apply forces to both cars - DOUBLED FORCES for better visibility (doubled again)
            const forceStrength = 100; // Doubled again (was 50, now 100)
            const rotationalForce = 4.0; // Doubled again (was 2.0, now 4.0)
            
            // Initialize physics for both cars if not present
            if (!car1.userData.velocity) {
                car1.userData.velocity = { x: 0, z: 0 };
            }
            if (!car2.userData.velocity) {
                car2.userData.velocity = { x: 0, z: 0 };
            }
            
            // Store original positions and rotations for interpolation back
            if (!car1.userData.originalPosition) {
                car1.userData.originalPosition = {
                    x: car1.position.x,
                    y: car1.position.y,
                    z: car1.position.z
                };
            }
            if (!car1.userData.originalRotation) {
                car1.userData.originalRotation = car1.rotation.y;
            }
            if (!car2.userData.originalPosition) {
                car2.userData.originalPosition = {
                    x: car2.position.x,
                    y: car2.position.y,
                    z: car2.position.z
                };
            }
            if (!car2.userData.originalRotation) {
                car2.userData.originalRotation = car2.rotation.y;
            }
            
            // Apply opposite forces to both cars - CAR1 gets pushed in collision direction
            car1.userData.velocity.x = normalizedDirX * forceStrength;
            car1.userData.velocity.z = normalizedDirZ * forceStrength;
            
            // CAR2 gets pushed in opposite direction
            car2.userData.velocity.x = -normalizedDirX * forceStrength;
            car2.userData.velocity.z = -normalizedDirZ * forceStrength;
            
            // Apply rotational inertia ONLY when player-controlled car is involved
            // ZERO rotational force until player-controlled car collides
            const playerCarInvolved = (car1.userData.isPlayerControlled || car2.userData.isPlayerControlled);
            if (playerCarInvolved) {
                car1.userData.angularVelocity = (Math.random() - 0.5) * rotationalForce * 2; // Random direction, doubled spin
                car2.userData.angularVelocity = (Math.random() - 0.5) * rotationalForce * 2; // Random direction, doubled spin
            } else {
                // No rotational force applied - cars maintain perfectly orthogonal orientations
                car1.userData.angularVelocity = 0;
                car2.userData.angularVelocity = 0;
            }
            
            // Set both cars to physics mode
            car1.userData.inPhysicsMode = true;
            car2.userData.inPhysicsMode = true;

            // Stop normal car movement for both cars
            if (car1.userData.speed !== undefined) {
                car1.userData.speed = 0;
            }
            if (car2.userData.speed !== undefined) {
                car2.userData.speed = 0;
            }

            // Also stop any AI movement patterns but DO NOT make cars disappear
            if (car1.userData.moveSpeed !== undefined) {
                car1.userData.originalSpeed = car1.userData.moveSpeed;
                car1.userData.moveSpeed = 0;
            }
            if (car2.userData.moveSpeed !== undefined) {
                car2.userData.originalSpeed = car2.userData.moveSpeed;
                car2.userData.moveSpeed = 0;
            }

            // Ensure both cars will resume their normal path after physics ends
            car1.userData.shouldResumeNormalPath = true;
            car2.userData.shouldResumeNormalPath = true;
            car1.userData.needsInterpolation = true; // Flag for interpolation back to original position
            car2.userData.needsInterpolation = true; // Flag for interpolation back to original position
        }
        
        function updateCarPhysics(car, deltaTime) {
            if (!car.userData.inPhysicsMode && !car.userData.needsInterpolation) return;
            
            // Handle interpolation back to original position after physics ends
            if (car.userData.needsInterpolation && !car.userData.inPhysicsMode) {
                const interpolationSpeed = 2.0; // Speed of interpolation back to original position
                
                // Interpolate position back to original
                if (car.userData.originalPosition) {
                    const targetX = car.userData.originalPosition.x;
                    const targetY = car.userData.originalPosition.y;
                    const targetZ = car.userData.originalPosition.z;
                    
                    // Smooth interpolation towards original position
                    car.position.x += (targetX - car.position.x) * interpolationSpeed * deltaTime;
                    car.position.y += (targetY - car.position.y) * interpolationSpeed * deltaTime;
                    car.position.z += (targetZ - car.position.z) * interpolationSpeed * deltaTime;
                    
                    // Check if close enough to original position
                    const distanceToOriginal = Math.sqrt(
                        Math.pow(car.position.x - targetX, 2) +
                        Math.pow(car.position.y - targetY, 2) +
                        Math.pow(car.position.z - targetZ, 2)
                    );
                    
                    if (distanceToOriginal < 0.5) {
                        // Close enough - snap to exact position
                        car.position.x = targetX;
                        car.position.y = targetY;
                        car.position.z = targetZ;
                    }
                }
                
                // Interpolate rotation back to original
                if (car.userData.originalRotation !== undefined) {
                    const targetRotation = car.userData.originalRotation;
                    let rotationDiff = targetRotation - car.rotation.y;
                    
                    // Handle angle wrapping (shortest path)
                    if (rotationDiff > Math.PI) rotationDiff -= 2 * Math.PI;
                    if (rotationDiff < -Math.PI) rotationDiff += 2 * Math.PI;
                    
                    // Smooth interpolation towards original rotation
                    car.rotation.y += rotationDiff * interpolationSpeed * deltaTime;
                    
                    // Check if close enough to original rotation
                    if (Math.abs(rotationDiff) < 0.1) {
                        // Close enough - snap to exact rotation
                        car.rotation.y = targetRotation;

                        // Interpolation complete - clean up and resume normal path
                        car.userData.needsInterpolation = false;
                        car.userData.originalPosition = undefined;
                        car.userData.originalRotation = undefined;

                        // Restore AI movement
                        if (car.userData.originalSpeed !== undefined && car.userData.shouldResumeNormalPath) {
                            car.userData.moveSpeed = car.userData.originalSpeed;
                            car.userData.originalSpeed = undefined;
                            car.userData.shouldResumeNormalPath = false;

                            // Reset car state to normal for AI cars (not player car)
                            if (car !== currentCar) {
                                car.userData.state = 'normal';
                            }
                        }
                    }
                }

                return; // Skip physics update during interpolation
            }
            
            // Normal physics mode handling
            if (!car.userData.inPhysicsMode) return;
            
            // Initialize physics properties if not present
            if (!car.userData.velocity) {
                car.userData.velocity = { x: 0, z: 0 };
            }
            // CRITICAL: Ensure angular velocity is ZERO unless explicitly set by player collision
            if (car.userData.angularVelocity === undefined) {
                car.userData.angularVelocity = 0;
            }
            
            // Apply deceleration to linear velocity (gradual slowdown)
            const deceleration = 6; // Slightly slower deceleration for more realistic physics (was 8, now 6)
            car.userData.velocity.x *= (1 - deceleration * deltaTime);
            car.userData.velocity.z *= (1 - deceleration * deltaTime);
            
            // Apply deceleration to angular velocity (rotational slowdown)
            const angularDeceleration = 3; // Slower angular deceleration for longer spin (was 5, now 3)
            car.userData.angularVelocity *= (1 - angularDeceleration * deltaTime);
            
            // Update position based on velocity
            const newX = car.position.x + car.userData.velocity.x * deltaTime;
            const newZ = car.position.z + car.userData.velocity.z * deltaTime;
            
            // Check world boundaries
            const worldBoundary = getWorldBoundary();
            const carRadius = 3.5;

            if (Math.abs(newX) <= worldBoundary - carRadius && Math.abs(newZ) <= worldBoundary - carRadius) {
                // Check for building collisions during physics movement
                let canMove = true;
                for (const cube of worldCubes) {
                    const cubeHeight = cube.height || cube.size;
                    
                    // Only check collision with tall buildings
                    if (cubeHeight > 50) {
                        const cubeHalfSizeX = cube.size / 2;
                        const cubeHalfSizeZ = (cube.sizeZ || cube.size) / 2;

                        // Check if car would be within building's horizontal bounds
                        const distX = Math.abs(newX - cube.x);
                        const distZ = Math.abs(newZ - cube.z);

                        if (distX < cubeHalfSizeX + carRadius && distZ < cubeHalfSizeZ + carRadius) {
                            // Car would hit building - stop physics movement
                            canMove = false;
                            car.userData.velocity.x = 0;
                            car.userData.velocity.z = 0;
                            car.userData.angularVelocity = 0; // Stop spinning too
                            break;
                        }
                    }
                }
                
                if (canMove) {
                    car.position.x = newX;
                    car.position.z = newZ;
                    
                    // Update car height based on ground collision
                    const collision = checkCollisions(newX, newZ, car.position.y);
                    car.position.y = collision.stepUpHeight;
                }
            } else {
                // Hit world boundary - stop physics
                car.userData.velocity.x = 0;
                car.userData.velocity.z = 0;
                car.userData.angularVelocity = 0; // Stop spinning too
            }
            
            // Update rotation based on angular velocity
            car.rotation.y += car.userData.angularVelocity * deltaTime;
            
            // Stop physics mode when velocities are very small
            const linearSpeed = Math.sqrt(car.userData.velocity.x * car.userData.velocity.x + car.userData.velocity.z * car.userData.velocity.z);
            if (linearSpeed < 0.5 && Math.abs(car.userData.angularVelocity) < 0.1) { // Higher thresholds for longer physics
                car.userData.inPhysicsMode = false;
                car.userData.velocity = { x: 0, z: 0 };
                car.userData.angularVelocity = 0;

                // Start interpolation back to original position if this is an AI car
                if (car !== currentCar && car.userData.shouldResumeNormalPath) {
                    car.userData.needsInterpolation = true;
                } else {
                    // For player car, just restore movement immediately
                    if (car.userData.originalSpeed !== undefined && car.userData.shouldResumeNormalPath) {
                        car.userData.moveSpeed = car.userData.originalSpeed;
                        car.userData.originalSpeed = undefined;
                        car.userData.shouldResumeNormalPath = false;

                        // Reset car state to normal for AI cars (not player car)
                        if (car !== currentCar) {
                            car.userData.state = 'normal';
                        }
                    }
                }
            }
        }
        
        function handleCarNPCCollision(npc, npcIndex) {
            // Calculate car's movement direction and speed
            const carVelocityX = Math.sin(currentCar.rotation.y) * currentCar.userData.speed;
            const carVelocityZ = Math.cos(currentCar.rotation.y) * currentCar.userData.speed;
            
            // Apply 2x force to NPC in same direction as car movement
            const throwForceX = carVelocityX * 2;
            const throwForceZ = carVelocityZ * 2;
            const throwForceY = 15; // High upward force
            
            // Initialize NPC physics if not present
            if (!npc.userData.velocity) {
                npc.userData.velocity = { x: 0, y: 0, z: 0 };
            }
            
            // Apply throwing forces to NPC
            npc.userData.velocity.x = throwForceX;
            npc.userData.velocity.y = throwForceY;
            npc.userData.velocity.z = throwForceZ;
            npc.userData.onGround = false;
            npc.userData.isFlying = true;
            npc.userData.bounceCount = 0; // Reset bounce count for new collision
            
            // Add Y-axis rotation while flying
            npc.userData.rotationSpeed = 2 + Math.random() * 2; // 2-4 radians/sec
                        
            // Spawn dense red and maroon particle burst at collision point
            spawnRedParticleBurst(npc.position.x, npc.position.y, npc.position.z);

            // Raise wanted level to 2 stars (or 3 if police nearby)
            setWantedLevelForInfraction(2);

            // Mark NPC for special handling during physics update
            npc.userData.hitByCar = true;
            npc.userData.fadeAfterLanding = true;
        }
        
        function handleCarBuildingCollision(building) {
            // Calculate collision point at front of car
            const frontX = currentCar.position.x + Math.sin(currentCar.rotation.y) * 6.5; // 6.5 units in front of center
            const frontZ = currentCar.position.z + Math.cos(currentCar.rotation.y) * 6.5;
            const frontY = currentCar.position.y + 1; // At car center height
            
            // Spawn big yellow/white particle burst at collision point (3x as dense, 2x bigger, 100% opacity, 4x lifespan)
            spawnCarSparkParticleBurst(frontX, frontY, frontZ, 240); // Was 80, now 240 (3x)
            
            // Stop the car completely
            currentCar.userData.speed = 0;
            
            // Push car back slightly to prevent getting stuck in building
            const pushBackDistance = 1;
            currentCar.position.x -= Math.sin(currentCar.rotation.y) * pushBackDistance;
            currentCar.position.z -= Math.cos(currentCar.rotation.y) * pushBackDistance;
            
            // Car shadows removed - no shadow positioning needed            
        }
        
        function updateNPCSliding(npc, deltaTime) {
            if (!npc.userData.velocity || !npc.userData.isSliding) return;
            
            // Apply gradual deceleration to horizontal movement
            const decelerationRate = npc.userData.slideDecelerationRate || 8;
            
            // Update position based on velocity (ground sliding only)
            npc.position.x += npc.userData.velocity.x * deltaTime;
            npc.position.z += npc.userData.velocity.z * deltaTime;
            
            // Gradually reduce horizontal velocity
            npc.userData.velocity.x *= (1 - decelerationRate * deltaTime);
            npc.userData.velocity.z *= (1 - decelerationRate * deltaTime);
            
            // Stop sliding when velocity is very small
            if (Math.abs(npc.userData.velocity.x) < 0.1 && Math.abs(npc.userData.velocity.z) < 0.1) {
                npc.userData.velocity.x = 0;
                npc.userData.velocity.z = 0;
                npc.userData.isSliding = false;
            }
            
            // Update height based on ground collision (stay on ground)
            const collision = checkCollisions(npc.position.x, npc.position.z, npc.position.y);
            npc.position.y = collision.stepUpHeight;
            
            // Update NPC shadow position if it exists
            updateNPCShadowPosition(npc, collision);
            
            // Handle fade out while sliding
            if (npc.userData.isFadingOut) {
                // Update death rotation animation
                updateDeathRotation(npc, deltaTime);

                // Count down death delay timer before starting fade
                if (npc.userData.deathDelayTimer > 0) {
                    npc.userData.deathDelayTimer -= deltaTime;
                    // Stay fully visible during delay
                    setMaterialOpacity(npc, 1);
                } else {
                    // Delay complete, start fading
                    npc.userData.fadeOutProgress += deltaTime * npc.userData.fadeSpeed;

                    if (npc.userData.fadeOutProgress >= 1) {
                        // Fade complete - remove NPC
                        scene.remove(npc);
                        if (npc.userData.shadowPlane) {
                            scene.remove(npc.userData.shadowPlane);
                        }

                        // Remove from NPC list
                        const index = npcCharacters.indexOf(npc);
                        if (index > -1) {
                            npcCharacters.splice(index, 1);
                        }
                    } else {
                        // Still fading out
                        const opacity = 1 - npc.userData.fadeOutProgress;

                        // Set NPC opacity based on fade progress
                        setMaterialOpacity(npc, opacity);

                        // Fade shadow as well
                        if (npc.userData.shadowPlane && npc.userData.shadowPlane.material) {
                            npc.userData.shadowPlane.material.opacity = opacity * 0.8; // Shadow is already semi-transparent
                        }
                    }
                }
            }

            // Prevent NPC from going through world boundaries while sliding
            const worldBoundary = getWorldBoundary();
            const npcRadius = 0.5625;

            if (Math.abs(npc.position.x) > worldBoundary - npcRadius) {
                npc.position.x = Math.sign(npc.position.x) * (worldBoundary - npcRadius);
                npc.userData.velocity.x = 0; // Stop horizontal movement at boundary
            }
            if (Math.abs(npc.position.z) > worldBoundary - npcRadius) {
                npc.position.z = Math.sign(npc.position.z) * (worldBoundary - npcRadius);
                npc.userData.velocity.z = 0; // Stop horizontal movement at boundary
            }
        }
        
        function updateNPCPhysics(npc, deltaTime) {
            if (!npc.userData.velocity || !npc.userData.isFlying) return;
            
            const gravity = -26; // Same gravity as player
            
            // Update velocity with gravity
            npc.userData.velocity.y += gravity * deltaTime;
            
            // Update position based on velocity
            npc.position.x += npc.userData.velocity.x * deltaTime;
            npc.position.y += npc.userData.velocity.y * deltaTime;
            npc.position.z += npc.userData.velocity.z * deltaTime;
            
            // Add Y-axis rotation while flying
            if (npc.userData.rotationSpeed) {
                npc.rotation.y += npc.userData.rotationSpeed * deltaTime;
            }
            
            // Check for ground collision
            const collision = checkCollisions(npc.position.x, npc.position.z, npc.position.y);
            const groundHeight = collision.stepUpHeight;
            
            if (npc.position.y <= groundHeight && npc.userData.velocity.y <= 0) {
                // NPC has landed
                npc.position.y = groundHeight;
                
                // Initialize bounce count if not present
                if (npc.userData.bounceCount === undefined) {
                    npc.userData.bounceCount = 0;
                }
                
                // Only allow one bounce after landing
                if (npc.userData.bounceCount === 0) {
                    // First bounce - calculate bounce velocity (30% of impact velocity, minimum 5 units/sec)
                    const impactVelocity = Math.abs(npc.userData.velocity.y);
                    const bounceVelocity = Math.max(impactVelocity * 0.3, 5);
                    npc.userData.velocity.y = bounceVelocity;
                    
                    // Reduce horizontal velocity by 20% on bounce
                    npc.userData.velocity.x *= 0.8;
                    npc.userData.velocity.z *= 0.8;
                    
                    npc.userData.bounceCount = 1; // Mark that we've bounced once
                } else {
                    // Second landing - stop flying
                    npc.userData.isFlying = false;
                    npc.userData.onGround = true;
                    npc.userData.velocity = { x: 0, y: 0, z: 0 };
                    npc.userData.rotationSpeed = 0; // Stop rotation
                    npc.userData.bounceCount = 0; // Reset bounce count
                    npc.userData.isShot = false; // Clear shot state
                    npc.userData.isFlyingFromShot = false;

                    // Only fade out if they were killed (isFadingOut was set during the explosion)
                    if (!npc.userData.isFadingOut) {
                        // NPC survived - just stunned, return to normal behavior
                        // They will resume their normal AI behavior
                    }
                    // If isFadingOut is already true, they will continue fading out
                }
            }
            
            // Handle fade out after landing
            if (npc.userData.isFadingOut) {
                // Update death rotation animation
                updateDeathRotation(npc, deltaTime);

                // Count down death delay timer before starting fade
                if (npc.userData.deathDelayTimer > 0) {
                    npc.userData.deathDelayTimer -= deltaTime;
                    // Stay fully visible during delay
                    setMaterialOpacity(npc, 1);
                } else {
                    // Delay complete, start fading
                    npc.userData.fadeOutProgress += deltaTime * npc.userData.fadeSpeed;

                    if (npc.userData.fadeOutProgress >= 1) {
                        // Fade complete - remove NPC
                        scene.remove(npc);
                        if (npc.userData.shadowPlane) {
                            scene.remove(npc.userData.shadowPlane);
                        }

                        // Remove from NPC list
                        const index = npcCharacters.indexOf(npc);
                        if (index > -1) {
                            npcCharacters.splice(index, 1);
                        }
                    } else {
                        // Still fading out
                        const opacity = 1 - npc.userData.fadeOutProgress;

                        // Set NPC opacity based on fade progress
                        setMaterialOpacity(npc, opacity);
                    }
                }
            }
            
            // Update shadow position if NPC has one
            updateNPCShadowPosition(npc, collision);
            
            // Prevent NPC from going through world boundaries while flying
            const worldBoundary = getWorldBoundary();
            const npcRadius = 0.5625;

            if (Math.abs(npc.position.x) > worldBoundary - npcRadius) {
                npc.position.x = Math.sign(npc.position.x) * (worldBoundary - npcRadius);
                npc.userData.velocity.x = 0; // Stop horizontal movement at boundary
            }
            if (Math.abs(npc.position.z) > worldBoundary - npcRadius) {
                npc.position.z = Math.sign(npc.position.z) * (worldBoundary - npcRadius);
                npc.userData.velocity.z = 0; // Stop horizontal movement at boundary
            }
        }
        
                function updatePlayerFadeOut(deltaTime) {
            if (!character.userData.isFadingOut) return;
            
            const fadeSpeed = 3; // Fade speed
            character.userData.fadeOutProgress += deltaTime * fadeSpeed;
            
            if (character.userData.fadeOutProgress >= 1) {
                // Fade complete - hide character completely and stop all collision checks
                character.visible = false;
                character.userData.isFadingOut = false;
                character.userData.fadeOutProgress = 1;
                character.userData.isInCar = true; // Flag to disable collision checks
                
                // CRITICAL: Ensure player remains COMPLETELY INVISIBLE while in car
                character.userData.mustRemainInvisible = true;
                
                // Also hide the shadow plane
                if (shadowPlane) {
                    shadowPlane.visible = false;
                }
            } else {
                // Still fading
                const opacity = 1 - character.userData.fadeOutProgress;
                
                // Set character opacity
                character.traverse((child) => {
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.transparent = true;
                                mat.opacity = opacity;
                            });
                        } else {
                            child.material.transparent = true;
                            child.material.opacity = opacity;
                        }
                    }
                });
                
                // Also fade the shadow
                if (shadowPlane) {
                    shadowPlane.material.opacity = opacity * 0.8; // Shadow is already semi-transparent
                }
            }
        }
        
        function updatePlayerFadeIn(deltaTime) {
            if (!character.userData.isFadingIn) return;
            
            const fadeSpeed = 3; // Fade speed
            character.userData.fadeInProgress += deltaTime * fadeSpeed;
            
            if (character.userData.fadeInProgress >= 1) {
                // Fade in complete - restore character to full opacity
                character.userData.isFadingIn = false;
                character.userData.fadeInProgress = 1;
                
                // Reset character materials to full opacity
                character.traverse((child) => {
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.transparent = false;
                                mat.opacity = 1;
                            });
                        } else {
                            child.material.transparent = false;
                            child.material.opacity = 1;
                        }
                    }
                });
                
                // Reset shadow to full opacity
                if (shadowPlane) {
                    shadowPlane.material.opacity = 0.8; // Original shadow opacity
                }
            } else {
                // Still fading in
                const opacity = character.userData.fadeInProgress;
                
                // Set character opacity
                character.traverse((child) => {
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.transparent = true;
                                mat.opacity = opacity;
                            });
                        } else {
                            child.material.transparent = true;
                            child.material.opacity = opacity;
                        }
                    }
                });
                
                // Also fade in the shadow
                if (shadowPlane) {
                    shadowPlane.material.opacity = opacity * 0.8; // Shadow is already semi-transparent
                }
            }
        }
        
                function findValidExitPosition(car) {
            const directions = [
                { angle: Math.PI / 2, name: 'left' },     // Left (current default)
                { angle: -Math.PI / 2, name: 'right' },   // Right
                { angle: Math.PI, name: 'behind' },       // Behind
                { angle: 0, name: 'front' }               // Front
            ];

            const distances = [5, 7, 10, 15];  // Try multiple distances

            // Try each distance
            for (const distance of distances) {
                // Try each direction
                for (const dir of directions) {
                    const exitAngle = car.rotation.y + dir.angle;
                    const exitX = car.position.x + Math.sin(exitAngle) * distance;
                    const exitZ = car.position.z + Math.cos(exitAngle) * distance;

                    const collision = checkCollisions(exitX, exitZ, character.position.y);

                    if (collision.canMove) {
                        console.log(`Valid exit position found: ${dir.name} at ${distance} units`);
                        return { x: exitX, z: exitZ, collision, direction: dir.name };
                    }
                }
            }

            // Last resort: spawn point
            console.log('No valid exit position near car - using spawn point');
            return {
                x: CHARACTER_SPAWN_X,
                z: CHARACTER_SPAWN_Z,
                collision: checkCollisions(CHARACTER_SPAWN_X, CHARACTER_SPAWN_Z, 0),
                direction: 'spawn'
            };
        }

                function exitCar() {
            if (!currentCar || gameState !== 'driving') return;

            // Find valid exit position
            const exitPos = findValidExitPosition(currentCar);

            // Position character at valid exit location
            character.position.x = exitPos.x;
            character.position.z = exitPos.z;
            character.position.y = exitPos.collision.stepUpHeight;
            character.userData.groundHeight = exitPos.collision.groundHeight;

            // Make character face the car
            character.userData.facingAngle = Math.atan2(currentCar.position.x - exitPos.x, currentCar.position.z - exitPos.z);
            character.rotation.y = character.userData.facingAngle;
            
            // Start fade in animation
            character.visible = true;
            character.userData.isFadingOut = false;
            character.userData.fadeOutProgress = 0;
            character.userData.isFadingIn = true;
            character.userData.fadeInProgress = 0;
            character.userData.isInCar = false; // Re-enable collision checks
            
            // Show shadow plane
            if (shadowPlane) {
                shadowPlane.visible = true;
            }
            
            // Reset car state - car should STOP and stay stopped, not return to normal
            currentCar.userData.isPlayerControlled = false;
            currentCar.userData.state = 'stopped'; // Car stays in STOPPED state
            currentCar.userData.speed = 0; // Reset car speed

            // Update navigation data to car's current position to prevent snap-back
            assignCarToRoadNetwork(currentCar);

            // Clear interpolation state to prevent car from snapping back to original position
            currentCar.userData.needsInterpolation = false;
            currentCar.userData.originalPosition = undefined;
            currentCar.userData.originalRotation = undefined;
            currentCar.userData.shouldResumeNormalPath = false;
            currentCar.userData.inPhysicsMode = false;
            
            // Reset game state
            gameState = 'walking';
            currentCar = null;
            
            // Reset car control linger state
            leftRightLingerVelocity = 0;
            leftRightInputStartTime = 0;
            leftRightInputActive = false;
            
            // Reset camera angle to follow character
            cameraHorizontalAngle = character.userData.facingAngle + Math.PI;
            
            // Update UI for walking state
            updateUIForGameState();
        }

        function setupCameraZoomControls() {
            const gameContainer = document.getElementById('gameContainer');

            if (!gameContainer) {
                return;
            }

            // Desktop scroll wheel zoom
            gameContainer.addEventListener('wheel', (e) => {
                if (playerInputDisabled) return;
                
                e.preventDefault();
                
                // Determine zoom direction
                const zoomDirection = e.deltaY > 0 ? 1 : -1; // Positive = zoom out, negative = zoom in
                const zoomSpeed = 0.1; // Zoom sensitivity
                
                // Update zoom level
                cameraZoomLevel += zoomDirection * zoomSpeed;
                cameraZoomLevel = Math.max(minZoomLevel, Math.min(maxZoomLevel, cameraZoomLevel));
            }, { passive: false });
            
            // Mobile pinch zoom
            let touches = [];
            
            gameContainer.addEventListener('touchstart', (e) => {
                if (playerInputDisabled) return;

                touches = Array.from(e.touches);

                // FIRST TOUCH: Store timing and check if in valid pinch zone
                if (touches.length === 1) {
                    firstTouchTime = Date.now();

                    const screenHeight = window.innerHeight;
                    const minY = screenHeight * 0.25;  // Top of middle 50%
                    const maxY = screenHeight * 0.75;  // Bottom of middle 50%
                    const touch = touches[0];

                    firstTouchInZone = (touch.clientY >= minY && touch.clientY <= maxY);
                    isPinching = false; // Ensure not in pinch mode yet

                    // If in pinch zone, store touch info and set timeout to activate joystick if no pinch happens
                    if (firstTouchInZone) {
                        blockedTouchInfo = {
                            identifier: touch.identifier,
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                            target: e.target
                        };

                        // Clear any existing timeout
                        if (pinchTimeout) {
                            clearTimeout(pinchTimeout);
                        }

                        // Set timeout to activate joystick if no valid pinch within 100ms
                        pinchTimeout = setTimeout(() => {
                            if (firstTouchInZone && !isPinching && blockedTouchInfo) {
                                // No valid pinch happened, activate joystick now
                                firstTouchInZone = false;
                                if (!isTouchOnButton(blockedTouchInfo.target)) {
                                    activeJoystickTouch = blockedTouchInfo.identifier;
                                    activateJoystick(blockedTouchInfo.clientX, blockedTouchInfo.clientY);
                                }
                                blockedTouchInfo = null;
                            }
                        }, 100);
                    }
                }

                // SECOND TOUCH: Validate timing and position constraints
                if (touches.length === 2) {
                    const currentTime = Date.now();
                    const timeDiff = currentTime - firstTouchTime;

                    let pinchActivated = false;

                    // Check timing constraint (within 100ms) and first touch was in zone
                    if (timeDiff <= 100 && firstTouchInZone) {
                        const touch2 = touches[1];

                        // Check position constraint for second touch
                        const screenHeight = window.innerHeight;
                        const minY = screenHeight * 0.25;
                        const maxY = screenHeight * 0.75;

                        if (touch2.clientY >= minY && touch2.clientY <= maxY) {
                            // BOTH CONSTRAINTS SATISFIED - activate pinch
                            isPinching = true;
                            pinchActivated = true;
                            const touch1 = touches[0];

                            lastPinchDistance = Math.sqrt(
                                Math.pow(touch2.clientX - touch1.clientX, 2) +
                                Math.pow(touch2.clientY - touch1.clientY, 2)
                            );

                            pinchStartZoom = cameraZoomLevel;

                            // Clear timeout since pinch activated
                            if (pinchTimeout) {
                                clearTimeout(pinchTimeout);
                                pinchTimeout = null;
                            }
                            blockedTouchInfo = null;

                            // Force hide joystick visual when pinch activates
                            const joystickElement = document.getElementById('joystick');
                            if (joystickElement) {
                                joystickElement.classList.remove('active');
                                joystickElement.style.display = 'none';
                                joystickElement.style.opacity = '0';
                            }

                            // Deactivate joystick state
                            if (joystickActive) {
                                deactivateJoystick();
                            }
                        }
                    }

                    // If pinch validation failed but first touch was in zone, activate joystick now
                    if (!pinchActivated && firstTouchInZone && blockedTouchInfo) {
                        // Clear timeout
                        if (pinchTimeout) {
                            clearTimeout(pinchTimeout);
                            pinchTimeout = null;
                        }

                        firstTouchInZone = false; // Reset so joystick can activate
                        if (!isTouchOnButton(blockedTouchInfo.target)) {
                            activeJoystickTouch = blockedTouchInfo.identifier;
                            activateJoystick(blockedTouchInfo.clientX, blockedTouchInfo.clientY);
                        }
                        blockedTouchInfo = null;
                    }
                }

                // 3+ touches: reset everything
                if (touches.length >= 3) {
                    isPinching = false;
                    firstTouchTime = null;
                    firstTouchInZone = false;
                    if (pinchTimeout) {
                        clearTimeout(pinchTimeout);
                        pinchTimeout = null;
                    }
                    blockedTouchInfo = null;
                }
            }, { passive: false });
            
            gameContainer.addEventListener('touchmove', (e) => {
                if (playerInputDisabled) return;
                
                touches = Array.from(e.touches);
                
                if (touches.length === 2 && isPinching) {
                    e.preventDefault(); // Prevent default pinch behavior
                    
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    
                    const currentPinchDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) + 
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );
                    
                    if (lastPinchDistance > 0) {
                        // Calculate zoom change based on pinch distance change
                        const pinchRatio = currentPinchDistance / lastPinchDistance;
                        const zoomSensitivity = 1.0; // Increased sensitivity
                        
                        // Apply zoom change relative to starting zoom
                        const zoomChange = (pinchRatio - 1) * zoomSensitivity;
                        cameraZoomLevel = pinchStartZoom + zoomChange;
                        cameraZoomLevel = Math.max(minZoomLevel, Math.min(maxZoomLevel, cameraZoomLevel));
                    }
                }
            }, { passive: false });
            
            gameContainer.addEventListener('touchend', (e) => {
                touches = Array.from(e.touches);

                if (touches.length < 2) {
                    isPinching = false;
                    lastPinchDistance = 0;
                }

                // Reset timing tracking when all touches released
                if (touches.length === 0) {
                    firstTouchTime = null;
                    firstTouchInZone = false;
                    if (pinchTimeout) {
                        clearTimeout(pinchTimeout);
                        pinchTimeout = null;
                    }
                    blockedTouchInfo = null;
                }
            }, { passive: false });
            
            gameContainer.addEventListener('touchcancel', (e) => {
                isPinching = false;
                lastPinchDistance = 0;
                touches = [];
                firstTouchTime = null;
                firstTouchInZone = false;
                if (pinchTimeout) {
                    clearTimeout(pinchTimeout);
                    pinchTimeout = null;
                }
                blockedTouchInfo = null;
            }, { passive: false });
        }

                function setupControls() {
            const joystick = document.getElementById('joystick');
            const joystickKnob = document.getElementById('joystickKnob');
            const gameContainer = document.getElementById('gameContainer');

            // Dynamic joystick state
            let joystickAnchorX = 0;
            let joystickAnchorY = 0;
            let activeJoystickTouch = null; // Track which touch is the joystick
            let isMouseJoystick = false; // Track if joystick is controlled by mouse
            let joystickFadeTimeout = null; // Timer for fading out joystick
            let hasExceededThreshold = false; // Track if movement exceeded threshold
            let fadeAnimationId = null; // Track fade animation frame

            // Helper function to check if touch is on an interactive button
            function isTouchOnButton(target) {
                // Check if the target or any parent is a button we want to exclude
                const excludedClasses = [
                    'gun-button',
                    'gun-button-icon',
                    'hold-up-button',
                    'hold-up-button-icon',
                    'weapon-switch-button',
                    'weapon-switch-container',
                    'weapon-switch-btn',
                    'weapon-switch-icon',
                    'minimap-container',
                    'minimap-canvas',
                    'quest-dialog',
                    'quest-dialog-button'
                ];

                let element = target;
                while (element && element !== document.body) {
                    // Check if element has any excluded class
                    for (const className of excludedClasses) {
                        if (element.classList && element.classList.contains(className)) {
                            return true;
                        }
                    }
                    // Check if element has an ID that's a button
                    if (element.id && (
                        element.id === 'gunButton' ||
                        element.id === 'holdUpButton' ||
                        element.id === 'weaponSwitchButton'
                    )) {
                        return true;
                    }
                    element = element.parentElement;
                }
                return false;
            }

            // JavaScript-based fade animation (bypasses iOS CSS transition issues)
            function fadeOutJoystick() {
                const startTime = performance.now();
                const duration = 150; // 150ms fade duration
                const startOpacity = parseFloat(window.getComputedStyle(joystick).opacity) || 1;

                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Calculate opacity (linear fade from startOpacity to 0)
                    const opacity = startOpacity * (1 - progress);
                    joystick.style.opacity = opacity;

                    if (progress < 1) {
                        // Continue animation
                        fadeAnimationId = requestAnimationFrame(animate);
                    } else {
                        // Fade complete - hide joystick
                        joystick.classList.remove('active');
                        joystick.style.opacity = '';
                        fadeAnimationId = null;
                    }
                }

                fadeAnimationId = requestAnimationFrame(animate);
            }

            // Shared joystick logic
            function activateJoystick(clientX, clientY) {
                // Set anchor point to input location
                joystickAnchorX = clientX;
                joystickAnchorY = clientY;

                // Position joystick at anchor point
                joystick.style.left = `${joystickAnchorX}px`;
                joystick.style.top = `${joystickAnchorY}px`;
                joystick.style.transform = 'translate(-50%, -50%)';

                // Cancel any ongoing fade animation
                if (fadeAnimationId) {
                    cancelAnimationFrame(fadeAnimationId);
                    fadeAnimationId = null;
                }

                // Show joystick (always visible when activated)
                joystick.classList.add('active');
                joystick.style.opacity = '1'; // Ensure fully visible
                joystick.style.display = ''; // Clear any display:none
                joystickActive = true;

                // Reset fade state
                hasExceededThreshold = false;
                if (joystickFadeTimeout) {
                    clearTimeout(joystickFadeTimeout);
                    joystickFadeTimeout = null;
                }

                // Reset knob to center
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }

            function updateJoystickPosition(clientX, clientY) {
                // Calculate delta from anchor point
                let deltaX = clientX - joystickAnchorX;
                let deltaY = clientY - joystickAnchorY;
                let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                const maxLogicalDistance = 200; // 200px maximum distance
                const maxVisualDistance = 120; // Visual radius (240px diameter / 2)
                const fadeThreshold = 40; // Distance threshold before starting fade timer

                // Check if we've exceeded the threshold for fading
                if (!hasExceededThreshold && distance > fadeThreshold) {
                    hasExceededThreshold = true;

                    // Start fade timer - fade out joystick visual after 500ms using JS animation
                    joystickFadeTimeout = setTimeout(() => {
                        fadeOutJoystick();
                    }, 500);
                }

                // Normalize direction (avoid division by zero)
                let directionX = 0;
                let directionY = 0;
                if (distance > 0) {
                    directionX = deltaX / distance;
                    directionY = deltaY / distance;
                }

                // SLIDING WINDOW ALGORITHM: If distance > 200px, reposition anchor
                if (distance > maxLogicalDistance) {
                    // Move anchor to stay 200px away from current position
                    joystickAnchorX = clientX - (directionX * maxLogicalDistance);
                    joystickAnchorY = clientY - (directionY * maxLogicalDistance);

                    // Reposition joystick visual (even if hidden, keep position updated)
                    joystick.style.left = `${joystickAnchorX}px`;
                    joystick.style.top = `${joystickAnchorY}px`;

                    // Clamp distance to max for calculations
                    distance = maxLogicalDistance;

                    // Knob should be at max distance in the drag direction
                    const visualDeltaX = directionX * maxVisualDistance;
                    const visualDeltaY = directionY * maxVisualDistance;

                    // Update knob position (offset by -40 to account for 80px knob size)
                    joystickKnob.style.transform = `translate(${visualDeltaX - 40}px, ${visualDeltaY - 40}px)`;
                } else {
                    // Within range - scale proportionally
                    const scale = distance / maxLogicalDistance;
                    const visualDeltaX = directionX * maxVisualDistance * scale;
                    const visualDeltaY = directionY * maxVisualDistance * scale;

                    // Update knob position (offset by -40 to account for 80px knob size)
                    joystickKnob.style.transform = `translate(${visualDeltaX - 40}px, ${visualDeltaY - 40}px)`;
                }

                // Update joystick vector for game logic (normalized to -1 to 1)
                // This continues to work even when joystick visual is hidden
                joystickVector.x = directionX * Math.min(distance / maxLogicalDistance, 1.0);
                joystickVector.y = directionY * Math.min(distance / maxLogicalDistance, 1.0);
            }

            function deactivateJoystick() {
                // Cancel any ongoing fade animation
                if (fadeAnimationId) {
                    cancelAnimationFrame(fadeAnimationId);
                    fadeAnimationId = null;
                }

                // Hide joystick (forcefully)
                joystick.classList.remove('active');
                joystick.style.opacity = '0';
                joystick.style.display = 'none';
                joystickActive = false;
                isMouseJoystick = false;
                activeJoystickTouch = null;

                // Clear fade timer and reset threshold flag
                if (joystickFadeTimeout) {
                    clearTimeout(joystickFadeTimeout);
                    joystickFadeTimeout = null;
                }
                hasExceededThreshold = false;

                // Reset movement
                joystickVector = { x: 0, y: 0 };
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }

            // Touch event handlers
            function handleJoystickStart(e) {
                if (playerInputDisabled || isDialogActive()) return;
                if (isMouseJoystick) return; // Don't activate if mouse joystick is active
                if (isPinching) return; // Don't activate if pinch-to-zoom is active
                if (joystickActive) return; // Don't reactivate if already active

                // Use changedTouches to get the newly added touch, not the first existing touch
                const touch = e.changedTouches[0];
                if (!touch) return;

                if (isTouchOnButton(e.target)) return;

                // Don't activate joystick if first touch is in potential pinch zone
                // (wait to see if second touch comes to form a pinch gesture)
                if (firstTouchInZone && e.touches.length === 1) return;

                e.preventDefault();

                // Store touch identifier
                activeJoystickTouch = touch.identifier;

                activateJoystick(touch.clientX, touch.clientY);
            }

            function handleJoystickMove(e) {
                if (!joystickActive || playerInputDisabled || isDialogActive()) return;
                if (isPinching) return; // Don't move joystick during pinch

                // Find the touch that matches our joystick
                let touch = null;
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === activeJoystickTouch) {
                        touch = e.touches[i];
                        break;
                    }
                }

                if (!touch) return;

                e.preventDefault();

                updateJoystickPosition(touch.clientX, touch.clientY);
            }

            function handleJoystickEnd(e) {
                if (!joystickActive) return;

                // Check if our joystick touch ended by looking at changedTouches
                let touchEnded = false;
                if (e.changedTouches) {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === activeJoystickTouch) {
                            touchEnded = true;
                            break;
                        }
                    }
                }

                if (!touchEnded) return; // Our touch is still active

                e.preventDefault();

                deactivateJoystick();
            }

            // Mouse event handlers
            function handleMouseJoystickStart(e) {
                if (playerInputDisabled || isDialogActive()) return;
                if (joystickActive && !isMouseJoystick) return; // Don't activate if touch joystick is active

                if (isTouchOnButton(e.target)) return;

                e.preventDefault();

                // Mark as mouse-controlled joystick
                isMouseJoystick = true;

                activateJoystick(e.clientX, e.clientY);
            }

            function handleMouseJoystickMove(e) {
                if (!joystickActive || !isMouseJoystick || playerInputDisabled || isDialogActive()) return;

                e.preventDefault();

                updateJoystickPosition(e.clientX, e.clientY);
            }

            function handleMouseJoystickEnd(e) {
                if (!joystickActive || !isMouseJoystick) return;

                e.preventDefault();

                deactivateJoystick();
            }

            // Attach joystick events to gameContainer instead of joystick element
            // Touch events
            gameContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
            gameContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
            gameContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
            gameContainer.addEventListener('touchcancel', handleJoystickEnd, { passive: false });

            // Mouse events
            gameContainer.addEventListener('mousedown', handleMouseJoystickStart, { passive: false });
            document.addEventListener('mousemove', handleMouseJoystickMove, { passive: false });
            document.addEventListener('mouseup', handleMouseJoystickEnd, { passive: false });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (playerInputDisabled || isDialogActive()) return; // Block input during loading or dialog

                keys[e.code] = true;
                
                // Space key triggers gun (same as tapping gun icon) - only when walking
                if (e.code === 'Space' && gameState === 'walking') {
                    e.preventDefault(); // Prevent page scrolling
                    startGunAction(true); // Space key CAN fire
                }
                
                // E key exits car when driving
                if (e.code === 'KeyE' && gameState === 'driving') {
                    e.preventDefault();
                    exitCar();
                }
                
                // Q key switches weapons when walking
                if (e.code === 'KeyQ' && gameState === 'walking') {
                    e.preventDefault();
                    switchWeapon();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false; // Always allow key ups to reset

                if (playerInputDisabled || isDialogActive()) return; // Block input during loading or dialog
                
                // Space key releases gun - only when walking
                if (e.code === 'Space' && gameState === 'walking') {
                    e.preventDefault();
                    isHoldingFire = false;
                    endGunAction();
                }
            });

            // Hold Up button handling (changes to EXIT when driving)
            const holdUpButton = document.getElementById('holdUpButton');
            
            function handleHoldUpPress() {
                if (playerInputDisabled || isDialogActive()) return; // Block input during loading or dialog

                if (gameState === 'walking') {
                    startGunAction(false); // Hold up button CANNOT fire
                    
                    // Add pressed class for scaling effect
                    holdUpButton.classList.add('pressed');
                    // Add flash effect
                    holdUpButton.classList.add('flash');
                    // Remove flash after short duration
                    setTimeout(() => {
                        holdUpButton.classList.remove('flash');
                    }, 100);
                } else if (gameState === 'driving') {
                    // Exit car when driving
                    exitCar();
                    
                    // Add pressed class for scaling effect
                    holdUpButton.classList.add('pressed');
                    // Add flash effect
                    holdUpButton.classList.add('flash');
                    // Remove flash after short duration
                    setTimeout(() => {
                        holdUpButton.classList.remove('flash');
                        holdUpButton.classList.remove('pressed');
                    }, 100);
                }
            }
            
            function handleHoldUpRelease() {
                if (playerInputDisabled || isDialogActive()) return; // Block input during loading or dialog

                if (gameState === 'walking') {
                    endGunAction();
                    // Remove pressed class
                    holdUpButton.classList.remove('pressed');
                }
                // For driving mode, button release is handled in the press function
            }
            
            // Aiming joystick cleanup function
            function cleanupAimingJoystick() {
                aimingJoystickActive = false;
                aimingJoystickDragging = false;
                aimingJoystickVector = { x: 0, y: 0 };
                activeAimingTouch = null;
                currentAimingButton = null;
                document.getElementById('gunButton')?.classList.remove('pressed');
                document.getElementById('holdUpButton')?.classList.remove('pressed');
            }

            // Aiming joystick handlers
            function handleAimingStart(e, buttonType) {
                if (playerInputDisabled || isDialogActive()) return;
                e.preventDefault();

                // Use changedTouches to get the newly added touch
                const touch = e.changedTouches[0];
                activeAimingTouch = touch.identifier;

                // Store initial position
                aimingStartX = touch.clientX;
                aimingStartY = touch.clientY;
                aimingJoystickAnchorX = touch.clientX;
                aimingJoystickAnchorY = touch.clientY;

                aimingJoystickActive = true;
                aimingJoystickDragging = false;
                currentAimingButton = buttonType; // 'fire' or 'holdup'

                // Visual feedback - button pressed
                const button = document.getElementById(
                    buttonType === 'fire' ? 'gunButton' : 'holdUpButton'
                );
                button.classList.add('pressed');

                // Start firing/holdup immediately
                if (buttonType === 'fire') {
                    handleGunPress();
                } else {
                    handleHoldUpPress();
                }
            }

            function handleAimingMove(e) {
                if (!aimingJoystickActive) return;
                if (playerInputDisabled || isDialogActive()) return;

                // Find our touch
                let touch = null;
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === activeAimingTouch) {
                        touch = e.touches[i];
                        break;
                    }
                }
                if (!touch) return;

                e.preventDefault();

                // Calculate distance from start position
                const deltaX = touch.clientX - aimingStartX;
                const deltaY = touch.clientY - aimingStartY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Check if exceeded threshold
                if (!aimingJoystickDragging && distance > AIMING_DRAG_THRESHOLD) {
                    aimingJoystickDragging = true;
                    // Continue firing/holdup while aiming (don't release)
                }

                if (aimingJoystickDragging) {
                    // Update aiming vector
                    const deltaFromAnchor = {
                        x: touch.clientX - aimingJoystickAnchorX,
                        y: touch.clientY - aimingJoystickAnchorY
                    };

                    const dist = Math.sqrt(
                        deltaFromAnchor.x * deltaFromAnchor.x +
                        deltaFromAnchor.y * deltaFromAnchor.y
                    );

                    const maxDistance = 120; // Max aiming distance

                    if (dist > 0) {
                        const dirX = deltaFromAnchor.x / dist;
                        const dirY = deltaFromAnchor.y / dist;

                        aimingJoystickVector.x = dirX * Math.min(dist / maxDistance, 1.0);
                        aimingJoystickVector.y = dirY * Math.min(dist / maxDistance, 1.0);
                    }
                }
            }

            function handleAimingEnd(e) {
                if (!aimingJoystickActive) return;

                // Check if our touch ended by looking at changedTouches
                let touchEnded = false;
                if (e.changedTouches) {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === activeAimingTouch) {
                            touchEnded = true;
                            break;
                        }
                    }
                }
                if (!touchEnded) return;

                e.preventDefault();

                // Always release the action on touch end (was active entire time)
                if (currentAimingButton === 'fire') {
                    handleGunRelease();
                } else {
                    handleHoldUpRelease();
                }

                // Cleanup
                cleanupAimingJoystick();
            }

            // Touch events for hold up button (aiming joystick)
            holdUpButton.addEventListener('touchstart', (e) => handleAimingStart(e, 'holdup'));
            holdUpButton.addEventListener('touchmove', handleAimingMove);
            holdUpButton.addEventListener('touchend', handleAimingEnd);
            holdUpButton.addEventListener('touchcancel', handleAimingEnd);

            // Global mouse handlers for aiming (set up once, used when mouse aiming is active)
            function handleGlobalMouseMove(e) {
                if (!aimingJoystickActive || !isMouseAiming) return;
                if (playerInputDisabled || isDialogActive()) return;

                // Calculate distance from start position
                const deltaX = e.clientX - aimingStartX;
                const deltaY = e.clientY - aimingStartY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Check if exceeded threshold
                if (!aimingJoystickDragging && distance > AIMING_DRAG_THRESHOLD) {
                    aimingJoystickDragging = true;
                    // Continue action while aiming (don't release)
                }

                if (aimingJoystickDragging) {
                    // Update aiming vector
                    const deltaFromAnchor = {
                        x: e.clientX - aimingJoystickAnchorX,
                        y: e.clientY - aimingJoystickAnchorY
                    };

                    const dist = Math.sqrt(
                        deltaFromAnchor.x * deltaFromAnchor.x +
                        deltaFromAnchor.y * deltaFromAnchor.y
                    );

                    const maxDistance = 120;

                    if (dist > 0) {
                        const dirX = deltaFromAnchor.x / dist;
                        const dirY = deltaFromAnchor.y / dist;

                        aimingJoystickVector.x = dirX * Math.min(dist / maxDistance, 1.0);
                        aimingJoystickVector.y = dirY * Math.min(dist / maxDistance, 1.0);
                    }
                }
            }

            function handleGlobalMouseUp(e) {
                if (!aimingJoystickActive || !isMouseAiming) return;

                // Always release the action on mouse up
                if (currentAimingButton === 'fire') {
                    handleGunRelease();
                } else {
                    handleHoldUpRelease();
                }

                // Cleanup
                cleanupAimingJoystick();
                isMouseAiming = false;

                // Remove global listeners
                document.removeEventListener('mousemove', handleGlobalMouseMove);
                document.removeEventListener('mouseup', handleGlobalMouseUp);
            }

            // Mouse events for hold up button (using aiming joystick system)
            holdUpButton.addEventListener('mousedown', (e) => {
                if (playerInputDisabled || isDialogActive()) return;
                e.preventDefault();

                isMouseAiming = true;
                aimingStartX = e.clientX;
                aimingStartY = e.clientY;
                aimingJoystickAnchorX = e.clientX;
                aimingJoystickAnchorY = e.clientY;
                aimingJoystickActive = true;
                aimingJoystickDragging = false;
                currentAimingButton = 'holdup';

                const button = document.getElementById('holdUpButton');
                button.classList.add('pressed');

                // Start holding up immediately
                handleHoldUpPress();

                // Add global mouse listeners for tracking anywhere on page
                document.addEventListener('mousemove', handleGlobalMouseMove);
                document.addEventListener('mouseup', handleGlobalMouseUp);
            });

            // Gun button tap/click handling (now 2x faster)
            const gunButton = document.getElementById('gunButton');
            
            function handleGunPress() {
                if (playerInputDisabled || isDialogActive()) return; // Block input during loading or dialog

                if (gameState === 'walking') {
                    startGunAction(true); // Gun button CAN fire

                    // Add pressed class for scaling effect
                    gunButton.classList.add('pressed');
                    // Add flash effect
                    gunButton.classList.add('flash');
                    // Remove flash after short duration
                    setTimeout(() => {
                        gunButton.classList.remove('flash');
                    }, 100);
                }
            }

            function handleGunRelease() {
                if (playerInputDisabled || isDialogActive()) return; // Block input during loading or dialog

                if (gameState === 'walking') {
                    endGunAction();
                    // Remove pressed class
                    gunButton.classList.remove('pressed');
                }
            }
            
            // Touch events for gun button (aiming joystick)
            gunButton.addEventListener('touchstart', (e) => handleAimingStart(e, 'fire'));
            gunButton.addEventListener('touchmove', handleAimingMove);
            gunButton.addEventListener('touchend', handleAimingEnd);
            gunButton.addEventListener('touchcancel', handleAimingEnd);

            // Mouse events for gun button (using aiming joystick system)
            gunButton.addEventListener('mousedown', (e) => {
                if (playerInputDisabled || isDialogActive()) return;
                e.preventDefault();

                isMouseAiming = true;
                aimingStartX = e.clientX;
                aimingStartY = e.clientY;
                aimingJoystickAnchorX = e.clientX;
                aimingJoystickAnchorY = e.clientY;
                aimingJoystickActive = true;
                aimingJoystickDragging = false;
                currentAimingButton = 'fire';

                const button = document.getElementById('gunButton');
                button.classList.add('pressed');

                // Start firing immediately
                handleGunPress();

                // Add global mouse listeners for tracking anywhere on page
                document.addEventListener('mousemove', handleGlobalMouseMove);
                document.addEventListener('mouseup', handleGlobalMouseUp);
            });

            // Weapon switch button handling
            const weaponSwitchButton = document.getElementById('weaponSwitchButton');
            
            function handleWeaponSwitch() {
                if (playerInputDisabled) return; // Block input during loading
                
                if (gameState === 'walking') {
                    switchWeapon();
                    
                    // Add pressed class for scaling effect
                    weaponSwitchButton.classList.add('pressed');
                    // Add flash effect
                    weaponSwitchButton.classList.add('flash');
                    // Remove effects after short duration
                    setTimeout(() => {
                        weaponSwitchButton.classList.remove('flash');
                        weaponSwitchButton.classList.remove('pressed');
                    }, 100);
                }
            }
            
            // Touch events for weapon switch button
            if (weaponSwitchButton) {
                weaponSwitchButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handleWeaponSwitch();
                });

                // Mouse events for weapon switch button
                weaponSwitchButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    handleWeaponSwitch();
                });
            }
            // Mouse-based camera movement removed as requested
            // All camera control now handled by keyboard A/D keys and joystick left/right movement

            // Still prevent context menu on right click for better user experience
            gameContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Click handling for minimap interaction
            gameContainer.addEventListener('click', (e) => {
                // Check if dialog is active - if so, advance dialog on any click
                if (isDialogActive()) {
                    advanceDialog();
                    return; // Don't process other click logic
                }
                
                // Check if click is on minimap
                const minimapContainer = document.querySelector('.minimap-container');
                if (minimapContainer) {
                    const minimapRect = minimapContainer.getBoundingClientRect();
                    const clickX = e.clientX;
                    const clickY = e.clientY;
                    
                    // Check if click is within minimap bounds
                    if (clickX >= minimapRect.left && clickX <= minimapRect.right &&
                        clickY >= minimapRect.top && clickY <= minimapRect.bottom) {
                        // Click is on minimap - toggle maximize/minimize
                        toggleMinimap();
                        return; // Don't process other click logic
                    }
                }
                
                // When minimap is maximized, clicking anywhere else should close it
                if (minimapMaximized) {
                    toggleMinimap();
                    return; // Don't process other click logic
                }
                
                const rect = renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // Play mode - no click interaction with world objects
            });
            
            // Setup camera zoom controls
            setupCameraZoomControls();
        }












        // addCube function removed









                function updateShadowPlane() {
            if (!shadowPlane || !character) return;
            
            // Don't update shadow when player is in car, fading out, or fading in
            if (gameState === 'driving' || character.userData.isFadingOut || character.userData.isInCar) return;
            
            // Get character position
            const charX = character.position.x;
            const charZ = character.position.z;
            
            // Check what surface the character is standing on
            const collision = checkCollisions(charX, charZ, character.position.y);
            const groundHeight = collision.groundHeight;
            
            // Check if player is inside an interior (curb interior = location state 2)
            const isInInterior = character.userData.isOnCurb === 2;
            
            // Calculate shadow height: base 0.01 + extra 0.01 if in interior
            const shadowHeight = groundHeight + 0.01 + (isInInterior ? 0.01 : 0);
            
            // Position shadow plane just above the ground/surface
            shadowPlane.position.set(charX, shadowHeight, charZ);
        }

        function updateDebugDisplay() {
            const debugElement = document.getElementById('debugCoords');
            if (!debugElement) return;

            if (showDebugCoordinates) {
                debugElement.classList.remove('hidden');
                debugElement.style.display = 'block';
                if (character && shadowPlane) {
                    const x = character.position.x.toFixed(1);
                    const y = character.position.y.toFixed(1);
                    const z = character.position.z.toFixed(1);
                    const shadowY = shadowPlane.position.y.toFixed(3);
                    const locationState = character.userData.isOnCurb || 0;
                    const locationNames = ['Road', 'Curb', 'Interior'];
                    const locationName = locationNames[locationState] || 'Unknown';
                    debugElement.textContent = `X: ${x}, Y: ${y}, Z: ${z}, Shadow Y: ${shadowY}, Location: ${locationName}`;
                }
            } else {
                debugElement.classList.add('hidden');
                debugElement.style.display = 'none';
            }
        }

        // FPS tracking variables
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fpsTime = 0;
        let currentFPS = 0;

        // Game loop timing
        let lastGameLoopTime = performance.now();
        let globalDeltaTime = 0.016; // Current frame's delta time, updated each frame

        function updateFPSCounter(currentTime) {
            const fpsElement = document.getElementById('fpsDisplay');

            // Show or hide FPS display based on DEBUG_SHOW_FPS
            if (fpsElement) {
                fpsElement.style.display = DEBUG_SHOW_FPS ? 'block' : 'none';
            }

            if (!DEBUG_SHOW_FPS) {
                lastFrameTime = currentTime;
                return;
            }

            frameCount++;
            const deltaMs = currentTime - lastFrameTime;
            fpsTime += deltaMs;

            // Update FPS display every 500ms for stability
            if (fpsTime >= 500) {
                currentFPS = Math.round((frameCount * 1000) / fpsTime);
                frameCount = 0;
                fpsTime = 0;

                // Update FPS display
                if (fpsElement) {
                    fpsElement.textContent = `FPS: ${currentFPS}`;
                }
            }

            lastFrameTime = currentTime;
        }

        function gameLoop() {
            const currentTime = performance.now();
            updateFPSCounter(currentTime);

            // Calculate actual delta time in seconds
            globalDeltaTime = (currentTime - lastGameLoopTime) / 1000;
            // Cap delta time to prevent huge jumps (e.g., when tab is unfocused)
            globalDeltaTime = Math.min(globalDeltaTime, 0.1);
            lastGameLoopTime = currentTime;

            const deltaTime = globalDeltaTime;

            // Update loading screen
            if (loadingScreenActive) {
                updateLoadingScreen();
            }

            updateMovement(deltaTime);

            // Handle automatic fire for Uzi
            if (isHoldingFire && currentWeapon === 'uzi' && gameState === 'walking') {
                fireGun();
            }

            // Update weapon switch cooldown
            if (weaponSwitchCooldown > 0) {
                weaponSwitchCooldown -= deltaTime;
            }

            // Update camera shake
            if (cameraShakeDuration > 0) {
                cameraShakeDuration -= deltaTime;
                if (cameraShakeDuration <= 0) {
                    cameraShakeIntensity = 0;
                }
            }

            // Update active explosions
            for (let i = activeExplosions.length - 1; i >= 0; i--) {
                const explosion = activeExplosions[i];
                explosion.scale += 0.5;
                explosion.mesh.scale.set(explosion.scale, explosion.scale, explosion.scale);
                explosion.mesh.material.opacity -= explosion.fadeSpeed;

                if (explosion.mesh.material.opacity <= 0 || explosion.scale >= explosion.maxScale) {
                    scene.remove(explosion.mesh);
                    activeExplosions.splice(i, 1);
                }
            }
            
            // Check quest objectives - use appropriate checker based on quest type
            if (currentQuest && currentMode === 'play') {
                if (currentQuest.objective) {
                    // Chain quest - has objective property
                    checkQuestObjective(deltaTime);
                } else if (currentQuest.target) {
                    // Random quest - has target property
                    checkQuestProgress();
                }
            }

            // Update NPC movement
            if (currentMode === 'play') {
                npcCharacters.forEach(npc => {
                    updateNPCMovement(npc, deltaTime);
                });

                // Despawn aggressive police officers that are >200m from player
                if (character) {
                    npcCharacters.forEach(npc => {
                        if (npc.userData.isPoliceOfficer && npc.userData.isAggressive) {
                            const distanceToPlayer = Math.sqrt(
                                Math.pow(character.position.x - npc.position.x, 2) +
                                Math.pow(character.position.z - npc.position.z, 2)
                            );

                            if (distanceToPlayer > 200) {
                                // Remove from scene
                                scene.remove(npc);
                                if (npc.userData.shadowPlane) {
                                    scene.remove(npc.userData.shadowPlane);
                                }
                                // Mark for removal from array
                                npc.userData.shouldRemove = true;
                            }
                        }
                    });

                    // Remove NPCs marked for removal
                    npcCharacters = npcCharacters.filter(npc => !npc.userData.shouldRemove);
                }

                // Update vendor NPCs
                vendorNPCs.forEach(vendor => {
                    updateVendorNPC(vendor, deltaTime);
                });
                
                // Update quest giver NPCs
                questGivers.forEach(questGiver => {
                    updateQuestGiverNPC(questGiver, deltaTime);
                });
                
                // Update car movement
                carObjects.forEach(car => {
                    updateCarMovement(car, deltaTime);
                });

                // Remove cars marked for removal (stopped police cars beyond 200m)
                carObjects = carObjects.filter(car => !car.userData.shouldRemove);

                // Update cash bundles
                updateCashBundles(deltaTime);
                
                // Update health packs
                updateHealthPacks(deltaTime);
                
                // Update particles
                updateParticles(deltaTime);
                
                // Update projectiles
                updateProjectiles(deltaTime);

                // Update quest system
                checkForQuestStart();
                updateQuestTargetCircle();
                cleanupCompletedQuestNPCs();

                // Update world arrow
                updateWorldArrow();
            }
            
            updateCamera();
            updateShadowPlane();
            updateDebugDisplay();
            updateMinimap();

            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }
        
        function updateProjectiles(deltaTime) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                if (!projectile.userData.isProjectile) continue;

                // Update position
                const moveX = projectile.userData.velocity.x * deltaTime;
                const moveZ = projectile.userData.velocity.z * deltaTime;

                projectile.position.x += moveX;
                projectile.position.z += moveZ;

                // Check for building collision
                const buildingCollision = checkCollisions(
                    projectile.position.x,
                    projectile.position.z,
                    projectile.position.y
                );

                // If projectile is inside a building or hits a wall
                if (!buildingCollision.canMove) {
                    if (projectile.userData.explosive) {
                        // Rockets explode on building impact
                        createExplosion(
                            projectile.position.x,
                            projectile.position.y,
                            projectile.position.z,
                            projectile.userData.explosionRadius
                        );
                    }
                    // Remove projectile (regular bullets just disappear)
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Add smoke trail for rockets
                if (projectile.userData.explosive) {
                    projectile.userData.smokeTimer += deltaTime;
                    if (projectile.userData.smokeTimer >= 0.05) { // Smoke every 50ms
                        projectile.userData.smokeTimer = 0;
                        spawnSmokeParticle(projectile.position.x, projectile.position.y, projectile.position.z);
                    }
                }

                // Update distance traveled
                const frameDist = Math.sqrt(moveX * moveX + moveZ * moveZ);
                projectile.userData.distanceTraveled += frameDist;

                // Check for collisions based on projectile type
                let hitTarget = false;
                
                if (projectile.userData.isPoliceProjectile) {
                    // Police projectile - check collision with player
                    if (character && gameState === 'walking') {
                        const distanceToPlayer = Math.sqrt(
                            Math.pow(projectile.position.x - character.position.x, 2) + 
                            Math.pow(projectile.position.z - character.position.z, 2)
                        );
                        
                        // Player collision radius: 0.9 units wide, so 0.45 unit radius + projectile size
                        const playerCollisionDistance = 0.45 + 0.1;
                        
                        if (distanceToPlayer <= playerCollisionDistance) {
                            // Police bullet hit player!
                            handlePoliceProjectilePlayerCollision(projectile);
                            
                            // Remove projectile
                            scene.remove(projectile);
                            projectiles.splice(i, 1);
                            hitTarget = true;
                        }
                    }
                } else {
                    // Player projectile - check collision with NPCs
                    npcCharacters.forEach((npc, npcIndex) => {
                        if (hitTarget) return; // Skip if already hit an NPC

                        // Calculate distance to NPC
                        const distanceToNPC = Math.sqrt(
                            Math.pow(projectile.position.x - npc.position.x, 2) +
                            Math.pow(projectile.position.z - npc.position.z, 2)
                        );

                        // Check collision with NPC's expanded bounding box (1.5x larger for easier hits)
                        // NPC is roughly 0.9 units wide, so use 0.675 unit radius (1.5x) + actual projectile size
                        const projectileRadius = projectile.userData.explosive ? 0.5 : 0.2; // Rockets are bigger
                        const collisionDistance = 0.675 + projectileRadius;

                        if (distanceToNPC <= collisionDistance) {
                            // Bullet hit NPC!
                            if (projectile.userData.explosive) {
                                // Rocket hit NPC directly - kill immediately AND create explosion
                                // First, apply direct hit damage (same as regular bullet)
                                handleBulletNPCCollision(projectile, npc, npcIndex);

                                // Then create explosion for area damage
                                createExplosion(
                                    projectile.position.x,
                                    projectile.position.y,
                                    projectile.position.z,
                                    projectile.userData.explosionRadius
                                );
                            } else {
                                // Regular bullet damage
                                handleBulletNPCCollision(projectile, npc, npcIndex);
                            }

                            // Remove projectile
                            scene.remove(projectile);
                            projectiles.splice(i, 1);
                            hitTarget = true;
                            return;
                        }
                    });

                    // Check collision with cars (only for player projectiles)
                    if (!hitTarget && projectile.userData.explosive) {
                        carObjects.forEach(car => {
                            if (hitTarget) return; // Skip if already hit something
                            if (car.userData.isDestroyed) return; // Skip destroyed cars

                            // Calculate distance to car
                            const distanceToCar = Math.sqrt(
                                Math.pow(projectile.position.x - car.position.x, 2) +
                                Math.pow(projectile.position.z - car.position.z, 2)
                            );

                            // Car collision radius: 3.5 units + rocket radius 0.5
                            const carCollisionDistance = 4.0;

                            if (distanceToCar <= carCollisionDistance) {
                                // Rocket hit car!
                                handleRocketCarCollision(projectile, car);

                                // Remove projectile
                                scene.remove(projectile);
                                projectiles.splice(i, 1);
                                hitTarget = true;
                                return;
                            }
                        });
                    }
                }

                if (hitTarget) continue; // Skip distance check if we hit a target

                // Check for ground collision (rockets explode on ground)
                if (projectile.userData.explosive && projectile.position.y <= 0.5) {
                    createExplosion(
                        projectile.position.x,
                        projectile.position.y,
                        projectile.position.z,
                        projectile.userData.explosionRadius
                    );
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }

                // Remove projectile if it has traveled max distance
                if (projectile.userData.distanceTraveled >= projectile.userData.maxDistance) {
                    if (projectile.userData.explosive) {
                        // Rocket explodes at max range
                        createExplosion(
                            projectile.position.x,
                            projectile.position.y,
                            projectile.position.z,
                            projectile.userData.explosionRadius
                        );
                    }
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        function handleBulletNPCCollision(projectile, npc, npcIndex) {
            // Calculate bullet direction for pushing NPC
            const bulletDirectionX = projectile.userData.velocity.x;
            const bulletDirectionZ = projectile.userData.velocity.z;
            const bulletSpeed = Math.sqrt(bulletDirectionX * bulletDirectionX + bulletDirectionZ * bulletDirectionZ);
            
            // Normalize bullet direction
            const normalizedDirX = bulletDirectionX / bulletSpeed;
            const normalizedDirZ = bulletDirectionZ / bulletSpeed;
            
            // Apply force to NPC in bullet direction (ground-only push, no flying)
            const pushForce = 15; // Moderate ground push force
            const pushForceX = normalizedDirX * pushForce;
            const pushForceZ = normalizedDirZ * pushForce;
            const pushForceY = 0; // NO upward force - NPCs stay on ground
            
            // Initialize NPC physics if not present
            if (!npc.userData.velocity) {
                npc.userData.velocity = { x: 0, y: 0, z: 0 };
            }
            
            // Apply ground-only pushing forces to NPC
            npc.userData.velocity.x = pushForceX;
            npc.userData.velocity.y = pushForceY;
            npc.userData.velocity.z = pushForceZ;
            npc.userData.onGround = true; // NPC stays on ground
            npc.userData.isFlying = false; // No flying when shot
            
            // No Y-axis rotation - NPC stays upright
            npc.userData.rotationSpeed = 0;
            
            // Start ground sliding with gradual slowdown
            npc.userData.isSliding = true;
            npc.userData.slideDecelerationRate = 8; // Gradual slowdown rate

            // Stop aggressive behavior immediately (unique to bullet death)
            npc.userData.isAggressive = false;
            npc.userData.isShooting = false;

            // Kill NPC with common death setup
            killNPC(npc);

            console.log(`Bullet hit NPC! NPC pushed with great force. Wanted level: ${wantedLevel}/${maxWantedLevel}`);
        }

        function handlePoliceProjectilePlayerCollision(projectile) {
            // Police bullet hit player - damage player health
            damagePlayer(20); // Police bullets do 20% damage
            
            // Calculate bullet direction for visual effects
            const bulletDirectionX = projectile.userData.velocity.x;
            const bulletDirectionZ = projectile.userData.velocity.z;
            const bulletSpeed = Math.sqrt(bulletDirectionX * bulletDirectionX + bulletDirectionZ * bulletDirectionZ);
            
            // Normalize bullet direction
            const normalizedDirX = bulletDirectionX / bulletSpeed;
            const normalizedDirZ = bulletDirectionZ / bulletSpeed;
            
            // Apply small knockback to player
            const knockbackForce = 5; // Small knockback
            const knockbackX = normalizedDirX * knockbackForce;
            const knockbackZ = normalizedDirZ * knockbackForce;
            
            // Initialize player physics for knockback if not present
            if (!character.userData.velocity) {
                character.userData.velocity = { x: 0, y: 0, z: 0 };
            }
            
            // Apply knockback
            character.userData.velocity.x = knockbackX;
            character.userData.velocity.z = knockbackZ;
            character.userData.hasKickbackVelocity = true;
                        
            // Spawn burst of red particles at player position
            spawnRedParticleBurst(character.position.x, character.position.y + 1, character.position.z);
        }

        function handleRocketCarCollision(projectile, car) {
            // Mark car as destroyed
            car.userData.isDestroyed = true;

            // Raise wanted level to 2 stars (or 3 if police nearby)
            setWantedLevelForInfraction(2);
            
            // Create massive car explosion
            const explosionRadius = 8; // Bigger than normal explosions
            createExplosion(
                car.position.x,
                car.position.y + 2, // Explosion at car center height
                car.position.z,
                explosionRadius
            );

            // Check if player is in this car
            if (currentCar === car && gameState === 'driving') {
                // Eject player from car
                exitCar();

                // Damage player significantly
                damagePlayer(50); // 50% damage from car explosion

                // Launch player away from explosion
                if (!character.userData.velocity) {
                    character.userData.velocity = { x: 0, y: 0, z: 0 };
                }

                // Calculate direction from car to player
                const dirX = character.position.x - car.position.x;
                const dirZ = character.position.z - car.position.z;
                const distance = Math.sqrt(dirX * dirX + dirZ * dirZ) || 1;

                // Normalize and apply massive force
                const launchForce = 30;
                character.userData.velocity.x = (dirX / distance) * launchForce;
                character.userData.velocity.y = 20; // Launch upward
                character.userData.velocity.z = (dirZ / distance) * launchForce;
                character.userData.onGround = false;
                character.userData.isFlying = true;
            }

            // Spawn car parts flying
            spawnCarDebris(car.position.x, car.position.y, car.position.z);

            // Make car parts fly apart
            if (car.userData.upperBody) {
                car.userData.upperBody.userData.isFlying = true;
                car.userData.upperBody.userData.velocity = {
                    x: (Math.random() - 0.5) * 20,
                    y: 15 + Math.random() * 10,
                    z: (Math.random() - 0.5) * 20
                };
            }

            // Make tires fly off
            if (car.userData.tires) {
                car.userData.tires.forEach(tire => {
                    tire.userData.isFlying = true;
                    tire.userData.velocity = {
                        x: (Math.random() - 0.5) * 30,
                        y: 10 + Math.random() * 15,
                        z: (Math.random() - 0.5) * 30
                    };
                    tire.userData.angularVelocity = (Math.random() - 0.5) * 10;
                });
            }

            // Change car color to burnt/charred
            if (car.userData.lowerBody) {
                // Create new dark material for destroyed car
                car.userData.lowerBody.material = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            }
            if (car.userData.upperBody) {
                // Create new darker material for destroyed car upper body
                car.userData.upperBody.material = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            }

            // Stop car movement
            car.userData.moveSpeed = 0;
            car.userData.speed = 0;
            car.userData.state = 'destroyed';

            // Area damage to nearby NPCs and cars
            checkAreaDamage(car.position.x, car.position.y, car.position.z, explosionRadius);

            // Check for chain reactions with nearby cars
            carObjects.forEach(otherCar => {
                if (otherCar === car || otherCar.userData.isDestroyed) return;

                const distanceToOtherCar = Math.sqrt(
                    Math.pow(car.position.x - otherCar.position.x, 2) +
                    Math.pow(car.position.z - otherCar.position.z, 2)
                );

                // Chain reaction if another car is within explosion radius
                if (distanceToOtherCar <= explosionRadius) {
                    // Delay chain reaction slightly for dramatic effect
                    setTimeout(() => {
                        if (!otherCar.userData.isDestroyed) {
                            // Create a fake projectile to trigger the explosion
                            const fakeProjectile = { userData: { explosive: true } };
                            handleRocketCarCollision(fakeProjectile, otherCar);
                        }
                    }, 100 + Math.random() * 300); // 100-400ms delay
                }
            });
        }

        function spawnCarDebris(x, y, z) {
            // Spawn metal debris particles
            const debrisCount = 40;
            for (let i = 0; i < debrisCount; i++) {
                const debrisGeometry = new THREE.BoxGeometry(
                    0.3 + Math.random() * 0.5,
                    0.2 + Math.random() * 0.3,
                    0.3 + Math.random() * 0.5
                );

                // Metal colors - gray to dark gray
                const grayValue = 0.2 + Math.random() * 0.3;
                const debrisMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color(grayValue, grayValue, grayValue)
                });

                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.set(x, y + 2, z);

                // Random velocity for debris - MUCH FASTER
                const speed = 30 + Math.random() * 40; // Doubled speed range
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.5; // Mostly upward

                debris.userData = {
                    isParticle: true,
                    isCarDebris: true, // Flag for special gravity
                    velocity: {
                        x: Math.sin(phi) * Math.cos(theta) * speed,
                        y: Math.cos(phi) * speed + 20, // More upward velocity
                        z: Math.sin(phi) * Math.sin(theta) * speed
                    },
                    life: 3.0, // 3 second lifetime
                    maxLife: 3.0,
                    scaleTime: 0, // Required for particle system
                    flickerTime: 0, // Required for particle system
                    angularVelocity: {
                        x: (Math.random() - 0.5) * 10,
                        y: (Math.random() - 0.5) * 10,
                        z: (Math.random() - 0.5) * 10
                    }
                };

                scene.add(debris);
                if (!window.gameParticles) window.gameParticles = [];
                window.gameParticles.push(debris);
            }

            // Spawn fire particles
            for (let i = 0; i < 20; i++) {
                spawnExplosionParticles(x, y + 1, z);
            }
        }

        function updateParticles(deltaTime) {
            if (!window.gameParticles) return;
            
            for (let i = window.gameParticles.length - 1; i >= 0; i--) {
                const particle = window.gameParticles[i];
                if (!particle.userData.isParticle) continue;
                
                // Update particle physics
                // Car debris has much higher gravity for faster falling
                const gravity = particle.userData.isCarDebris ? -40 : -9.8;
                particle.userData.velocity.y += gravity * deltaTime;
                
                // Update position
                particle.position.x += particle.userData.velocity.x * deltaTime;
                particle.position.y += particle.userData.velocity.y * deltaTime;
                particle.position.z += particle.userData.velocity.z * deltaTime;

                // Update rotation for debris particles
                if (particle.userData.angularVelocity) {
                    particle.rotation.x += particle.userData.angularVelocity.x * deltaTime;
                    particle.rotation.y += particle.userData.angularVelocity.y * deltaTime;
                    particle.rotation.z += particle.userData.angularVelocity.z * deltaTime;
                }

                // Update lifetime
                particle.userData.life -= deltaTime;
                
                // Fade out particle
                const alpha = particle.userData.life / particle.userData.maxLife;
                particle.material.opacity = alpha;
                particle.material.transparent = true;

                // Skip scale/color effects for car debris (it's solid metal)
                if (particle.userData.isCarDebris) {
                    // Car debris stays solid size, no flickering
                    // Just update rotation handled earlier, no other effects needed
                } else {
                    // Update scale fluctuation (rapidly fluctuate between 1x and 2x)
                    particle.userData.scaleTime += deltaTime * 10; // Fast fluctuation
                    const scaleMultiplier = 1.0 + Math.sin(particle.userData.scaleTime) * 0.5; // 1.0 to 2.0
                    particle.scale.setScalar(scaleMultiplier);

                    // Update color flicker based on particle type
                    particle.userData.flickerTime += deltaTime * 8; // Flicker frequency
                    const flickerIntensity = 0.5 + Math.abs(Math.sin(particle.userData.flickerTime)) * 0.5; // 0.5 to 1.0

                    // Check particle type and apply appropriate behavior
                    if (particle.userData.isSmokeParticle) {
                        // Smoke particles - simple fade and gentle movement
                        // No color changes, just fade out and slow physics
                        particle.userData.velocity.x *= 0.98; // Slow down horizontal movement
                        particle.userData.velocity.z *= 0.98;
                        particle.userData.velocity.y *= 0.95; // Slow down vertical movement less
                    } else if (particle.userData.isYellowWhite) {
                        // Yellow/white gun particles - bright colors with 100% self-illumination
                        const yellowIntensity = 0.9 + Math.random() * 0.1; // 0.9 to 1.0 (bright)
                        const whiteComponent = 0.8 + Math.random() * 0.2; // 0.8 to 1.0 (bright white)
                        particle.material.color.setRGB(yellowIntensity, yellowIntensity, whiteComponent);
                        // Keep 100% self-illumination - no transparency changes for MeshBasicMaterial
                    } else {
                        // Other particle types
                        const currentColor = particle.material.color;
                        if (currentColor.r > currentColor.g && currentColor.r > currentColor.b) {
                            // Red/maroon particle - flicker between red and lighter reds
                            const redTint = flickerIntensity * 0.8 + Math.random() * 0.2; // Add randomness
                            const maroonComponent = Math.random() * 0.3; // 0 to 0.3 for maroon tint
                            particle.material.color.setRGB(redTint, maroonComponent, maroonComponent);
                        } else {
                            // Green particle - original green flicker behavior
                            const whiteTint = flickerIntensity * 0.8 + Math.random() * 0.2; // Add randomness
                            particle.material.color.setRGB(whiteTint, 1.0, whiteTint); // Green with varying white tint
                        }
                    }
                }
                
                // Remove dead particles
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    window.gameParticles.splice(i, 1);
                }
            }
        }

        function updateUIForGameState() {
            const holdUpButton = document.getElementById('holdUpButton');
            const gunButton = document.getElementById('gunButton');
            const weaponSwitchButton = document.getElementById('weaponSwitchButton');

            const holdUpIcon = document.getElementById('holdUpIcon');

            if (gameState === 'driving') {
                // Change hold up button icon to car exit icon
                if (holdUpIcon) {
                    const exitAsset = lib.getAsset('ui_car_exit_icon');
                    if (exitAsset) {
                        holdUpIcon.style.background = `url(${exitAsset.url}) center/contain no-repeat transparent`;
                    }
                }
                // Fade out gun button and weapon switch button
                if (gunButton) {
                    gunButton.style.opacity = '0.3';
                    gunButton.style.pointerEvents = 'none';
                }
                if (weaponSwitchButton) {
                    weaponSwitchButton.style.opacity = '0.3';
                    weaponSwitchButton.style.pointerEvents = 'none';
                }
            } else {
                // Change back to hold up icon
                if (holdUpIcon) {
                    const holdUpAsset = lib.getAsset('ui_holdup_icon');
                    if (holdUpAsset) {
                        holdUpIcon.style.background = `url(${holdUpAsset.url}) center/contain no-repeat transparent`;
                    }
                }
                // Fade gun button and weapon switch button back in
                if (gunButton) {
                    gunButton.style.opacity = '1';
                    gunButton.style.pointerEvents = 'auto';
                }
                if (weaponSwitchButton) {
                    weaponSwitchButton.style.opacity = '1';
                    weaponSwitchButton.style.pointerEvents = 'auto';
                }
            }
        }

        function initializeMinimap() {
            minimapCanvas = document.getElementById('minimapCanvas');
            if (minimapCanvas) {
                minimapCtx = minimapCanvas.getContext('2d');
                minimapCtx.imageSmoothingEnabled = false; // Pixelated style

                // Create offscreen canvas for rendering at full opacity
                minimapOffscreenCanvas = document.createElement('canvas');
                minimapOffscreenCtx = minimapOffscreenCanvas.getContext('2d');
                minimapOffscreenCtx.imageSmoothingEnabled = false; // Pixelated style
            }
        }

        let minimapMaximized = false;
        let minimapOriginalSize = { width: 200, height: 200 };
        let minimapMaximizedSize = { width: 720, height: 720 };

        function updateMinimap() {
            if (!minimapCtx || !character) return;

            const canvas = minimapCanvas;
            const size = minimapMaximized ? minimapMaximizedSize.width : minimapOriginalSize.width;
            const worldSize = getWorldSize();
            const scale = size / worldSize; // Scale factor from world to minimap

            // Update canvas sizes if needed
            if (canvas.width !== size || canvas.height !== size) {
                canvas.width = size;
                canvas.height = size;
            }
            if (minimapOffscreenCanvas.width !== size || minimapOffscreenCanvas.height !== size) {
                minimapOffscreenCanvas.width = size;
                minimapOffscreenCanvas.height = size;
            }

            // Draw to offscreen canvas at full opacity
            const ctx = minimapOffscreenCtx;

            // Clear offscreen canvas
            ctx.clearRect(0, 0, size, size);

            // Get player position
            const playerX = gameState === 'driving' && currentCar ? currentCar.position.x : character.position.x;
            const playerZ = gameState === 'driving' && currentCar ? currentCar.position.z : character.position.z;

            // Calculate minimap center offset to keep player centered
            const centerX = size / 2;
            const centerZ = size / 2;

            // Save the current transformation matrix
            ctx.save();

            // Apply 180-degree rotation around the center of the minimap
            ctx.translate(centerX, centerZ);
            ctx.rotate(Math.PI); // 180 degrees in radians
            ctx.translate(-centerX, -centerZ);

            // Draw world background (dark asphalt)
            ctx.fillStyle = '#2F2F2F';
            ctx.fillRect(0, 0, size, size);

            // Draw water (blue area around the world)
            const worldBoundary = worldSize / 2;
            ctx.fillStyle = '#1E90FF'; // Dodger blue for water

            // Draw water as four rectangles around the world edges
            const waterThickness = worldSize; // Extend far beyond world

            // North water
            const northWaterRelativeZ = -worldBoundary - waterThickness/2 - playerZ;
            const northWaterMapZ = centerZ + northWaterRelativeZ * scale;
            const waterWidth = (worldSize + waterThickness * 2) * scale;
            const waterHeight = waterThickness * scale;
            ctx.fillRect(
                centerX - waterWidth/2,
                northWaterMapZ - waterHeight/2,
                waterWidth,
                waterHeight
            );

            // South water
            const southWaterRelativeZ = worldBoundary + waterThickness/2 - playerZ;
            const southWaterMapZ = centerZ + southWaterRelativeZ * scale;
            ctx.fillRect(
                centerX - waterWidth/2,
                southWaterMapZ - waterHeight/2,
                waterWidth,
                waterHeight
            );

            // East water
            const eastWaterRelativeX = worldBoundary + waterThickness/2 - playerX;
            const eastWaterMapX = centerX + eastWaterRelativeX * scale;
            const waterWidthVertical = waterThickness * scale;
            const waterHeightVertical = worldSize * scale;
            ctx.fillRect(
                eastWaterMapX - waterWidthVertical/2,
                centerZ - waterHeightVertical/2,
                waterWidthVertical,
                waterHeightVertical
            );

            // West water
            const westWaterRelativeX = -worldBoundary - waterThickness/2 - playerX;
            const westWaterMapX = centerX + westWaterRelativeX * scale;
            ctx.fillRect(
                westWaterMapX - waterWidthVertical/2,
                centerZ - waterHeightVertical/2,
                waterWidthVertical,
                waterHeightVertical
            );

            // Draw docks (brown wooden platforms)
            if (worldDocks) {
                ctx.fillStyle = '#8B4513'; // Saddle brown for wood
                worldDocks.forEach(dock => {
                    const relativeX = dock.x - playerX;
                    const relativeZ = dock.z - playerZ;

                    const mapX = centerX + relativeX * scale;
                    const mapZ = centerZ + relativeZ * scale;

                    const dockWidth = (dock.width || 30) * scale;
                    const dockLength = (dock.length || 70) * scale;

                    // Save context for rotation
                    ctx.save();
                    ctx.translate(mapX, mapZ);
                    ctx.rotate(dock.rotation || 0);
                    ctx.fillRect(-dockWidth/2, -dockLength/2, dockWidth, dockLength);
                    ctx.restore();
                });
            }

            // Draw curbs (concrete squares) - draw first so buildings appear on top
            ctx.fillStyle = '#6A6A6A';
            worldCubes.forEach(cube => {
                if (cube.height <= 1 && cube.asset === 'concrete_texture') { // Curb squares
                    const relativeX = cube.x - playerX;
                    const relativeZ = cube.z - playerZ;

                    const mapX = centerX + relativeX * scale;
                    const mapZ = centerZ + relativeZ * scale;

                    const curbSize = cube.size * scale;

                    if (mapX > -curbSize && mapX < size + curbSize &&
                        mapZ > -curbSize && mapZ < size + curbSize) {
                        ctx.fillRect(
                            mapX - curbSize/2,
                            mapZ - curbSize/2,
                            curbSize,
                            curbSize
                        );
                    }
                }
            });

            // Draw buildings (concrete squares with buildings) - draw after curbs
            ctx.fillStyle = '#505050';
            worldCubes.forEach(cube => {
                if (cube.height > 50) { // Only tall buildings
                    // Convert world coordinates to minimap coordinates relative to player
                    const relativeX = cube.x - playerX;
                    const relativeZ = cube.z - playerZ;

                    // Apply camera orientation (top-down view looking at Z-axis)
                    const mapX = centerX + relativeX * scale;
                    const mapZ = centerZ + relativeZ * scale;

                    const buildingSize = cube.size * scale;

                    // Only draw if within minimap bounds
                    if (mapX > -buildingSize && mapX < size + buildingSize &&
                        mapZ > -buildingSize && mapZ < size + buildingSize) {
                        ctx.fillRect(
                            mapX - buildingSize/2,
                            mapZ - buildingSize/2,
                            buildingSize,
                            buildingSize
                        );
                    }
                }
            });
            
            // Draw parks (green areas)
            ctx.fillStyle = '#4CAF50';
            worldCubes.forEach(cube => {
                if (cube.height <= 1 && cube.asset === 'new_grass_texture') { // Park areas
                    const relativeX = cube.x - playerX;
                    const relativeZ = cube.z - playerZ;
                    
                    const mapX = centerX + relativeX * scale;
                    const mapZ = centerZ + relativeZ * scale;
                    
                    const parkSize = cube.size * scale;
                    
                    if (mapX > -parkSize && mapX < size + parkSize && 
                        mapZ > -parkSize && mapZ < size + parkSize) {
                        ctx.fillRect(
                            mapX - parkSize/2, 
                            mapZ - parkSize/2, 
                            parkSize, 
                            parkSize
                        );
                    }
                }
            });
            
            // Draw cars as small rectangles
            carObjects.forEach(car => {
                const relativeX = car.position.x - playerX;
                const relativeZ = car.position.z - playerZ;

                const mapX = centerX + relativeX * scale;
                const mapZ = centerZ + relativeZ * scale;

                const carSize = minimapMaximized ? 12 : 6; // Twice as big (was 6:3, now 12:6)

                if (mapX > -carSize && mapX < size + carSize &&
                    mapZ > -carSize && mapZ < size + carSize) {
                    // Police cars are blue, civilian cars are yellow
                    ctx.fillStyle = car.userData.isPolice ? '#4444FF' : '#CCCC00';
                    ctx.fillRect(
                        mapX - carSize/2,
                        mapZ - carSize/2,
                        carSize,
                        carSize
                    );
                }
            });
            
            // Draw NPCs as small dots
            npcCharacters.forEach(npc => {
                const relativeX = npc.position.x - playerX;
                const relativeZ = npc.position.z - playerZ;
                
                const mapX = centerX + relativeX * scale;
                const mapZ = centerZ + relativeZ * scale;
                
                const npcSize = minimapMaximized ? 4 : 2; // Bigger when maximized
                
                if (mapX > -npcSize && mapX < size + npcSize && 
                    mapZ > -npcSize && mapZ < size + npcSize) {
                    
                    // Check if this NPC is a police officer by examining their body material color
                    let isPoliceOfficer = false;
                    if (npc.children && npc.children.length > 0) {
                        // Find the body mesh (first child with materials)
                        const bodyMesh = npc.children.find(child => child.material && Array.isArray(child.material));
                        if (bodyMesh && bodyMesh.material[4] && bodyMesh.material[4].color) {
                            // Check if front face material is blue (police officer)
                            isPoliceOfficer = bodyMesh.material[4].color.getHex() === 0x0000FF;
                        }
                    }
                    
                    // Set color based on NPC type
                    if (isPoliceOfficer) {
                        ctx.fillStyle = '#00BFFF'; // Bright blue for police officers
                    } else {
                        ctx.fillStyle = '#000080'; // Dark blue for regular NPCs
                    }
                    
                    ctx.beginPath();
                    ctx.arc(mapX, mapZ, npcSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Draw vendor NPCs as purple dots
            ctx.fillStyle = '#800080'; // Purple for vendors
            vendorNPCs.forEach(vendor => {
                const relativeX = vendor.position.x - playerX;
                const relativeZ = vendor.position.z - playerZ;
                
                const mapX = centerX + relativeX * scale;
                const mapZ = centerZ + relativeZ * scale;
                
                const vendorSize = minimapMaximized ? 4 : 2; // Bigger when maximized
                
                if (mapX > -vendorSize && mapX < size + vendorSize && 
                    mapZ > -vendorSize && mapZ < size + vendorSize) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapZ, vendorSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Draw quest giver NPCs as gold dots
            ctx.fillStyle = '#FFD700'; // Gold for quest givers
            questGivers.forEach(questGiver => {
                const relativeX = questGiver.position.x - playerX;
                const relativeZ = questGiver.position.z - playerZ;
                
                const mapX = centerX + relativeX * scale;
                const mapZ = centerZ + relativeZ * scale;
                
                const questGiverSize = minimapMaximized ? 4 : 2; // Bigger when maximized
                
                if (mapX > -questGiverSize && mapX < size + questGiverSize && 
                    mapZ > -questGiverSize && mapZ < size + questGiverSize) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapZ, questGiverSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Draw cash bundles as small green dots
            ctx.fillStyle = '#00FF00'; // Bright green for cash
            cashBundles.forEach(bundle => {
                const relativeX = bundle.position.x - playerX;
                const relativeZ = bundle.position.z - playerZ;
                
                const mapX = centerX + relativeX * scale;
                const mapZ = centerZ + relativeZ * scale;
                
                const cashSize = minimapMaximized ? 4 : 2; // Bigger when maximized
                
                if (mapX > -cashSize && mapX < size + cashSize && 
                    mapZ > -cashSize && mapZ < size + cashSize) {
                    ctx.beginPath();
                    ctx.arc(mapX, mapZ, cashSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            // Draw health packs as small red crosses
            ctx.fillStyle = '#FF1493'; // Bright red/magenta for health packs
            healthPacks.forEach(pack => {
                const relativeX = pack.position.x - playerX;
                const relativeZ = pack.position.z - playerZ;
                
                const mapX = centerX + relativeX * scale;
                const mapZ = centerZ + relativeZ * scale;
                
                const packSize = minimapMaximized ? 3 : 1.5; // Bigger when maximized
                
                if (mapX > -packSize && mapX < size + packSize && 
                    mapZ > -packSize && mapZ < size + packSize) {
                    // Draw a cross shape for health pack
                    ctx.fillRect(mapX - packSize, mapZ - packSize/3, packSize*2, packSize*2/3); // Horizontal bar
                    ctx.fillRect(mapX - packSize/3, mapZ - packSize, packSize*2/3, packSize*2); // Vertical bar
                }
            });
            
            // Draw quest target if active
            if (currentQuest && currentQuest.target) {
                let targetX, targetZ;
                
                // Get target position based on quest type
                if (currentQuest.target.type === 'npc' && currentQuest.target.npc) {
                    targetX = currentQuest.target.npc.position.x;
                    targetZ = currentQuest.target.npc.position.z;
                } else if (currentQuest.target.type === 'car' && currentQuest.target.car) {
                    targetX = currentQuest.target.car.position.x;
                    targetZ = currentQuest.target.car.position.z;
                } else if (currentQuest.target.type === 'cash' && currentQuest.target.cash) {
                    targetX = currentQuest.target.cash.position.x;
                    targetZ = currentQuest.target.cash.position.z;
                } else {
                    targetX = currentQuest.target.x;
                    targetZ = currentQuest.target.z;
                }
                
                const relativeX = targetX - playerX;
                const relativeZ = targetZ - playerZ;
                
                const mapX = centerX + relativeX * scale;
                const mapZ = centerZ + relativeZ * scale;
                
                const targetSize = minimapMaximized ? 8 : 4; // Bigger when maximized
                
                if (mapX > -targetSize && mapX < size + targetSize && 
                    mapZ > -targetSize && mapZ < size + targetSize) {
                    // Draw bright yellow circle for quest target at 100% alpha
                    ctx.fillStyle = 'rgba(255, 255, 0, 1.0)'; // Bright yellow at 100% alpha
                    ctx.beginPath();
                    ctx.arc(mapX, mapZ, targetSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw quest target if there's an active quest
            if (currentQuest && currentQuest.objective) {
                // Get quest target location
                let targetLocation = null;
                const objective = currentQuest.objective;

                switch(objective.type) {
                    case 'TALK':
                        targetLocation = namedLocations[objective.targetLocation];
                        break;
                    case 'DELIVER_ITEM':
                        if (!hasItemInInventory(objective.item)) {
                            targetLocation = namedLocations[objective.fromLocation];
                        } else {
                            targetLocation = namedLocations[objective.toLocation];
                        }
                        break;
                    case 'STEAL_CAR':
                        if (gameState !== 'driving') {
                            targetLocation = namedLocations[objective.fromLocation];
                        } else {
                            targetLocation = namedLocations[objective.toLocation];
                        }
                        break;
                    case 'BUY':
                        targetLocation = namedLocations[objective.vendorLocation];
                        break;
                    case 'KILL':
                        targetLocation = namedLocations[objective.targetLocation];
                        break;
                }

                // Draw quest target marker
                if (targetLocation && targetLocation.x !== undefined && targetLocation.z !== undefined) {
                    const relativeX = targetLocation.x - playerX;
                    const relativeZ = targetLocation.z - playerZ;

                    const mapX = centerX + relativeX * scale;
                    const mapZ = centerZ + relativeZ * scale;

                    const targetSize = minimapMaximized ? 8 : 4; // Bigger when maximized

                    // Draw yellow diamond for quest target
                    ctx.fillStyle = '#FFFF00'; // Yellow for quest target
                    ctx.save();
                    ctx.translate(mapX, mapZ);
                    ctx.rotate(Math.PI / 4); // Rotate 45 degrees to make diamond
                    ctx.fillRect(-targetSize/2, -targetSize/2, targetSize, targetSize);
                    ctx.restore();

                    // Draw pulsing ring around target
                    const pulse = (Date.now() % 1000) / 1000;
                    const ringSize = targetSize + pulse * (minimapMaximized ? 8 : 4);
                    ctx.strokeStyle = `rgba(255, 255, 0, ${1 - pulse})`; // Fading yellow
                    ctx.lineWidth = minimapMaximized ? 2 : 1;
                    ctx.beginPath();
                    ctx.arc(mapX, mapZ, ringSize, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }

            // Draw player at center
            if (gameState === 'driving') {
                // Draw car icon for player when driving
                ctx.fillStyle = '#00FFFF'; // Cyan for player car
                const playerCarSize = minimapMaximized ? 8 : 4; // Bigger when maximized
                ctx.fillRect(
                    centerX - playerCarSize/2, 
                    centerZ - playerCarSize/2, 
                    playerCarSize, 
                    playerCarSize
                );
            } else {
                // Draw player dot when walking
                ctx.fillStyle = '#FFFFFF'; // White for player
                ctx.beginPath();
                const playerSize = minimapMaximized ? 6 : 3; // Bigger when maximized
                ctx.arc(centerX, centerZ, playerSize, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw player facing direction
                const facingAngle = character.userData.facingAngle || 0;
                const directionLength = minimapMaximized ? 16 : 8; // Longer when maximized
                const directionX = Math.sin(facingAngle) * directionLength;
                const directionZ = Math.cos(facingAngle) * directionLength;
                
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = minimapMaximized ? 4 : 2; // Thicker when maximized
                ctx.beginPath();
                ctx.moveTo(centerX, centerZ);
                ctx.lineTo(centerX + directionX, centerZ + directionZ);
                ctx.stroke();
            }
            
            // Restore the transformation matrix
            ctx.restore();

            // Now draw the offscreen canvas to the visible canvas
            const visibleCtx = minimapCtx;
            visibleCtx.clearRect(0, 0, size, size);

            // Apply transparency only when maximized
            if (minimapMaximized) {
                visibleCtx.globalAlpha = 0.5;
            }

            // Draw the offscreen canvas to the visible canvas
            visibleCtx.drawImage(minimapOffscreenCanvas, 0, 0);

            // Reset alpha
            visibleCtx.globalAlpha = 1.0;
        }

        function toggleMinimap() {
            const minimapContainer = document.querySelector('.minimap-container');
            if (!minimapContainer) return;
            
            minimapMaximized = !minimapMaximized;
            
            if (minimapMaximized) {
                // Maximize to center of screen, full width
                minimapContainer.style.width = '720px';
                minimapContainer.style.height = '720px';
                minimapContainer.style.top = '50%';
                minimapContainer.style.left = '50%';
                minimapContainer.style.transform = 'translate(-50%, -50%)';
                minimapContainer.style.zIndex = '2000'; // Higher z-index when maximized
            } else {
                // Return to mini size at right side, below the money icon
                minimapContainer.style.width = '200px';
                minimapContainer.style.height = '200px';
                minimapContainer.style.top = '140px'; // Below money icon
                minimapContainer.style.right = '20px';
                minimapContainer.style.left = 'auto';
                minimapContainer.style.transform = 'none';
                minimapContainer.style.zIndex = '1000'; // Original z-index
            }
        }

        function initializeUI() {
            // Load bullet box asset and display as texture without outlines
            const bulletAsset = lib.getAsset('bullet_box_icon');
            const bulletIcon = document.getElementById('bulletIcon');
            if (bulletAsset) {
                bulletIcon.style.background = `url(${bulletAsset.url}) center/contain no-repeat transparent`;
                bulletIcon.style.border = 'none';
            }
            
            // Initialize weapon icons
            const pistolIcon = document.getElementById('pistolIcon');
            const pistolAsset = lib.getAsset('ui_pistol_icon');
            if (pistolIcon && pistolAsset) {
                pistolIcon.style.background = `url(${pistolAsset.url}) center/contain no-repeat`;
            }

            const uziIcon = document.getElementById('uziIcon');
            const uziAsset = lib.getAsset('ui_uzi_icon');
            if (uziIcon && uziAsset) {
                uziIcon.style.background = `url(${uziAsset.url}) center/contain no-repeat`;
            }

            const rocketIcon = document.getElementById('rocketIcon');
            const rocketAsset = lib.getAsset('ui_rocketlauncher_icon');
            if (rocketIcon && rocketAsset) {
                rocketIcon.style.background = `url(${rocketAsset.url}) center/contain no-repeat`;
            }

            // Initialize hold up button icon
            const holdUpIcon = document.getElementById('holdUpIcon');
            const holdUpAsset = lib.getAsset('ui_holdup_icon');
            if (holdUpIcon && holdUpAsset) {
                holdUpIcon.style.background = `url(${holdUpAsset.url}) center/contain no-repeat transparent`;
            }

            // Set up weapon switch button click handlers
            document.querySelectorAll('.weapon-switch-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const weapon = btn.dataset.weapon;
                    if (weapon) {
                        switchWeapon(weapon);
                    }
                });
            });

            // Initialize weapon UI
            updateWeaponUI();
            
            // Load cash asset and display as texture without outlines
            const cashAsset = lib.getAsset('cash_ui_icon') || lib.getAsset('ui_cash_stack_icon');
            const cashIcon = document.getElementById('cashIcon');
            if (cashAsset) {
                cashIcon.style.background = `url(${cashAsset.url}) center/contain no-repeat transparent`;
                cashIcon.style.border = 'none';
            }
            
            // Load pixelated heart icon
            const heartAsset = lib.getAsset('pixelated_heart_icon');
            const heartIcon = document.getElementById('healthHeart');
            if (heartAsset && heartIcon) {
                heartIcon.style.background = `url(${heartAsset.url}) center/contain no-repeat transparent`;
                heartIcon.textContent = ''; // Remove emoji fallback
            }
            
            // Load pixelated star icons
            const starAsset = lib.getAsset('pixelated_star_icon');
            if (starAsset) {
                for (let i = 1; i <= 5; i++) {
                    const star = document.getElementById(`star${i}`);
                    if (star) {
                        star.style.background = `url(${starAsset.url}) center/contain no-repeat transparent`;
                        star.textContent = ''; // Remove emoji fallback
                    }
                }
            }
            
            // Initialize health bar and star system
            updateHealthBar();
            updateStarSystem();
            updateCashDisplay();

            // Initialize weapon system
            updateWeaponUI();
            
            // Initialize minimap
            initializeMinimap();
            
            // Initialize UI state
            updateUIForGameState();
            updateWeaponUI();
            
            // Setup vendor shop close button
            const vendorCloseButton = document.getElementById('vendorCloseButton');
            if (vendorCloseButton) {
                const closeHandler = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    closeVendorShop();
                };
                vendorCloseButton.addEventListener('click', closeHandler);
                vendorCloseButton.addEventListener('touchstart', closeHandler);
            }

            // Example dialog usage (can be removed - just for demonstration)
            // To use the dialog system, call showDialog with a JSON structure like this:
            /*
            showDialog({
                lines: [
                    { speaker: "Vendor", text: "Welcome to my shop! What can I get for you today?" },
                    { speaker: "Player", text: "I'm looking for some weapons." },
                    { speaker: "Vendor", text: "Ah, you've come to the right place! Take a look at my selection." }
                ],
                onComplete: () => {
                    console.log('Dialog completed');
                    // Optional callback when dialog finishes
                }
            });
            */
        }

        // Loading screen state
        let loadingScreenActive = true;
        let loadingStartTime = 0;
        let loadingDuration = 7000; // 7 seconds in milliseconds
        let playerInputDisabled = true;
        let loadingFadeStarted = false; // Flag to prevent multiple fade-out timeouts

        function run(mode) {
            console.log('run() called. Mode: ' + mode);
            console.log("Grand Theft Astro version 2025.11.21-web-audio");
            currentMode = mode;

            // Initialize loading screen (optional based on ENABLE_LOADING_SCREEN)
            if (ENABLE_LOADING_SCREEN) {
                loadingScreenActive = true;
                loadingStartTime = Date.now();
                playerInputDisabled = true;
                createLoadingScreen();
            } else {
                // Skip loading screen - enable input immediately
                loadingScreenActive = false;
                playerInputDisabled = false;
                console.log('Loading screen disabled - player input enabled immediately');
            }

            // Apply collision checking to character BEFORE loading is over
            // This ensures the game engine knows where the character is positioned
            // and adjusts Y-axis height accordingly during the loading phase

            console.log('Character spawn: (' + CHARACTER_SPAWN_X + ', ' + CHARACTER_SPAWN_Z + ')');
            console.log('World size: ' + getWorldSize());
            console.log('World cubes: ' + worldCubes.length);

            // Initialize game
            initAudioContext();
            preloadAssets();
            preloadAudioBuffers(AUDIO_ASSET_IDS).then(() => {
                lib.log("Audio assets loaded successfully");
                startAmbientAudio();
            }).catch(e => {
                console.error("Failed to load audio:", e);
            });
            initThreeJS();

            character = createCharacter(
                CHARACTER_SPAWN_X,
                CHARACTER_SPAWN_Z,
                true
            );

            // Initialize character facing angle
            characterFacingAngle = 0; // Start facing north
            character.userData.facingAngle = characterFacingAngle;

            // CRITICAL: Apply collision checking to character IMMEDIATELY after creation
            // This ensures the game engine knows the character's location (road, interior, etc.)
            // and adjusts Y-axis height accordingly BEFORE loading completes
            const initialCollision = checkCollisions(
                CHARACTER_SPAWN_X,
                CHARACTER_SPAWN_Z,
                character.position.y
            );
            character.position.y = initialCollision.stepUpHeight;
            character.userData.groundHeight = initialCollision.groundHeight;
            character.userData.isOnCurb = (character.userData.isOnCurb !== undefined) ? character.userData.isOnCurb : 0;
            
            console.log(`Character collision applied during loading: Y=${character.position.y.toFixed(2)}, Ground=${initialCollision.groundHeight}, Location=${character.userData.isOnCurb}`);
            world = createWorld();

            // Initialize quest chains system
            initializeQuestChains();

            // Light is already positioned high in the sky for open world
            // No need to adjust position based on walls since there are none
            
            // Clear existing cubes to force regeneration with new streetlight signs
            worldCubes = [];
            
            // Create cubes (will generate concrete grid if cubes array is empty)
            createCubes();

            // Create island features (water, seawalls, docks)
            createIslandFeatures();

            // IMPORTANT: Re-apply collision checking after world is created
            // This ensures character height is correct based on the generated world
            const postWorldCollision = checkCollisions(
                character.position.x, 
                character.position.z, 
                character.position.y
            );
            character.position.y = postWorldCollision.stepUpHeight;
            character.userData.groundHeight = postWorldCollision.groundHeight;
            
            console.log(`Character collision re-applied after world creation: Y=${character.position.y.toFixed(2)}, Ground=${postWorldCollision.groundHeight}`);
            
            // Create NPCs (will generate 20 NPCs if array is empty)
            createNPCs();
            
            // Create cars (will generate cars for each road if array is empty)
            createCars();

            // DEBUG: Generate 100 parking location test cubes
//            debugGenerateLocations("Shop", 100);

            // Initialize quest system
            initializeQuestSystem();

            setupControls();
            updateCamera();
            updateDebugDisplay();
            
            // Initialize UI with a small delay to ensure assets are loaded
            setTimeout(() => {
                initializeUI();
                updateWeaponUI(); // Initialize weapon UI to show locked/unlocked states
            }, 100);
            
            // Initialize UI

            // Start game loop
            gameLoop();

            initSplashScreen(); // Initialize splash screen fade
        }
        
        function createLoadingScreen() {
            // Create loading overlay
            let loadingOverlay = document.getElementById('loadingOverlay');
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'loadingOverlay';
                loadingOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: black;
                    z-index: 10001;
                    display: flex;
                    align-items: flex-end;
                    justify-content: center;
                    padding-bottom: 80px;
                    opacity: 1;
                    transition: opacity 1s ease-out;
                `;

                // Original loading text removed - now rendered as 3D plane texture
                document.body.appendChild(loadingOverlay);

                // Create 3D loading scene with textured planes
                createLoading3DScene();
            }
        }
        
        function createLoading3DScene() {
            // Create separate Three.js scene for loading screen
            const loadingScene = new THREE.Scene();
            const loadingCamera = new THREE.PerspectiveCamera(75, 720 / 1280, 0.1, 1000);
            const loadingRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            loadingRenderer.setSize(720, 1280);
            loadingRenderer.domElement.style.position = 'absolute';
            loadingRenderer.domElement.style.top = '0';
            loadingRenderer.domElement.style.left = '0';
            loadingRenderer.domElement.style.zIndex = '10000';
            loadingRenderer.domElement.style.pointerEvents = 'none';
            loadingRenderer.domElement.id = 'loadingCanvas';
            
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.appendChild(loadingRenderer.domElement);
            } else {
                document.body.appendChild(loadingRenderer.domElement);
            }
            
            // Position camera at center of view
            loadingCamera.position.set(0, 0, 5);
            loadingCamera.lookAt(0, 0, 0);
            
            // Create background plane (city sunset) - 9:16 aspect ratio, screen size, brought closer
            const backgroundGeometry = new THREE.PlaneGeometry(4, 7.11); // 9:16 aspect ratio scaled to fit screen
            
            // Load city sunset texture
            const cityAsset = lib.getAsset('city_sunset_background');
            let backgroundMaterial;
            if (cityAsset) {
                const cityTexture = new THREE.TextureLoader().load(cityAsset.url);
                cityTexture.magFilter = THREE.LinearFilter;
                cityTexture.minFilter = THREE.LinearFilter;
                backgroundMaterial = new THREE.MeshBasicMaterial({ 
                    map: cityTexture,
                    transparent: true,
                    opacity: 0 // Start invisible
                });
            } else {
                // Fallback gradient background
                backgroundMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff6600, // Orange sunset color
                    transparent: true,
                    opacity: 0 // Start invisible
                });
            }
            
            const backgroundPlane = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
            backgroundPlane.position.set(0, 0, -0.5); // Brought slightly closer to player (was -1, now -0.5)
            loadingScene.add(backgroundPlane);
            
            // Create foreground plane (character with pistol) - 9:16 aspect ratio, screen size, in front
            const foregroundGeometry = new THREE.PlaneGeometry(4, 7.11); // Same size as background
            
            // Load character texture
            const characterAsset = lib.getAsset('character_with_pistol');
            let foregroundMaterial;
            if (characterAsset) {
                const characterTexture = new THREE.TextureLoader().load(characterAsset.url);
                characterTexture.magFilter = THREE.LinearFilter;
                characterTexture.minFilter = THREE.LinearFilter;
                foregroundMaterial = new THREE.MeshBasicMaterial({ 
                    map: characterTexture,
                    transparent: true,
                    opacity: 0, // Start invisible
                    alphaTest: 0.1
                });
            } else {
                // Fallback transparent material
                foregroundMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0 // Start invisible
                });
            }
            
            const foregroundPlane = new THREE.Mesh(foregroundGeometry, foregroundMaterial);
            foregroundPlane.position.set(0, -0.2 * 7.11 * 0.5, 1); // Move down 20% of its height (off screen), bring closer to viewer
            loadingScene.add(foregroundPlane);
            
            // Create "LOADING..." text plane above both planes
            const textPlane = createLoadingTextPlane();
            textPlane.position.set(0, 0, 2); // In front of both planes
            loadingScene.add(textPlane);
            
            // Store references for animation
            window.loadingBackgroundPlane = backgroundPlane;
            window.loadingForegroundPlane = foregroundPlane;
            window.loadingTextPlane = textPlane;
            
            // Store loading scene references for cleanup
            window.loadingScene = loadingScene;
            window.loadingCamera = loadingCamera;
            window.loadingRenderer = loadingRenderer;
            
            // Start loading screen animation loop
            animateLoadingScreen();
        }
        
        function createLoadingTextPlane() {
            // Create canvas for "LOADING..." text
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Set font and styling to match the original loading text
            ctx.font = 'bold 48px "Denk One", cursive';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw text with black outline (same as original styling)
            const text = 'LOADING...';
            const x = canvas.width / 2;
            const y = canvas.height / 2;
            
            // Draw black outline
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 4;
            ctx.strokeText(text, x, y);
            
            // Draw white fill
            ctx.fillStyle = 'white';
            ctx.fillText(text, x, y);
            
            // Create texture from canvas
            const textTexture = new THREE.CanvasTexture(canvas);
            textTexture.magFilter = THREE.LinearFilter;
            textTexture.minFilter = THREE.LinearFilter;
            
            // Create material
            const textMaterial = new THREE.MeshBasicMaterial({
                map: textTexture,
                transparent: true,
                opacity: 0 // Start invisible
            });
            
            // Create plane geometry (4:1 aspect ratio to match canvas)
            const textGeometry = new THREE.PlaneGeometry(2, 0.5);
            const textPlane = new THREE.Mesh(textGeometry, textMaterial);
            
            return textPlane;
        }
        
        function animateLoadingScreen() {
            if (!loadingScreenActive || !window.loadingRenderer) return;
            
            // Handle sequential fade-in animation and rotation
            if (window.loadingBackgroundPlane && window.loadingForegroundPlane && window.loadingTextPlane) {
                const currentTime = Date.now();
                const elapsed = currentTime - loadingStartTime;
                const progress = Math.min(elapsed / loadingDuration, 1); // 0 to 1 over loading duration
                
                // Phase 1: Background plane fades in (0-0.5s)
                if (elapsed <= 500) {
                    const fadeProgress = elapsed / 500; // 0 to 1 over 0.5s
                    window.loadingBackgroundPlane.material.opacity = fadeProgress;
                    window.loadingForegroundPlane.material.opacity = 0;
                    window.loadingTextPlane.material.opacity = 0;
                } else if (elapsed <= 1000) {
                    // Phase 2: Character plane fades in (0.5-1.0s)
                    const fadeProgress = (elapsed - 500) / 500; // 0 to 1 over next 0.5s
                    window.loadingBackgroundPlane.material.opacity = 1;
                    window.loadingForegroundPlane.material.opacity = fadeProgress;
                    window.loadingTextPlane.material.opacity = 0;
                } else if (elapsed <= 1500) {
                    // Phase 3: Text plane fades in (1.0-1.5s)
                    const fadeProgress = (elapsed - 1000) / 500; // 0 to 1 over next 0.5s
                    window.loadingBackgroundPlane.material.opacity = 1;
                    window.loadingForegroundPlane.material.opacity = 1;
                    window.loadingTextPlane.material.opacity = fadeProgress;
                } else {
                    // Phase 4: All visible, continue with rotation animation
                    window.loadingBackgroundPlane.material.opacity = 1;
                    window.loadingForegroundPlane.material.opacity = 1;
                    window.loadingTextPlane.material.opacity = 1;
                }
                
                // Rotation animation (starts after 1.5s)
                if (elapsed > 1500) {
                    const rotationElapsed = elapsed - 1500;
                    const rotationDuration = loadingDuration - 1500;
                    const rotationProgress = Math.min(rotationElapsed / rotationDuration, 1);
                    const halfTime = 0.5; // Midpoint of rotation duration
                    
                    const baseRotationSpeed = 0.003; // 1.5x faster (was 0.002, now 0.003)
                    let currentRotationSpeed = 0;
                    
                    if (rotationProgress <= halfTime) {
                        // First half: rotate in one direction, slowing down to stop at midpoint
                        const halfProgress = rotationProgress / halfTime; // 0 to 1 over first half
                        currentRotationSpeed = baseRotationSpeed * (1 - halfProgress); // Slow down to 0
                        
                        // Background plane rotates clockwise
                        window.loadingBackgroundPlane.rotation.y += currentRotationSpeed;
                        
                        // Foreground plane rotates counter-clockwise
                        window.loadingForegroundPlane.rotation.y -= currentRotationSpeed;
                    } else {
                        // Second half: speed up and rotate in opposite direction
                        const secondHalfProgress = (rotationProgress - halfTime) / halfTime; // 0 to 1 over second half
                        currentRotationSpeed = baseRotationSpeed * secondHalfProgress; // Speed up from 0
                        
                        // Background plane rotates counter-clockwise (opposite direction)
                        window.loadingBackgroundPlane.rotation.y -= currentRotationSpeed;
                        
                        // Foreground plane rotates clockwise (opposite direction)
                        window.loadingForegroundPlane.rotation.y += currentRotationSpeed;
                    }
                }
            }
            
            // Render the loading scene
            window.loadingRenderer.render(window.loadingScene, window.loadingCamera);
            
            // Continue animation loop
            requestAnimationFrame(animateLoadingScreen);
        }
        
        function updateLoadingScreen() {
            const currentTime = Date.now();
            const elapsed = currentTime - loadingStartTime;

            if (elapsed >= loadingDuration && !loadingFadeStarted) {
                // Loading complete - start fade out (only once)
                loadingFadeStarted = true; // Set flag to prevent multiple timeouts

                const loadingOverlay = document.getElementById('loadingOverlay');

                // Fade out loading overlay
                if (loadingOverlay) {
                    loadingOverlay.style.opacity = '0';
                }

                if (loadingOverlay) {
                    // Remove overlay after fade completes and enable player input
                    setTimeout(() => {
                        if (loadingOverlay.parentNode) {
                            loadingOverlay.parentNode.removeChild(loadingOverlay);
                        }

                        // Clean up loading 3D scene
                        if (window.loadingRenderer) {
                            const loadingCanvas = document.getElementById('loadingCanvas');
                            if (loadingCanvas && loadingCanvas.parentNode) {
                                loadingCanvas.parentNode.removeChild(loadingCanvas);
                            }
                            window.loadingRenderer.dispose();
                            window.loadingRenderer = null;
                            window.loadingScene = null;
                            window.loadingCamera = null;
                            window.loadingBackgroundPlane = null;
                            window.loadingForegroundPlane = null;
                            window.loadingTextPlane = null;
                        }

                        loadingScreenActive = false;
                        playerInputDisabled = false;
                        console.log('Loading screen complete - player input enabled');
                    }, 3000); // Wait for 2s delay + 1s fade transition
                } else {
                    // No overlay to fade
                    setTimeout(() => {
                        loadingScreenActive = false;
                        playerInputDisabled = false;
                        console.log('Loading screen complete - player input enabled (no overlay)');
                    }, 3000); // Wait for 2s delay + 1s fade transition
                }
            }
        }

        // Expose run function globally for the framework to call
        window.run = run;

              window.mode = "play";
      window.gameConfig = window.gameConfig || {};
      if (typeof run === "function") run("play");

    </script>
</body>
</html>