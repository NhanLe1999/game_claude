<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Grand Theft Astro - Full Demo</title>
    <link href="css2.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Denk One', sans-serif;
        }

        :root {
            --ui-margin: clamp(12px, 3vmin, 24px);
            --ui-padding: clamp(10px, 2.5vmin, 18px);
            --ui-font-lg: clamp(16px, 3.5vmin, 28px);
            --ui-font-md: clamp(12px, 2.5vmin, 18px);
            --ui-font-sm: clamp(10px, 2vmin, 14px);
            --ui-joystick-size: clamp(80px, 18vmin, 140px);
            --ui-joystick-knob: clamp(34px, 8vmin, 64px);
            --ui-action-size: clamp(52px, 12vmin, 88px);
            --ui-weapon-switch: clamp(44px, 10vmin, 72px);
            --ui-minimap: clamp(110px, 20vmin, 200px);
            --ui-heart: clamp(28px, 6vmin, 48px);
            --ui-star: clamp(20px, 4.5vmin, 36px);
            --ui-quest-arrow: clamp(44px, 10vmin, 72px);
            --ui-health-width: clamp(120px, 24vmin, 200px);
            --ui-health-height: clamp(14px, 3vmin, 24px);
            --ui-button-gap: clamp(10px, 3vmin, 24px);
            --ui-bottom-pad: clamp(70px, 14vmin, 120px);
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas { display: block; }
        
        /* Joystick */
        #joystick {
            position: fixed;
            bottom: var(--ui-bottom-pad);
            left: var(--ui-margin);
            width: var(--ui-joystick-size);
            height: var(--ui-joystick-size);
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.4);
            z-index: 1000;
        }
        
        #joystickKnob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--ui-joystick-knob);
            height: var(--ui-joystick-knob);
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            border: 2px solid white;
        }
        
        /* Health Bar */
        .health-bar-container {
            position: fixed;
            top: var(--ui-margin);
            left: var(--ui-margin);
            display: flex;
            align-items: center;
            gap: clamp(6px, 2vmin, 12px);
            z-index: 1000;
        }
        
        #healthHeart { width: var(--ui-heart); height: var(--ui-heart); font-size: var(--ui-font-lg); }
        
        .health-bar-bg {
            width: var(--ui-health-width);
            height: var(--ui-health-height);
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 2px solid white;
            overflow: hidden;
        }
        
        #healthBarFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #ff4444, #ff6666);
            transition: width 0.3s;
        }
        
        /* Stars */
        .star-container {
            position: fixed;
            top: var(--ui-margin);
            right: var(--ui-margin);
            display: flex;
            gap: clamp(3px, 1vmin, 8px);
            z-index: 1000;
        }
        
        .star { width: var(--ui-star); height: var(--ui-star); font-size: var(--ui-font-md); opacity: 0.3; }
        .star.active { opacity: 1; }
        
        /* Cash Display */
        .cash-display {
            position: fixed;
            top: calc(var(--ui-margin) + clamp(26px, 6vmin, 48px));
            right: var(--ui-margin);
            color: #00ff00;
            font-size: var(--ui-font-lg);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 1000;
        }
        
        /* Action Buttons */
        .action-button {
            position: fixed;
            bottom: var(--ui-bottom-pad);
            width: var(--ui-action-size);
            height: var(--ui-action-size);
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 3px solid white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: var(--ui-font-lg);
            cursor: pointer;
            z-index: 1000;
            transition: transform 0.1s, background 0.1s;
        }
        
        .action-button:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.5);
        }
        
        #gunButton {
            right: var(--ui-margin);
            background-repeat: no-repeat;
            background-position: center;
            background-size: 60%;
        }
        #holdUpButton { right: calc(var(--ui-margin) + var(--ui-action-size) + var(--ui-button-gap)); }
        
        /* Weapon Switch Button */
        #weaponSwitchButton {
            position: fixed;
            bottom: calc(var(--ui-bottom-pad) + var(--ui-action-size) + var(--ui-button-gap));
            right: var(--ui-margin);
            width: var(--ui-weapon-switch);
            height: var(--ui-weapon-switch);
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            border: 2px solid #ffaa00;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: var(--ui-font-lg);
            cursor: pointer;
            z-index: 1000;
        }
        
        /* Weapon Info Display */
        .weapon-info {
            position: fixed;
            bottom: calc(var(--ui-bottom-pad) + var(--ui-action-size) + var(--ui-weapon-switch) + (var(--ui-button-gap) * 2));
            right: var(--ui-margin);
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(6px, 2vmin, 10px) clamp(10px, 3vmin, 16px);
            border-radius: 8px;
            color: white;
            font-size: var(--ui-font-sm);
            z-index: 1000;
            text-align: center;
            min-width: 100px;
        }
        
        .weapon-name { font-weight: bold; color: #ffaa00; font-size: var(--ui-font-md); }
        .weapon-ammo { color: #aaa; font-size: var(--ui-font-sm); margin-top: 3px; }
        .weapon-ammo.low { color: #ff4444; }
        
        /* Quest UI */
        .quest-container {
            position: fixed;
            top: calc(var(--ui-margin) + clamp(48px, 10vmin, 90px));
            left: var(--ui-margin);
            background: rgba(0, 0, 0, 0.8);
            padding: var(--ui-padding);
            border-radius: 10px;
            border-left: 4px solid #ffaa00;
            color: white;
            z-index: 1000;
            max-width: clamp(220px, 40vw, 360px);
            display: none;
        }
        
        .quest-title {
            font-size: var(--ui-font-md);
            color: #ffaa00;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .quest-description {
            font-size: var(--ui-font-sm);
            color: #ccc;
            line-height: 1.4;
        }
        
        .quest-distance {
            font-size: var(--ui-font-sm);
            color: #888;
            margin-top: 8px;
        }
        
        /* Quest Arrow */
        .quest-arrow {
            position: fixed;
            top: 58%;
            left: 50%;
            width: var(--ui-quest-arrow);
            height: var(--ui-quest-arrow);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 999;
            display: none;
        }
        
        .quest-arrow svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 5px rgba(255, 170, 0, 0.8));
        }
        
        /* Quest Marker */
        .quest-marker {
            position: absolute;
            width: clamp(28px, 7vmin, 48px);
            height: clamp(28px, 7vmin, 48px);
            background: #ffaa00;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: var(--ui-font-md);
            font-weight: bold;
            color: black;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
            cursor: pointer;
            z-index: 1000;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Dialog System */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: none;
        }
        
        .dialog-box {
            position: fixed;
            bottom: var(--ui-bottom-pad);
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: clamp(280px, 70vw, 680px);
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            border: 3px solid #ffaa00;
            border-radius: 15px;
            padding: var(--ui-padding);
            z-index: 2001;
            display: none;
        }
        
        .dialog-speaker {
            font-size: var(--ui-font-md);
            color: #ffaa00;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .dialog-text {
            font-size: var(--ui-font-sm);
            color: white;
            line-height: 1.5;
        }
        
        .dialog-continue {
            position: absolute;
            bottom: 10px;
            right: 20px;
            color: #888;
            font-size: var(--ui-font-sm);
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffaa00;
            border-radius: 10px;
            padding: calc(var(--ui-padding) + 2px) calc(var(--ui-padding) + 12px);
            color: white;
            font-size: var(--ui-font-lg);
            z-index: 3000;
            text-align: center;
            animation: fadeInOut 3s forwards;
            display: none;
        }

        /* Blood splash */
        #bloodLayer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 2500;
        }

        .blood-splash {
            position: absolute;
            width: clamp(60px, 18vmin, 160px);
            height: clamp(60px, 18vmin, 160px);
            background:
                radial-gradient(circle at 30% 30%, rgba(120,0,0,0.9) 0 12%, rgba(80,0,0,0.7) 13% 28%, transparent 29%),
                radial-gradient(circle at 70% 40%, rgba(150,0,0,0.85) 0 10%, rgba(90,0,0,0.6) 11% 26%, transparent 27%),
                radial-gradient(circle at 45% 75%, rgba(130,0,0,0.8) 0 8%, rgba(70,0,0,0.6) 9% 22%, transparent 23%);
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6);
            animation: bloodSplatter 0.8s ease-out forwards;
        }

        @keyframes bloodSplatter {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.4); }
            30% { opacity: 0.85; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.1); }
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* Minimap */
        .minimap-container {
            position: fixed;
            bottom: var(--ui-margin);
            right: var(--ui-margin);
            width: var(--ui-minimap);
            height: var(--ui-minimap);
            border: 3px solid white;
            border-radius: 10px;
            overflow: hidden;
            z-index: 1000;
        }
        
        #minimapCanvas {
            width: 100%;
            height: 100%;
            background: #1a1a2e;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 1s;
        }
        
        #loadingScreen h1 {
            color: white;
            font-size: clamp(28px, 8vmin, 52px);
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,100,0,0.8);
        }
        
        #loadingScreen p { color: #aaa; font-size: var(--ui-font-md); }
        
        .loading-bar {
            width: clamp(200px, 60vw, 360px);
            height: clamp(8px, 2vmin, 12px);
            background: #333;
            border-radius: 5px;
            margin-top: 30px;
            overflow: hidden;
        }
        
        .loading-bar-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #ff6600, #ffaa00);
            animation: loading 2s ease-in-out forwards;
        }
        
        @keyframes loading {
            0% { width: 0%; }
            100% { width: 100%; }
        }
        
        /* Inventory Display */
        .inventory-display {
            position: fixed;
            top: calc(var(--ui-margin) + clamp(48px, 10vmin, 90px));
            right: var(--ui-margin);
            background: rgba(0, 0, 0, 0.7);
            padding: var(--ui-padding);
            border-radius: 8px;
            color: white;
            font-size: var(--ui-font-sm);
            z-index: 1000;
            display: none;
        }
        
        .inventory-item {
            padding: clamp(4px, 1.5vmin, 8px) clamp(6px, 2vmin, 12px);
            background: rgba(255, 170, 0, 0.3);
            border-radius: 5px;
            margin: clamp(2px, 1vmin, 6px) 0;
        }

        @media (orientation: portrait) {
            :root {
                --ui-bottom-pad: clamp(60px, 12vmin, 110px);
                --ui-action-size: clamp(48px, 13vmin, 82px);
                --ui-joystick-size: clamp(70px, 20vmin, 130px);
                --ui-joystick-knob: clamp(30px, 9vmin, 60px);
                --ui-minimap: clamp(100px, 26vmin, 190px);
            }

            .quest-container {
                width: calc(100vw - (var(--ui-margin) * 2));
                max-width: none;
            }

            .minimap-container {
                top: calc(var(--ui-margin) + clamp(70px, 16vmin, 130px));
                bottom: auto;
            }

            .weapon-info {
                bottom: calc(var(--ui-bottom-pad) + var(--ui-action-size) + var(--ui-weapon-switch) + (var(--ui-button-gap) * 2));
            }

            .quest-arrow {
                top: 62%;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <h1>GRAND THEFT ASTRO</h1>
        <p>Loading game...</p>
        <div class="loading-bar">
            <div class="loading-bar-fill"></div>
        </div>
    </div>

    <div id="gameContainer">
        <!-- Health Bar -->
        <div class="health-bar-container">
            <div id="healthHeart">‚ù§Ô∏è</div>
            <div class="health-bar-bg">
                <div id="healthBarFill"></div>
            </div>
        </div>
        
        <!-- Stars -->
        <div class="star-container">
            <div class="star" id="star1">‚≠ê</div>
            <div class="star" id="star2">‚≠ê</div>
            <div class="star" id="star3">‚≠ê</div>
            <div class="star" id="star4">‚≠ê</div>
            <div class="star" id="star5">‚≠ê</div>
        </div>
        
        <!-- Cash -->
        <div class="cash-display">$<span id="cashAmount">0</span></div>
        
        <!-- Quest UI -->
        <div class="quest-container" id="questContainer">
            <div class="quest-title" id="questTitle">Quest Title</div>
            <div class="quest-description" id="questDescription">Quest description here</div>
            <div class="quest-distance" id="questDistance">Distance: 0m</div>
        </div>
        
        <!-- Quest Arrow -->
        <div class="quest-arrow" id="questArrow">
            <svg viewBox="0 0 100 100">
                <polygon points="50,10 90,90 50,70 10,90" fill="#ffaa00" stroke="#fff" stroke-width="2"/>
            </svg>
        </div>
        
        <!-- Inventory Display -->
        <div class="inventory-display" id="inventoryDisplay">
            <div style="color: #ffaa00; margin-bottom: 5px;">üì¶ Inventory</div>
            <div id="inventoryItems"></div>
        </div>
        
        <!-- Dialog System -->
        <div class="dialog-overlay" id="dialogOverlay"></div>
        <div class="dialog-box" id="dialogBox">
            <div class="dialog-speaker" id="dialogSpeaker">Speaker</div>
            <div class="dialog-text" id="dialogText">Dialog text here...</div>
            <div class="dialog-continue">Tap to continue ‚ñ∂</div>
        </div>
        
        <!-- Notification -->
        <div class="notification" id="notification"></div>

        <!-- Blood FX -->
        <div id="bloodLayer"></div>
        
        <!-- Minimap -->
        <div class="minimap-container">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <!-- Joystick -->
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
        
        <!-- Weapon Info -->
        <div class="weapon-info">
            <div class="weapon-name" id="weaponName">PISTOL</div>
            <div class="weapon-ammo" id="weaponAmmo">‚àû</div>
        </div>
        
        <!-- Weapon Switch Button -->
        <div id="weaponSwitchButton">üîÑ</div>
        
        <!-- Action Buttons -->
        <div id="holdUpButton" class="action-button">‚úã</div>
        <div id="gunButton" class="action-button">üî´</div>
    </div>

    <script src="three.min.js"></script>
    <script>
        // ============================================
        // GAME STATE
        // ============================================
        let scene, camera, renderer;
        let character;
        let npcs = [];
        let cars = [];
        let buildings = [];
        let trees = [];
        let questGivers = [];
        let questTargetNPCs = [];
        let pendingQuest = null;
        let questGiverNPC = null;
        
        // Player Stats
        let playerHealth = 100;
        let playerCash = 0;
        let wantedLevel = 0;
        let lastCarHitTime = 0;
        let playerStunUntil = 0;
        let cameraShakeUntil = 0;
        let cameraShakeStrength = 0;
        let playerKnockdownStart = 0;
        let playerKnockdownEnd = 0;
        let playerRollSpins = 0;
        let playerBaseYaw = 0;
        let playerKnockbackEnd = 0;
        let playerKnockbackVel = new THREE.Vector3();
        
        // Inventory
        let inventory = new Set();
        
        // Controls
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };
        let keys = {};
        
        // Camera
        let cameraAngle = 0;
        let cameraDistance = 15;
        let cameraHeight = 10;
        
        // World
        const WORLD_SIZE = 500;
        const ROAD_WIDTH = 20;
        const BLOCK_SIZE = 100;
        
        // ============================================
        // WEAPON SYSTEM
        // ============================================
        const WEAPONS = {
            pistol: {
                name: 'PISTOL', damage: 25, fireRate: 500, ammo: Infinity,
                maxAmmo: Infinity, spread: 0.05, icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHJlY3QgeD0iOCIgeT0iMjgiIHdpZHRoPSIzNCIgaGVpZ2h0PSIxMCIgcng9IjIiIGZpbGw9IiNmNWY1ZjUiLz48cmVjdCB4PSIzNiIgeT0iMzAiIHdpZHRoPSIxMiIgaGVpZ2h0PSI2IiByeD0iMiIgZmlsbD0iI2Y1ZjVmNSIvPjxyZWN0IHg9IjI0IiB5PSIzOCIgd2lkdGg9IjgiIGhlaWdodD0iMTQiIHJ4PSIyIiBmaWxsPSIjZjVmNWY1Ii8+PC9zdmc+', color: 0xffff00,
                projectileSpeed: 2, isAutomatic: false,
                projectileIcon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHJlY3QgeD0iMjgiIHk9IjYiIHdpZHRoPSI4IiBoZWlnaHQ9IjQwIiByeD0iNCIgZmlsbD0iI2ZmZTA2NiIvPjxjaXJjbGUgY3g9IjMyIiBjeT0iNTAiIHI9IjYiIGZpbGw9IiNmZmUwNjYiLz48L3N2Zz4=',
                projectileScale: 0.7
            },
            uzi: {
                name: 'UZI', damage: 15, fireRate: 100, ammo: 120,
                maxAmmo: 120, spread: 0.15, icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHJlY3QgeD0iOCIgeT0iMjYiIHdpZHRoPSIzNiIgaGVpZ2h0PSIxMiIgcng9IjIiIGZpbGw9IiNmZmQxNjYiLz48cmVjdCB4PSIzNiIgeT0iMjgiIHdpZHRoPSIxNCIgaGVpZ2h0PSI2IiByeD0iMiIgZmlsbD0iI2ZmZDE2NiIvPjxyZWN0IHg9IjIwIiB5PSIzOCIgd2lkdGg9IjgiIGhlaWdodD0iMTQiIHJ4PSIyIiBmaWxsPSIjZmZkMTY2Ii8+PHJlY3QgeD0iNDQiIHk9IjI0IiB3aWR0aD0iMTIiIGhlaWdodD0iNCIgcng9IjEiIGZpbGw9IiNmZmQxNjYiLz48L3N2Zz4=', color: 0xffaa00,
                projectileSpeed: 2.5, isAutomatic: true,
                projectileIcon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHJlY3QgeD0iMTAiIHk9IjI4IiB3aWR0aD0iNDQiIGhlaWdodD0iOCIgcng9IjQiIGZpbGw9IiNmZjlmMWMiLz48cmVjdCB4PSI0MiIgeT0iMjQiIHdpZHRoPSIxMiIgaGVpZ2h0PSIxNiIgcng9IjYiIGZpbGw9IiNmZjlmMWMiLz48L3N2Zz4=',
                projectileScale: 0.8
            },
            rocketLauncher: {
                name: 'ROCKET', damage: 100, fireRate: 1500, ammo: 5,
                maxAmmo: 5, spread: 0, icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHJlY3QgeD0iMjYiIHk9IjE0IiB3aWR0aD0iMTIiIGhlaWdodD0iMjgiIHJ4PSI2IiBmaWxsPSIjZmY2YjM1Ii8+PHBvbHlnb24gcG9pbnRzPSIzMiw2IDM4LDE0IDI2LDE0IiBmaWxsPSIjZmY2YjM1Ii8+PHBvbHlnb24gcG9pbnRzPSIyNiwzMiAxNiwzOCAyNiwzOCIgZmlsbD0iI2ZmNmIzNSIvPjxwb2x5Z29uIHBvaW50cz0iMzgsMzIgMzgsMzggNDgsMzgiIGZpbGw9IiNmZjZiMzUiLz48Y2lyY2xlIGN4PSIzMiIgY3k9IjI0IiByPSI0IiBmaWxsPSIjMTExIi8+PC9zdmc+', color: 0xff4400,
                projectileSpeed: 1, isAutomatic: false, explosive: true, explosionRadius: 10
            }
        };
        
        let currentWeaponIndex = 0;
        const weaponKeys = ['pistol', 'uzi', 'rocketLauncher'];
        let currentWeapon = weaponKeys[currentWeaponIndex];
        let lastShotTime = 0;
        let projectiles = [];
        let explosions = [];
        const projectileSpriteCache = new Map();
        
        // ============================================
        // QUEST CHAIN DATA - ƒê·∫ßy ƒë·ªß t·ª´ code.html g·ªëc
        // ============================================
        const QUEST_CHAINS = {
            "main_story": [
                {
                    id: "Q01",
                    title: "First Night",
                    giverName: "Switch",
                    intro_dialog: [
                        {speaker: "Switch", text: "You look fresh off the bus. Hungry? I pay in cash and chances."},
                        {speaker: "Player", text: "Depends on the menu."},
                        {speaker: "Switch", text: "Start simple. Come find me at the High Street Diner. We talk, we see."}
                    ],
                    objective: {
                        type: "TALK",
                        targetLocation: "High Street Diner",
                        description: "Meet Switch outside the High Street Diner",
                        minDistance: 50,
                        maxDistance: 150
                    },
                    reward: {cash: 500},
                    autostart_next: true
                },
                {
                    id: "Q02",
                    title: "Starter Package",
                    giverName: "Switch",
                    intro_dialog: [
                        {speaker: "Switch", text: "Doc K at the docks needs a parcel‚Äîno shakes, no peeks."},
                        {speaker: "Player", text: "What's inside?"},
                        {speaker: "Switch", text: "The kind of question that lowers your rate. Just deliver."}
                    ],
                    objective: {
                        type: "DELIVER_ITEM",
                        item: "Sealed Parcel",
                        fromLocation: "High Street Diner",
                        toLocation: "Dock 12",
                        description: "Deliver the sealed parcel to Doc K at Dock 12",
                        minDistance: 100
                    },
                    reward: {cash: 1000},
                    autostart_next: true
                },
                {
                    id: "Q03",
                    title: "Test Drive",
                    giverName: "Doc K",
                    intro_dialog: [
                        {speaker: "Doc K", text: "Chopshop owes me. They want a Kuruma GT‚Äîclean condition."},
                        {speaker: "Player", text: "Keys?"},
                        {speaker: "Doc K", text: "Owner keeps them in the ignition. Lucky them, luckier you."}
                    ],
                    objective: {
                        type: "STEAL_CAR",
                        fromLocation: "Sable Row Parking",
                        toLocation: "Eastside Chopshop",
                        description: "Steal a car and deliver it to Eastside Chopshop",
                        minDistance: 100,
                        maxDistance: 250
                    },
                    reward: {cash: 1500},
                    autostart_next: true
                },
                {
                    id: "Q04",
                    title: "Noise Control",
                    giverName: "Rex",
                    intro_dialog: [
                        {speaker: "Rex", text: "Nines sells a signal muffler. We want it, fast."},
                        {speaker: "Player", text: "You buying or me?"},
                        {speaker: "Rex", text: "You buy, we reimburse. Bring a receipt. He hates fakes."}
                    ],
                    objective: {
                        type: "BUY",
                        item: "Signal Muffler",
                        vendorLocation: "Underpass Market",
                        price: 600,
                        description: "Buy a Signal Muffler from Nines at Underpass Market",
                        minDistance: 100,
                        maxDistance: 200
                    },
                    reward: {cash: 900},
                    autostart_next: true
                },
                {
                    id: "Q04B",
                    title: "The Drop-Off",
                    giverName: "Rex",
                    intro_dialog: [
                        {speaker: "Rex", text: "You got it? Good. Bring it here, now."},
                        {speaker: "Player", text: "On my way."}
                    ],
                    objective: {
                        type: "DELIVER_ITEM",
                        item: "Signal Muffler",
                        fromLocation: "Underpass Market",
                        toLocation: "Eastside Chopshop",
                        description: "Deliver the Signal Muffler to Rex at Eastside Chopshop"
                    },
                    reward: {cash: 300},
                    autostart_next: true
                },
                {
                    id: "Q05",
                    title: "Street Justice",
                    giverName: "Rex",
                    intro_dialog: [
                        {speaker: "Rex", text: "Razor's crew hijacked our delivery."},
                        {speaker: "Player", text: "Where's Razor?"},
                        {speaker: "Rex", text: "Pier 4. End him, then scatter."}
                    ],
                    objective: {
                        type: "KILL",
                        targetName: "Razor",
                        targetLocation: "Pier 4",
                        description: "Eliminate Razor at Pier 4",
                        minDistance: 150
                    },
                    reward: {cash: 2000, weapon: 'uzi'},
                    autostart_next: true
                },
                {
                    id: "Q06",
                    title: "Big Score",
                    giverName: "Rex",
                    intro_dialog: [
                        {speaker: "Rex", text: "You've proven yourself. Time for the big leagues."},
                        {speaker: "Player", text: "What's the job?"},
                        {speaker: "Rex", text: "Bank on 5th. In and out. You keep 30%."}
                    ],
                    objective: {
                        type: "REACH_LOCATION",
                        targetLocation: "First National Bank",
                        description: "Get to the First National Bank on 5th Street",
                        minDistance: 200
                    },
                    reward: {cash: 5000, weapon: 'rocketLauncher'},
                    autostart_next: false
                }
            ]
        };
        
        // Quest System State
        let questChainData = null;
        let questChainProgress = {
            currentChain: null,
            currentIndex: 0,
            completedQuests: [],
            objectiveProgress: {}
        };
        let currentQuest = null;
        let namedLocations = {};
        let questTargetMarkers = [];
        
        // NPC Appearance Definitions
        const npcDefinitions = {
            "Switch": { shirtColor: 0x333333, hairColor: 0x000000 },
            "Doc K": { shirtColor: 0x8B4513, hairColor: 0x808080 },
            "Rex": { shirtColor: 0xff0000, hairColor: 0xFFE4B5 },
            "Nines": { shirtColor: 0x0000ff, hairColor: 0x000000 },
            "Razor": { shirtColor: 0x800000, hairColor: 0x000000 }
        };
        
        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 400);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(100, 150, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Create world
            createGround();
            createRoads();
            createBuildings();
            createTrees();
            createCharacter();
            createNPCs(15);
            createCars(14);
            
            // Initialize Quest System
            initializeQuestChains();
            
            // Setup controls
            setupControls();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    // Start first quest with intro dialog
                    startFirstQuest();
                }, 1000);
            }, 2000);
            
            // Start game loop
            animate();
        }
        
        // ============================================
        // WORLD CREATION
        // ============================================
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3d8b3d });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        function createRoads() {
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            
            for (let i = -2; i <= 2; i++) {
                // Horizontal roads
                const hRoad = new THREE.Mesh(
                    new THREE.PlaneGeometry(WORLD_SIZE, ROAD_WIDTH),
                    roadMaterial
                );
                hRoad.rotation.x = -Math.PI / 2;
                hRoad.position.set(0, 0.01, i * BLOCK_SIZE);
                scene.add(hRoad);
                
                // Vertical roads
                const vRoad = new THREE.Mesh(
                    new THREE.PlaneGeometry(ROAD_WIDTH, WORLD_SIZE),
                    roadMaterial
                );
                vRoad.rotation.x = -Math.PI / 2;
                vRoad.position.set(i * BLOCK_SIZE, 0.01, 0);
                scene.add(vRoad);
            }
        }
        
        function createBuildings() {
            const buildingColors = [0x8B4513, 0x696969, 0x4a4a4a, 0x5c4033, 0x36454f];
            
            for (let bx = -2; bx <= 1; bx++) {
                for (let bz = -2; bz <= 1; bz++) {
                    if (Math.random() > 0.3) {
                        const height = 20 + Math.random() * 60;
                        const width = 30 + Math.random() * 30;
                        const depth = 30 + Math.random() * 30;
                        
                        const geometry = new THREE.BoxGeometry(width, height, depth);
                        const material = new THREE.MeshLambertMaterial({
                            color: buildingColors[Math.floor(Math.random() * buildingColors.length)]
                        });
                        
                        const building = new THREE.Mesh(geometry, material);
                        const halfW = width / 2;
                        const halfD = depth / 2;
                        const blockCenterX = (bx + 0.5) * BLOCK_SIZE;
                        const blockCenterZ = (bz + 0.5) * BLOCK_SIZE;
                        const freeHalfX = (BLOCK_SIZE - ROAD_WIDTH) / 2 - halfW - 2;
                        const freeHalfZ = (BLOCK_SIZE - ROAD_WIDTH) / 2 - halfD - 2;
                        if (freeHalfX <= 0 || freeHalfZ <= 0) {
                            continue;
                        }
                        
                        const localX = (Math.random() * 2 - 1) * freeHalfX;
                        const localZ = (Math.random() * 2 - 1) * freeHalfZ;
                        
                        building.position.set(
                            blockCenterX + localX,
                            height / 2,
                            blockCenterZ + localZ
                        );
                        building.userData.halfW = halfW;
                        building.userData.halfD = halfD;
                        building.castShadow = true;
                        building.receiveShadow = true;
                        
                        scene.add(building);
                        buildings.push(building);
                    }
                }
            }
        }
        
        function createTrees() {
            for (let i = 0; i < 50; i++) {
                const x = (Math.random() - 0.5) * WORLD_SIZE * 0.9;
                const z = (Math.random() - 0.5) * WORLD_SIZE * 0.9;
                
                if (Math.abs(x % BLOCK_SIZE) > ROAD_WIDTH && Math.abs(z % BLOCK_SIZE) > ROAD_WIDTH) {
                    const treeGroup = new THREE.Group();
                    
                    const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4, 8);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2;
                    treeGroup.add(trunk);
                    
                    const leavesGeometry = new THREE.SphereGeometry(3, 8, 8);
                    const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.y = 6;
                    treeGroup.add(leaves);
                    
                    treeGroup.position.set(x, 0, z);
                    scene.add(treeGroup);
                    trees.push(treeGroup);
                }
            }
        }
        
        // ============================================
        // CHARACTER CREATION
        // ============================================
        function createCharacter(x = 0, z = 0, isPlayer = true, appearance = null) {
            const charGroup = new THREE.Group();
            
            const shirtColor = appearance?.shirtColor || (isPlayer ? 0x333333 : 0xff0000);
            const hairColor = appearance?.hairColor || 0x3d2914;
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.5);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: shirtColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.25;
            body.castShadow = true;
            charGroup.add(body);
            charGroup.userData.body = body;
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.3;
            charGroup.add(head);
            
            // Hair
            const hairGeometry = new THREE.BoxGeometry(0.65, 0.2, 0.65);
            const hairMaterial = new THREE.MeshLambertMaterial({ color: hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 2.7;
            charGroup.add(hair);
            
            // Legs with pivots
            const legGeometry = new THREE.BoxGeometry(0.35, 1, 0.35);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            
            const leftLegPivot = new THREE.Group();
            leftLegPivot.position.set(-0.2, 1, 0);
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.y = -0.5;
            leftLegPivot.add(leftLeg);
            charGroup.add(leftLegPivot);
            charGroup.userData.leftLegPivot = leftLegPivot;
            
            const rightLegPivot = new THREE.Group();
            rightLegPivot.position.set(0.2, 1, 0);
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.y = -0.5;
            rightLegPivot.add(rightLeg);
            charGroup.add(rightLegPivot);
            charGroup.userData.rightLegPivot = rightLegPivot;
            
            // Arms with pivots
            const armGeometry = new THREE.BoxGeometry(0.25, 1, 0.25);
            const armMaterial = new THREE.MeshLambertMaterial({ color: shirtColor });
            
            const leftArmPivot = new THREE.Group();
            leftArmPivot.position.set(-0.65, 1.75, 0);
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.y = -0.5;
            leftArmPivot.add(leftArm);
            charGroup.add(leftArmPivot);
            charGroup.userData.leftArmPivot = leftArmPivot;
            
            const rightArmPivot = new THREE.Group();
            rightArmPivot.position.set(0.65, 1.75, 0);
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.y = -0.5;
            rightArmPivot.add(rightArm);
            charGroup.add(rightArmPivot);
            charGroup.userData.rightArmPivot = rightArmPivot;
            
            charGroup.userData.walkTime = 0;
            charGroup.userData.health = 100;
            charGroup.position.set(x, 0, z);
            scene.add(charGroup);
            
            if (isPlayer) {
                character = charGroup;
            }
            
            return charGroup;
        }
        
        function createNPCs(count) {
            const shirtColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            
            for (let i = 0; i < count; i++) {
                let x, z;
                do {
                    x = (Math.random() - 0.5) * WORLD_SIZE * 0.8;
                    z = (Math.random() - 0.5) * WORLD_SIZE * 0.8;
                } while (Math.sqrt(x*x + z*z) < 30);
                
                const npc = createCharacter(x, z, false, {
                    shirtColor: shirtColors[Math.floor(Math.random() * shirtColors.length)],
                    hairColor: [0x000000, 0x3d2914, 0xFFE4B5, 0x808080][Math.floor(Math.random() * 4)]
                });
                
                npc.userData.speed = 0.02 + Math.random() * 0.03;
                npc.userData.wanderTarget = pickNPCWanderTarget(npc.position);
                npc.userData.pauseUntil = 0;
                npc.userData.isNPC = true;
                
                npcs.push(npc);
            }
        }

        function pickNPCWanderTarget(origin) {
            let x, z;
            let tries = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 120;
                x = origin.x + Math.cos(angle) * distance;
                z = origin.z + Math.sin(angle) * distance;
                x = Math.max(-WORLD_SIZE/2 + 15, Math.min(WORLD_SIZE/2 - 15, x));
                z = Math.max(-WORLD_SIZE/2 + 15, Math.min(WORLD_SIZE/2 - 15, z));
                tries++;
            } while (tries < 20 && isLocationOnRoad(x, z));
            return { x, z };
        }
        
        function createCars(count) {
            const carColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0xffffff, 0x000000];
            
            for (let i = 0; i < count; i++) {
                const car = new THREE.Group();
                
                const roadIndex = Math.floor(Math.random() * 5) - 2;
                const isHorizontal = Math.random() > 0.5;
                const offset = (Math.random() - 0.5) * WORLD_SIZE * 0.8;
                const laneOffset = (Math.random() > 0.5 ? 4 : -4);
                
                let x, z, rotation;
                if (isHorizontal) {
                    x = offset;
                    z = roadIndex * BLOCK_SIZE + laneOffset;
                    rotation = Math.random() > 0.5 ? 0 : Math.PI;
                } else {
                    x = roadIndex * BLOCK_SIZE + laneOffset;
                    z = offset;
                    rotation = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
                }
                
                const isPolice = Math.random() < 0.2;
                const carColor = isPolice ? 0x111111 : carColors[Math.floor(Math.random() * carColors.length)];
                
                // Car body
                const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 2);
                if (isPolice) {
                    const bodyGeomHalf = new THREE.BoxGeometry(4, 1.5, 1);
                    const bodyWhite = new THREE.Mesh(
                        bodyGeomHalf,
                        new THREE.MeshLambertMaterial({ color: 0xffffff })
                    );
                    const bodyBlack = new THREE.Mesh(
                        bodyGeomHalf,
                        new THREE.MeshLambertMaterial({ color: 0x111111 })
                    );
                    bodyWhite.position.set(0, 0.75, 0.5);
                    bodyBlack.position.set(0, 0.75, -0.5);
                    car.add(bodyWhite);
                    car.add(bodyBlack);
                } else {
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: carColor });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.75;
                    car.add(body);
                }
                
                // Car roof
                const roofGeometry = new THREE.BoxGeometry(2, 1, 1.8);
                const roofMaterial = new THREE.MeshLambertMaterial({ color: isPolice ? 0xffffff : carColor });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(-0.3, 1.75, 0);
                car.add(roof);

                if (isPolice) {
                    const barGeometry = new THREE.BoxGeometry(1.4, 0.2, 0.6);
                    const barMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
                    const bar = new THREE.Mesh(barGeometry, barMaterial);
                    bar.position.set(-0.3, 2.2, 0);
                    car.add(bar);

                    const lightGeometry = new THREE.BoxGeometry(0.5, 0.2, 0.4);
                    const redLight = new THREE.Mesh(
                        lightGeometry,
                        new THREE.MeshBasicMaterial({ color: 0xff3333 })
                    );
                    const blueLight = new THREE.Mesh(
                        lightGeometry,
                        new THREE.MeshBasicMaterial({ color: 0x3388ff })
                    );
                    redLight.position.set(-0.7, 2.25, -0.2);
                    blueLight.position.set(-0.7, 2.25, 0.2);
                    car.add(redLight);
                    car.add(blueLight);
                    car.userData.policeLights = { red: redLight, blue: blueLight };
                }
                
                // Wheels
                const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
                const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
                
                [[-1.2, 0.4, 1.1], [-1.2, 0.4, -1.1], [1.2, 0.4, 1.1], [1.2, 0.4, -1.1]].forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.x = Math.PI / 2;
                    wheel.position.set(...pos);
                    car.add(wheel);
                });
                
                car.position.set(x, 0, z);
                car.rotation.y = rotation;
                car.userData.speed = 0.07 + Math.random() * 0.06;
                car.userData.direction = rotation;
                car.userData.roadType = isHorizontal ? 'horizontal' : 'vertical';
                car.userData.roadLine = isHorizontal ? z : x;
                car.userData.isPolice = isPolice;
                
                scene.add(car);
                cars.push(car);
            }
        }

        
        // ============================================
        // QUEST SYSTEM
        // ============================================
        function initializeQuestChains() {
            questChainData = QUEST_CHAINS;
            questChainProgress.currentChain = "main_story";
            questChainProgress.currentIndex = 0;
            namedLocations = {};
        }
        
        function startFirstQuest() {
            const firstQuest = getCurrentChainQuest();
            if (firstQuest && firstQuest.intro_dialog) {
                makeQuestAvailable(firstQuest);
            } else if (firstQuest) {
                makeQuestAvailable(firstQuest);
            }
        }
        
        function getCurrentChainQuest() {
            if (!questChainData || !questChainProgress.currentChain) return null;
            
            const chain = questChainData[questChainProgress.currentChain];
            if (!chain || questChainProgress.currentIndex >= chain.length) return null;
            
            return chain[questChainProgress.currentIndex];
        }
        
        function getOrCreateLocation(locationName, options = {}) {
            if (namedLocations[locationName]) {
                return namedLocations[locationName];
            }
            
            // Generate new location
            const minDist = options.minDistance || 50;
            const maxDist = options.maxDistance || 200;
            
            let x, z, attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const distance = minDist + Math.random() * (maxDist - minDist);
                x = character.position.x + Math.cos(angle) * distance;
                z = character.position.z + Math.sin(angle) * distance;
                
                // Keep within world bounds
                x = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, x));
                z = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, z));
                attempts++;
            } while (attempts < 50 && isLocationOnRoad(x, z));
            
            namedLocations[locationName] = { x, z, name: locationName };
            return namedLocations[locationName];
        }
        
        function isLocationOnRoad(x, z) {
            for (let i = -2; i <= 2; i++) {
                if (Math.abs(z - i * BLOCK_SIZE) < ROAD_WIDTH/2) return true;
                if (Math.abs(x - i * BLOCK_SIZE) < ROAD_WIDTH/2) return true;
            }
            return false;
        }

        function isBuildingOverRoad(x, z, halfW, halfD, margin = 2) {
            for (let i = -2; i <= 2; i++) {
                const hLine = i * BLOCK_SIZE;
                if (Math.abs(z - hLine) < (ROAD_WIDTH / 2 + halfD + margin)) return true;
                const vLine = i * BLOCK_SIZE;
                if (Math.abs(x - vLine) < (ROAD_WIDTH / 2 + halfW + margin)) return true;
            }
            return false;
        }
        
        function startQuest(quest) {
            if (!quest) return;
            
            clearQuestGiver();
            currentQuest = quest;
            
            // Initialize progress
            questChainProgress.objectiveProgress[quest.id] = {
                started: true
            };
            
            // Pre-generate locations
            const objective = quest.objective;
            if (objective) {
                switch (objective.type) {
                    case 'TALK':
                    case 'KILL':
                    case 'REACH_LOCATION':
                        getOrCreateLocation(objective.targetLocation, {
                            minDistance: objective.minDistance,
                            maxDistance: objective.maxDistance
                        });
                        break;
                    case 'DELIVER_ITEM':
                        getOrCreateLocation(objective.fromLocation, { minDistance: 30, maxDistance: 80 });
                        getOrCreateLocation(objective.toLocation, {
                            minDistance: objective.minDistance || 100,
                            maxDistance: objective.maxDistance || 200
                        });
                        break;
                    case 'STEAL_CAR':
                        getOrCreateLocation(objective.fromLocation, { minDistance: 50, maxDistance: 150 });
                        getOrCreateLocation(objective.toLocation, {
                            minDistance: objective.minDistance || 100,
                            maxDistance: objective.maxDistance || 250
                        });
                        break;
                    case 'BUY':
                        getOrCreateLocation(objective.vendorLocation, {
                            minDistance: objective.minDistance,
                            maxDistance: objective.maxDistance
                        });
                        break;
                }
            }
            
            // Update UI
            updateQuestUI();
            showNotification(`New Quest: ${quest.title}`);
            
            console.log(`Started quest: ${quest.title}`);
        }

        function makeQuestAvailable(quest) {
            if (!quest) return;
            pendingQuest = quest;
            questGiverNPC = pickQuestGiverNPC();
            if (questGiverNPC) {
                attachQuestMarker(questGiverNPC, 0xffaa00);
                showNotification('New quest available! Find the marker.');
                updateQuestUI();
            } else {
                // Fallback: start immediately if no NPCs are available
                startQuest(quest);
            }
        }

        function pickQuestGiverNPC() {
            if (!npcs.length) return null;
            const candidates = npcs.filter(npc => {
                if (!npc || npc.userData.isQuestTarget) return false;
                const dist = npc.position.distanceTo(character.position);
                return dist > 20;
            });
            const pool = candidates.length ? candidates : npcs;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function clearQuestGiver() {
            if (questGiverNPC && questGiverNPC.userData.questMarker) {
                scene.remove(questGiverNPC.userData.questMarker);
                questGiverNPC.userData.questMarker = null;
            }
            questGiverNPC = null;
            pendingQuest = null;
        }

        function createQuestMarkerSprite(colorHex, labelText) {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, size, size);
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size * 0.46, 0, Math.PI * 2);
            ctx.fillStyle = '#111';
            ctx.fill();
            ctx.lineWidth = 8;
            ctx.strokeStyle = `#${colorHex.toString(16).padStart(6, '0')}`;
            ctx.stroke();

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 72px Denk One, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(labelText, size / 2, size / 2 + 4);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2.2, 2.2, 1);
            sprite.userData.bobPhase = Math.random() * Math.PI * 2;
            return sprite;
        }

        function attachQuestMarker(npc, colorHex, labelText = '!') {
            if (!npc) return;
            if (npc.userData.questMarker) {
                scene.remove(npc.userData.questMarker);
            }
            const marker = createQuestMarkerSprite(colorHex, labelText);
            npc.userData.questMarker = marker;
            scene.add(marker);
        }
        
        function updateQuestUI() {
            const container = document.getElementById('questContainer');
            const title = document.getElementById('questTitle');
            const desc = document.getElementById('questDescription');
            
            if (currentQuest) {
                container.style.display = 'block';
                title.textContent = currentQuest.title;
                desc.textContent = currentQuest.objective?.description || currentQuest.description || '';
            } else if (pendingQuest) {
                container.style.display = 'block';
                title.textContent = pendingQuest.title;
                desc.textContent = 'Find the marked NPC to start this quest.';
            } else {
                container.style.display = 'none';
            }
        }
        
        function checkQuestObjective() {
            if (!currentQuest || !currentQuest.objective) return;
            
            const objective = currentQuest.objective;
            const progress = questChainProgress.objectiveProgress[currentQuest.id];
            
            let targetLocation = null;
            let distance = Infinity;
            
            switch (objective.type) {
                case 'TALK':
                case 'REACH_LOCATION':
                    targetLocation = namedLocations[objective.targetLocation];
                    if (targetLocation) {
                        distance = getDistanceTo(targetLocation.x, targetLocation.z);
                        if (distance < 10) {
                            completeQuest();
                        }
                    }
                    break;
                    
                case 'DELIVER_ITEM':
                    if (!hasItem(objective.item)) {
                        // Pickup phase
                        targetLocation = namedLocations[objective.fromLocation];
                        if (targetLocation) {
                            distance = getDistanceTo(targetLocation.x, targetLocation.z);
                            if (distance < 10) {
                                addItem(objective.item);
                                showNotification(`Picked up: ${objective.item}`);
                                document.getElementById('questDescription').textContent = 
                                    `Deliver ${objective.item} to ${objective.toLocation}`;
                            }
                        }
                    } else {
                        // Delivery phase
                        targetLocation = namedLocations[objective.toLocation];
                        if (targetLocation) {
                            distance = getDistanceTo(targetLocation.x, targetLocation.z);
                            if (distance < 10) {
                                removeItem(objective.item);
                                completeQuest();
                            }
                        }
                    }
                    break;
                    
                case 'STEAL_CAR':
                    if (!progress.hasCar) {
                        // Find car phase
                        targetLocation = namedLocations[objective.fromLocation];
                        if (targetLocation) {
                            distance = getDistanceTo(targetLocation.x, targetLocation.z);
                            // Check if near any car
                            cars.forEach(car => {
                                const carDist = character.position.distanceTo(car.position);
                                if (carDist < 5) {
                                    progress.hasCar = true;
                                    progress.stolenCar = car;
                                    showNotification('Car acquired! Deliver to dropoff.');
                                    document.getElementById('questDescription').textContent = 
                                        `Deliver the car to ${objective.toLocation}`;
                                }
                            });
                        }
                    } else {
                        // Delivery phase
                        targetLocation = namedLocations[objective.toLocation];
                        if (targetLocation) {
                            distance = getDistanceTo(targetLocation.x, targetLocation.z);
                            if (distance < 15) {
                                completeQuest();
                            }
                        }
                    }
                    break;
                    
                case 'BUY':
                    targetLocation = namedLocations[objective.vendorLocation];
                    if (targetLocation) {
                        distance = getDistanceTo(targetLocation.x, targetLocation.z);
                        if (distance < 10 && playerCash >= objective.price) {
                            playerCash -= objective.price;
                            addItem(objective.item);
                            showNotification(`Bought: ${objective.item}`);
                            updateUI();
                            completeQuest();
                        } else if (distance < 10 && playerCash < objective.price) {
                            showNotification(`Need $${objective.price} to buy ${objective.item}`);
                        }
                    }
                    break;
                    
                case 'KILL':
                    targetLocation = namedLocations[objective.targetLocation];
                    if (targetLocation) {
                        distance = getDistanceTo(targetLocation.x, targetLocation.z);
                        
                        // Spawn target NPC if close enough
                        if (distance < 50 && !progress.targetSpawned) {
                            spawnQuestTarget(objective.targetName, targetLocation);
                            progress.targetSpawned = true;
                        }
                        
                        // Check if target is killed
                        if (progress.targetKilled) {
                            completeQuest();
                        }
                    }
                    break;
            }
            
            // Update distance display
            if (targetLocation) {
                document.getElementById('questDistance').textContent = `Distance: ${Math.round(distance)}m`;
            }
            
            // Update quest arrow
            updateQuestArrow(targetLocation);
        }
        
        function spawnQuestTarget(targetName, location) {
            const appearance = npcDefinitions[targetName] || {
                shirtColor: 0x800000,
                hairColor: 0x000000
            };
            
            const targetNPC = createCharacter(location.x, location.z, false, appearance);
            targetNPC.userData.isQuestTarget = true;
            targetNPC.userData.targetName = targetName;
            targetNPC.userData.isAggressive = true;
            attachQuestMarker(targetNPC, 0xff4444);
            
            questTargetNPCs.push(targetNPC);
            npcs.push(targetNPC);
            
            showNotification(`${targetName} spotted!`);
        }
        
        function completeQuest() {
            if (!currentQuest) return;
            
            // Award rewards
            if (currentQuest.reward) {
                if (currentQuest.reward.cash) {
                    playerCash += currentQuest.reward.cash;
                    showNotification(`+$${currentQuest.reward.cash}`);
                }
                if (currentQuest.reward.weapon) {
                    showNotification(`Unlocked: ${WEAPONS[currentQuest.reward.weapon]?.name || currentQuest.reward.weapon}`);
                }
            }
            
            updateUI();
            
            // Track completion
            questChainProgress.completedQuests.push(currentQuest.id);
            questChainProgress.currentIndex++;
            
            const shouldAutoStart = currentQuest.autostart_next;
            
            showNotification(`Quest Complete: ${currentQuest.title}`);
            
            // Clear current quest
            currentQuest = null;
            updateQuestUI();
            
            // Hide quest arrow
            document.getElementById('questArrow').style.display = 'none';
            
            // Start next quest
            setTimeout(() => {
                const nextQuest = getCurrentChainQuest();
                if (nextQuest) {
                    makeQuestAvailable(nextQuest);
                } else {
                    showNotification('All quests completed! üéâ');
                }
            }, 2000);
        }
        
        function updateQuestArrow(targetLocation) {
            const arrow = document.getElementById('questArrow');
            
            if (!targetLocation || (!currentQuest && !pendingQuest)) {
                arrow.style.display = 'none';
                return;
            }
            
            arrow.style.display = 'block';
            
            // Calculate screen-space direction from player to target
            const playerPos = new THREE.Vector3(
                character.position.x,
                character.position.y,
                character.position.z
            );
            const targetPos = new THREE.Vector3(targetLocation.x, playerPos.y, targetLocation.z);
            const playerNDC = playerPos.clone().project(camera);
            const targetNDC = targetPos.clone().project(camera);
            const dx = targetNDC.x - playerNDC.x;
            const dy = targetNDC.y - playerNDC.y;
            const angle = Math.atan2(dx, dy) * (180 / Math.PI);
            
            arrow.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        }

        function updateQuestMarkers(currentTime) {
            npcs.forEach(npc => {
                const marker = npc?.userData?.questMarker;
                if (!marker) return;
                const bob = Math.sin(currentTime * 0.004 + marker.userData.bobPhase) * 0.1;
                marker.position.set(npc.position.x, npc.position.y + 3.2 + bob, npc.position.z);
            });
        }

        function tryStartPendingQuest() {
            if (!pendingQuest || !questGiverNPC) return;
            const dist = character.position.distanceTo(questGiverNPC.position);
            if (dist > 4) return;
            const quest = pendingQuest;
            clearQuestGiver();
            if (quest.intro_dialog) {
                showDialog(quest.intro_dialog, () => startQuest(quest));
            } else {
                startQuest(quest);
            }
        }

        function updatePendingQuestGuidance() {
            if (!pendingQuest || !questGiverNPC) return;
            const targetLocation = { x: questGiverNPC.position.x, z: questGiverNPC.position.z };
            const distance = getDistanceTo(targetLocation.x, targetLocation.z);
            document.getElementById('questDistance').textContent = `Distance: ${Math.round(distance)}m`;
            updateQuestArrow(targetLocation);
        }

        function updatePlayerKnockdown(currentTime) {
            if (currentTime >= playerKnockdownEnd) {
                character.rotation.z = 0;
                return false;
            }
            const t = currentTime - playerKnockdownStart;
            const fallEnd = 250;
            const rollEnd = 1050;
            const total = Math.max(1, playerKnockdownEnd - playerKnockdownStart);
            const standStart = Math.min(rollEnd, total * 0.8);
            let rotZ = 0;

            if (t < fallEnd) {
                const u = t / fallEnd;
                rotZ = -Math.PI / 2 * u;
            } else if (t < standStart) {
                const spinT = (t - fallEnd) / Math.max(1, standStart - fallEnd);
                rotZ = -Math.PI / 2 - spinT * (Math.PI * 2 * playerRollSpins);
            } else {
                const u = (t - standStart) / Math.max(1, total - standStart);
                rotZ = (-Math.PI / 2) * (1 - u);
            }

            character.rotation.y = playerBaseYaw;
            character.rotation.x = 0;
            character.rotation.z = rotZ;
            return true;
        }

        function isBlockedByBuilding(x, z) {
            for (let i = 0; i < buildings.length; i++) {
                const b = buildings[i];
                const halfW = b.userData.halfW || 0;
                const halfD = b.userData.halfD || 0;
                if (
                    Math.abs(x - b.position.x) < halfW + 1 &&
                    Math.abs(z - b.position.z) < halfD + 1
                ) {
                    return true;
                }
            }
            return false;
        }

        function spawnBloodSplatter(count = 1) {
            const layer = document.getElementById('bloodLayer');
            if (!layer) return;
            for (let i = 0; i < count; i++) {
                const splash = document.createElement('div');
                splash.className = 'blood-splash';
                const x = 30 + Math.random() * 40;
                const y = 30 + Math.random() * 40;
                splash.style.left = `${x}%`;
                splash.style.top = `${y}%`;
                splash.style.transform = `translate(-50%, -50%) rotate(${(Math.random() - 0.5) * 60}deg) scale(${0.6 + Math.random() * 0.5})`;
                layer.appendChild(splash);
                setTimeout(() => splash.remove(), 900);
            }
        }
        
        function getDistanceTo(x, z) {
            return Math.sqrt(
                Math.pow(character.position.x - x, 2) +
                Math.pow(character.position.z - z, 2)
            );
        }
        
        // ============================================
        // INVENTORY SYSTEM
        // ============================================
        function addItem(itemName) {
            inventory.add(itemName);
            updateInventoryUI();
        }
        
        function removeItem(itemName) {
            inventory.delete(itemName);
            updateInventoryUI();
        }
        
        function hasItem(itemName) {
            return inventory.has(itemName);
        }
        
        function updateInventoryUI() {
            const display = document.getElementById('inventoryDisplay');
            const items = document.getElementById('inventoryItems');
            
            if (inventory.size > 0) {
                display.style.display = 'block';
                items.innerHTML = Array.from(inventory).map(item => 
                    `<div class="inventory-item">${item}</div>`
                ).join('');
            } else {
                display.style.display = 'none';
            }
        }
        
        // ============================================
        // DIALOG SYSTEM
        // ============================================
        let currentDialog = null;
        let currentDialogIndex = 0;
        let dialogCallback = null;
        
        function showDialog(lines, onComplete) {
            currentDialog = lines;
            currentDialogIndex = 0;
            dialogCallback = onComplete;
            
            document.getElementById('dialogOverlay').style.display = 'block';
            document.getElementById('dialogBox').style.display = 'block';
            
            showDialogLine();
        }
        
        function showDialogLine() {
            if (currentDialogIndex >= currentDialog.length) {
                closeDialog();
                return;
            }
            
            const line = currentDialog[currentDialogIndex];
            document.getElementById('dialogSpeaker').textContent = line.speaker;
            document.getElementById('dialogText').textContent = line.text;
        }
        
        function advanceDialog() {
            currentDialogIndex++;
            showDialogLine();
        }
        
        function closeDialog() {
            document.getElementById('dialogOverlay').style.display = 'none';
            document.getElementById('dialogBox').style.display = 'none';
            
            currentDialog = null;
            currentDialogIndex = 0;
            
            if (dialogCallback) {
                const cb = dialogCallback;
                dialogCallback = null;
                cb();
            }
        }
        
        // ============================================
        // NOTIFICATION SYSTEM
        // ============================================
        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.textContent = text;
            notif.style.display = 'block';
            notif.style.animation = 'none';
            notif.offsetHeight; // Trigger reflow
            notif.style.animation = 'fadeInOut 3s forwards';
            
            setTimeout(() => {
                notif.style.display = 'none';
            }, 3000);
        }
        
        // ============================================
        // CONTROLS
        // ============================================
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => { keys[e.code] = true; });
            document.addEventListener('keyup', (e) => { keys[e.code] = false; });
            
            // Joystick
            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystickKnob');
            
            const handleJoystick = (clientX, clientY) => {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = clientX - centerX;
                let dy = clientY - centerY;
                
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = rect.width / 2 - 25;
                
                if (distance > maxDistance) {
                    dx = (dx / distance) * maxDistance;
                    dy = (dy / distance) * maxDistance;
                }
                
                knob.style.left = `calc(50% + ${dx}px)`;
                knob.style.top = `calc(50% + ${dy}px)`;
                
                joystickVector.x = dx / maxDistance;
                joystickVector.y = dy / maxDistance;
            };
            
            joystick.addEventListener('touchstart', (e) => {
                joystickActive = true;
                handleJoystick(e.touches[0].clientX, e.touches[0].clientY);
            });
            
            joystick.addEventListener('touchmove', (e) => {
                if (joystickActive) handleJoystick(e.touches[0].clientX, e.touches[0].clientY);
            });
            
            joystick.addEventListener('touchend', () => {
                joystickActive = false;
                joystickVector = { x: 0, y: 0 };
                knob.style.left = '50%';
                knob.style.top = '50%';
            });
            
            joystick.addEventListener('mousedown', (e) => {
                joystickActive = true;
                handleJoystick(e.clientX, e.clientY);
            });
            
            document.addEventListener('mousemove', (e) => {
                if (joystickActive) handleJoystick(e.clientX, e.clientY);
            });
            
            document.addEventListener('mouseup', () => {
                joystickActive = false;
                joystickVector = { x: 0, y: 0 };
                knob.style.left = '50%';
                knob.style.top = '50%';
            });
            
            // Action buttons
            document.getElementById('gunButton').addEventListener('click', shoot);
            document.getElementById('gunButton').addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); });
            document.getElementById('holdUpButton').addEventListener('click', holdUp);
            document.getElementById('weaponSwitchButton').addEventListener('click', switchWeapon);
            document.getElementById('weaponSwitchButton').addEventListener('touchstart', (e) => { e.preventDefault(); switchWeapon(); });
            
            // Dialog click
            document.getElementById('dialogOverlay').addEventListener('click', advanceDialog);
            document.getElementById('dialogBox').addEventListener('click', advanceDialog);
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                // adjust UI scale on resize
                try { updateUIScale(); } catch(e) { }
            });
        }
        
        // ============================================
        // WEAPON FUNCTIONS
        // ============================================
        function selectWeapon(index) {
            if (index < 0 || index >= weaponKeys.length) return;
            if (currentWeaponIndex === index) return;
            currentWeaponIndex = index;
            currentWeapon = weaponKeys[currentWeaponIndex];
            updateWeaponUI();
        }

        function switchWeapon() {
            selectWeapon((currentWeaponIndex + 1) % weaponKeys.length);
        }
        
        function updateWeaponUI() {
            const weapon = WEAPONS[currentWeapon];
            document.getElementById('weaponName').textContent = weapon.name;
            
            const ammoText = document.getElementById('weaponAmmo');
            if (weapon.ammo === Infinity) {
                ammoText.textContent = 'INF';
                ammoText.classList.remove('low');
            } else {
                ammoText.textContent = `${weapon.ammo} / ${weapon.maxAmmo}`;
                ammoText.classList.toggle('low', weapon.ammo < weapon.maxAmmo * 0.2);
            }
            
            const gunButton = document.getElementById('gunButton');
            gunButton.style.backgroundImage = `url('${weapon.icon}')`;
            gunButton.style.backgroundSize = weapon.iconScale || '60%';
            gunButton.textContent = '';
        }

        function getProjectileSprite(weapon) {
            if (!weapon.projectileIcon) return null;
            let material = projectileSpriteCache.get(weapon.projectileIcon);
            if (!material) {
                const texture = new THREE.TextureLoader().load(weapon.projectileIcon);
                texture.minFilter = THREE.LinearFilter;
                material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                projectileSpriteCache.set(weapon.projectileIcon, material);
            }
            const sprite = new THREE.Sprite(material);
            const scale = weapon.projectileScale || 0.7;
            sprite.scale.set(scale, scale, 1);
            return sprite;
        }
        
        function shoot() {
            const now = Date.now();
            const weapon = WEAPONS[currentWeapon];
            
            if (now - lastShotTime < weapon.fireRate) return;
            if (weapon.ammo !== Infinity && weapon.ammo <= 0) return;
            
            lastShotTime = now;
            
            if (weapon.ammo !== Infinity) {
                weapon.ammo--;
                updateWeaponUI();
            }
            
            const direction = new THREE.Vector3(
                Math.sin(character.rotation.y),
                0,
                Math.cos(character.rotation.y)
            );
            
            if (weapon.spread > 0) {
                direction.x += (Math.random() - 0.5) * weapon.spread;
                direction.z += (Math.random() - 0.5) * weapon.spread;
                direction.normalize();
            }
            
            createProjectile(direction, weapon);
            
            // Muzzle flash
            const flash = new THREE.PointLight(weapon.color, 3, 8);
            flash.position.copy(character.position);
            flash.position.y += 1.5;
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
            
            if (wantedLevel < 5 && Math.random() < 0.2) {
                wantedLevel++;
                updateUI();
            }
        }
        
        function createProjectile(direction, weapon) {
            let projectile;
            
            if (weapon.explosive) {
                const rocketGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.8, 8);
                const rocketMaterial = new THREE.MeshBasicMaterial({ color: 0xff4400 });
                projectile = new THREE.Mesh(rocketGeometry, rocketMaterial);
                projectile.rotation.x = Math.PI / 2;
                projectile.rotation.z = -character.rotation.y;
            } else {
                projectile = getProjectileSprite(weapon);
                if (!projectile) {
                    const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const bulletMaterial = new THREE.MeshBasicMaterial({ color: weapon.color });
                    projectile = new THREE.Mesh(bulletGeometry, bulletMaterial);
                }
            }
            
            projectile.position.copy(character.position);
            projectile.position.y += 1.5;
            projectile.position.x += direction.x * 0.8;
            projectile.position.z += direction.z * 0.8;
            
            projectile.userData = {
                direction: direction.clone(),
                speed: weapon.projectileSpeed,
                damage: weapon.damage,
                explosive: weapon.explosive || false,
                explosionRadius: weapon.explosionRadius || 0,
                lifetime: 100
            };
            
            scene.add(projectile);
            projectiles.push(projectile);
        }
        
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                const data = proj.userData;
                
                proj.position.x += data.direction.x * data.speed;
                proj.position.z += data.direction.z * data.speed;
                data.lifetime--;
                
                // Check NPC collision
                let hit = false;
                for (let j = npcs.length - 1; j >= 0; j--) {
                    const npc = npcs[j];
                    const dist = proj.position.distanceTo(npc.position);
                    
                    if (dist < 1.5) {
                        hit = true;
                        
                        if (data.explosive) {
                            createExplosion(proj.position, data.explosionRadius);
                            damageNPCsInRadius(proj.position, data.explosionRadius, data.damage);
                        } else {
                            damageNPC(npc, data.damage);
                        }
                        break;
                    }
                }
                
                if (hit || data.lifetime <= 0) {
                    scene.remove(proj);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        function damageNPC(npc, damage) {
            npc.userData.health = (npc.userData.health || 100) - damage;
            
            // Flash red
            if (npc.userData.body) {
                const originalColor = npc.userData.body.material.color.getHex();
                npc.userData.body.material.color.setHex(0xff0000);
                setTimeout(() => npc.userData.body.material.color.setHex(originalColor), 100);
            }
            
            if (npc.userData.health <= 0) {
                const wasQuestGiver = npc === questGiverNPC;
                const pending = pendingQuest;
                if (npc.userData.questMarker) {
                    scene.remove(npc.userData.questMarker);
                    npc.userData.questMarker = null;
                }
                // Check if quest target
                if (npc.userData.isQuestTarget && currentQuest) {
                    const progress = questChainProgress.objectiveProgress[currentQuest.id];
                    if (progress) {
                        progress.targetKilled = true;
                        showNotification(`${npc.userData.targetName} eliminated!`);
                    }
                }
                
                scene.remove(npc);
                const index = npcs.indexOf(npc);
                if (index > -1) npcs.splice(index, 1);
                
                if (wasQuestGiver && pending) {
                    clearQuestGiver();
                    makeQuestAvailable(pending);
                }
                
                playerCash += 100;
                updateUI();
            }
        }
        
        function damageNPCsInRadius(center, radius, damage) {
            npcs.forEach(npc => {
                const dist = center.distanceTo(npc.position);
                if (dist < radius) {
                    const damageMult = 1 - (dist / radius);
                    damageNPC(npc, damage * damageMult);
                }
            });
        }
        
        function createExplosion(position, radius) {
            const explosionGeometry = new THREE.SphereGeometry(radius * 0.5, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600, transparent: true, opacity: 0.8 
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(position);
            scene.add(explosion);
            
            const light = new THREE.PointLight(0xff6600, 5, radius * 2);
            light.position.copy(position);
            scene.add(light);
            
            explosions.push({ mesh: explosion, light: light, progress: 0 });
        }
        
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.progress += 0.1;
                
                const scale = 1 + exp.progress * 2;
                exp.mesh.scale.set(scale, scale, scale);
                exp.mesh.material.opacity = Math.max(0, 0.8 - exp.progress);
                exp.light.intensity = Math.max(0, 5 - exp.progress * 5);
                
                if (exp.progress >= 1) {
                    scene.remove(exp.mesh);
                    scene.remove(exp.light);
                    explosions.splice(i, 1);
                }
            }
        }
        
        function holdUp() {
            npcs.forEach(npc => {
                const distance = character.position.distanceTo(npc.position);
                if (distance < 5) {
                    playerCash += 50;
                    if (wantedLevel < 5) wantedLevel++;
                    updateUI();
                }
            });
        }
        
        // ============================================
        // UI UPDATE
        // ============================================
        function updateUI() {
            document.getElementById('healthBarFill').style.width = `${playerHealth}%`;
            document.getElementById('cashAmount').textContent = playerCash.toLocaleString();
            
            for (let i = 1; i <= 5; i++) {
                document.getElementById(`star${i}`).classList.toggle('active', i <= wantedLevel);
            }
        }
        
        // ============================================
        // MINIMAP
        // ============================================
        function updateMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const size = Math.min(rect.width, rect.height);
            if (size <= 0) return;
            
            canvas.width = size;
            canvas.height = size;
            
            const scale = size / WORLD_SIZE;
            const centerX = size / 2;
            const centerY = size / 2;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, size, size);
            
            // Roads
            ctx.fillStyle = '#333';
            for (let i = -2; i <= 2; i++) {
                ctx.fillRect(0, centerY + i * BLOCK_SIZE * scale - 2, size, 4);
                ctx.fillRect(centerX + i * BLOCK_SIZE * scale - 2, 0, 4, size);
            }
            
            // Quest target
            if (currentQuest && currentQuest.objective) {
                let targetLoc = null;
                const obj = currentQuest.objective;
                
                switch (obj.type) {
                    case 'TALK':
                    case 'KILL':
                    case 'REACH_LOCATION':
                        targetLoc = namedLocations[obj.targetLocation];
                        break;
                    case 'DELIVER_ITEM':
                        targetLoc = hasItem(obj.item) ? 
                            namedLocations[obj.toLocation] : namedLocations[obj.fromLocation];
                        break;
                    case 'STEAL_CAR':
                        const prog = questChainProgress.objectiveProgress[currentQuest.id];
                        targetLoc = prog?.hasCar ? 
                            namedLocations[obj.toLocation] : namedLocations[obj.fromLocation];
                        break;
                    case 'BUY':
                        targetLoc = namedLocations[obj.vendorLocation];
                        break;
                }
                
                if (targetLoc) {
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(centerX + targetLoc.x * scale, centerY + targetLoc.z * scale, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // NPCs
            ctx.fillStyle = '#00ff00';
            npcs.forEach(npc => {
                ctx.beginPath();
                ctx.arc(centerX - npc.position.x * scale, centerY - npc.position.z * scale, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Cars
            ctx.fillStyle = '#ffff00';
            cars.forEach(car => {
                ctx.fillRect(centerX - car.position.x * scale - 2, centerY - car.position.z * scale - 1, 4, 2);
            });
            
            // Player
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(centerX - character.position.x * scale, centerY - character.position.z * scale, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Player direction
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - character.position.x * scale, centerY - character.position.z * scale);
            ctx.lineTo(
                centerX - character.position.x * scale + Math.sin(character.rotation.y) * 8,
                centerY - character.position.z * scale + Math.cos(character.rotation.y) * 8
            );
            ctx.stroke();
        }
        
        // ============================================
        // ANIMATION
        // ============================================
        function updateCharacterAnimation(char, isMoving, deltaTime) {
            const walkSpeed = 12;
            const legSwing = 0.8;
            const armSwing = 0.6;
            
            if (isMoving) {
                char.userData.walkTime += walkSpeed * deltaTime;
                const t = char.userData.walkTime;
                
                char.userData.leftLegPivot.rotation.x = Math.sin(t) * legSwing;
                char.userData.rightLegPivot.rotation.x = Math.sin(t + Math.PI) * legSwing;
                char.userData.leftArmPivot.rotation.x = Math.sin(t + Math.PI) * armSwing;
                char.userData.rightArmPivot.rotation.x = Math.sin(t) * armSwing;
            } else {
                char.userData.leftLegPivot.rotation.x *= 0.85;
                char.userData.rightLegPivot.rotation.x *= 0.85;
                char.userData.leftArmPivot.rotation.x *= 0.85;
                char.userData.rightArmPivot.rotation.x *= 0.85;
            }
        }
        
        // ============================================
        // MAIN GAME LOOP
        // ============================================
        let lastTime = 0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000 || 0.016;
            lastTime = currentTime;
            
            // Player movement
            let moveX = 0, moveZ = 0;
            const speed = 0.15;
            
            const isStunned = currentTime < playerStunUntil;
            if (!isStunned) {
                if (keys['KeyW'] || keys['ArrowUp']) moveZ = 1;
                if (keys['KeyS'] || keys['ArrowDown']) moveZ = -1;
                if (keys['KeyA'] || keys['ArrowLeft']) moveX = -1;
                if (keys['KeyD'] || keys['ArrowRight']) moveX = 1;
                if (keys['Space']) shoot();
                if (keys['KeyQ']) { keys['KeyQ'] = false; switchWeapon(); }
                if (keys['Digit1']) { keys['Digit1'] = false; selectWeapon(0); }
                if (keys['Digit2']) { keys['Digit2'] = false; selectWeapon(1); }
                if (keys['Digit3']) { keys['Digit3'] = false; selectWeapon(2); }
                
                if (joystickActive) {
                    moveX = -joystickVector.x;
                    moveZ = -joystickVector.y;
                }
            }
            
            const magnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
            const isMoving = magnitude > 0.1;
            
            if (isMoving) {
                const normalizedX = (moveX / magnitude) * speed;
                const normalizedZ = (moveZ / magnitude) * speed;
                const nextX = character.position.x + normalizedX;
                const nextZ = character.position.z + normalizedZ;
                
                if (!isBlockedByBuilding(nextX, nextZ)) {
                    character.position.x = nextX;
                    character.position.z = nextZ;
                } else {
                    if (!isBlockedByBuilding(nextX, character.position.z)) {
                        character.position.x = nextX;
                    }
                    if (!isBlockedByBuilding(character.position.x, nextZ)) {
                        character.position.z = nextZ;
                    }
                }
                
                character.rotation.y = Math.atan2(normalizedX, normalizedZ);
                
                character.position.x = Math.max(-WORLD_SIZE/2 + 5, Math.min(WORLD_SIZE/2 - 5, character.position.x));
                character.position.z = Math.max(-WORLD_SIZE/2 + 5, Math.min(WORLD_SIZE/2 - 5, character.position.z));
            }
            
            if (currentTime < playerKnockbackEnd) {
                const timeFactor = deltaTime * 60;
                character.position.x += playerKnockbackVel.x * timeFactor;
                character.position.z += playerKnockbackVel.z * timeFactor;
                playerKnockbackVel.multiplyScalar(0.92);
            }
            
            if (!updatePlayerKnockdown(currentTime)) {
                updateCharacterAnimation(character, isMoving, deltaTime);
            }
            
            // NPCs
            npcs.forEach(npc => {
                if (npc.userData.isNPC) {
                    const timeFactor = deltaTime * 60;
                    if (currentTime < (npc.userData.pauseUntil || 0)) {
                        updateCharacterAnimation(npc, false, deltaTime);
                        return;
                    }

                    let target = npc.userData.wanderTarget;
                    if (!target) {
                        target = pickNPCWanderTarget(npc.position);
                        npc.userData.wanderTarget = target;
                    }

                    const toTargetX = target.x - npc.position.x;
                    const toTargetZ = target.z - npc.position.z;
                    const targetDist = Math.sqrt(toTargetX * toTargetX + toTargetZ * toTargetZ);
                    if (targetDist < 2) {
                        npc.userData.pauseUntil = currentTime + 400 + Math.random() * 600;
                        npc.userData.wanderTarget = pickNPCWanderTarget(npc.position);
                    }

                    // Avoid player if too close
                    let steerX = toTargetX;
                    let steerZ = toTargetZ;
                    const distToPlayer = character.position.distanceTo(npc.position);
                    if (distToPlayer < 8) {
                        steerX = npc.position.x - character.position.x;
                        steerZ = npc.position.z - character.position.z;
                    }

                    const steerLen = Math.sqrt(steerX * steerX + steerZ * steerZ) || 1;
                    const moveX = (steerX / steerLen) * npc.userData.speed * timeFactor;
                    const moveZ = (steerZ / steerLen) * npc.userData.speed * timeFactor;

                    const nextX = npc.position.x + moveX;
                    const nextZ = npc.position.z + moveZ;
                    if (isLocationOnRoad(nextX, nextZ)) {
                        npc.userData.wanderTarget = pickNPCWanderTarget(npc.position);
                    } else {
                        npc.position.x = nextX;
                        npc.position.z = nextZ;
                    }

                    npc.rotation.y = Math.atan2(moveX, moveZ);
                    
                    npc.position.x = Math.max(-WORLD_SIZE/2 + 10, Math.min(WORLD_SIZE/2 - 10, npc.position.x));
                    npc.position.z = Math.max(-WORLD_SIZE/2 + 10, Math.min(WORLD_SIZE/2 - 10, npc.position.z));
                    
                    const npcMoving = Math.abs(moveX) > 0.0005 || Math.abs(moveZ) > 0.0005;
                    updateCharacterAnimation(npc, npcMoving, deltaTime);
                }
            });
            
            // Cars
            cars.forEach(car => {
                // Move along the car's facing direction (car body is oriented along +X at rotation.y = 0)
                car.position.x += Math.cos(car.userData.direction) * car.userData.speed;
                car.position.z += Math.sin(car.userData.direction) * car.userData.speed;
                car.rotation.y = car.userData.direction;
                
                // Keep cars locked to their road line
                if (car.userData.roadType === 'horizontal') {
                    car.position.z = car.userData.roadLine;
                } else {
                    car.position.x = car.userData.roadLine;
                }

                if (car.userData.isPolice && car.userData.policeLights) {
                    const blink = Math.floor(currentTime / 200) % 2;
                    car.userData.policeLights.red.visible = blink === 0;
                    car.userData.policeLights.blue.visible = blink === 1;
                }

                const carDist = character.position.distanceTo(car.position);
                if (carDist < 2.6 && currentTime - lastCarHitTime > 700) {
                    lastCarHitTime = currentTime;
                    playerHealth = Math.max(0, playerHealth - 20);
                    updateUI();
                    showNotification('Hit by car!');
                    spawnBloodSplatter(3 + Math.floor(Math.random() * 3));
                    playerStunUntil = currentTime + 1500;
                    playerKnockdownStart = currentTime;
                    playerKnockdownEnd = currentTime + 1500;
                    playerRollSpins = 2 + Math.floor(Math.random() * 2);
                    playerBaseYaw = character.rotation.y;
                    cameraShakeUntil = currentTime + 400;
                    cameraShakeStrength = 0.4;
                    
                    const pushDir = new THREE.Vector3(
                        Math.cos(car.userData.direction),
                        0,
                        Math.sin(car.userData.direction)
                    );
                    const pushSpeed = 1.2;
                    playerKnockbackVel.set(pushDir.x * pushSpeed, 0, pushDir.z * pushSpeed);
                    playerKnockbackEnd = currentTime + 500;
                }
                
                if (car.position.x > WORLD_SIZE / 2) car.position.x = -WORLD_SIZE / 2;
                if (car.position.x < -WORLD_SIZE / 2) car.position.x = WORLD_SIZE / 2;
                if (car.position.z > WORLD_SIZE / 2) car.position.z = -WORLD_SIZE / 2;
                if (car.position.z < -WORLD_SIZE / 2) car.position.z = WORLD_SIZE / 2;
            });
            
            // Projectiles & Explosions
            updateProjectiles();
            updateExplosions();
            
            // Quest system
            checkQuestObjective();
            updatePendingQuestGuidance();
            tryStartPendingQuest();
            updateQuestMarkers(currentTime);
            
            // Camera
            camera.position.x = character.position.x - Math.sin(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.position.z = character.position.z - Math.cos(cameraAngle) * cameraDistance;
            if (currentTime < cameraShakeUntil) {
                const shake = cameraShakeStrength * (1 - (cameraShakeUntil - currentTime) / 400);
                camera.position.x += (Math.random() - 0.5) * shake;
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake;
            }
            camera.lookAt(character.position.x, character.position.y + 2, character.position.z);
            
            // Minimap
            updateMinimap();
            
            renderer.render(scene, camera);
        }
        
        // Start game
        init();
        setTimeout(() => updateWeaponUI(), 100);
    </script>
</body>
</html>
